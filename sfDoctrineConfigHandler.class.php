<?php
/**
 *
 * sfDoctrineConfigHandler parses the PHPDoctrine config file
 *
 * @package    symfony
 * @subpackage config
 * @author     Amadeus
 * @version    SVN: $Id: sfDoctrineConfigHandler.class.php 1415 2006-06-11 08:33:51Z fabien $
 */
class sfDoctrineConfigHandler extends sfYamlConfigHandler
{


  public function execute($configFiles)
  {

    // parse the yaml
    $myConfig = $this->parseYamls($configFiles);

    $myConfig = sfToolkit::arrayDeepMerge(
      isset($myConfig['all']) && is_array($myConfig['all']) ? $myConfig['all'] : array(),
      isset($myConfig[sfConfig::get('sf_environment')]) && is_array($myConfig[sfConfig::get('sf_environment')]) ? $myConfig[sfConfig::get('sf_environment')] : array()
    );

    //get default connection
    $defaultConnection = ($myConfig['database']['default'] !== null) ?
        $myConfig['database']['default'] : null;

    //get attributes
    $attributes = array();
    foreach($myConfig['attributes'] as $key=>$value)
    {
      if($value !== null)
      {
        $key = 'ATTR_'.strtoupper($key);
        switch($key)
        {
            #let doctrine automatically create db tables? (true, false)
            case 'ATTR_CREATE_TABLES':

                $attributes['ATTR_CREATE_TABLES'] = $value == 1 ? 'true':'false';
                break;

            #cache container
            case 'ATTR_CACHE':
                $attributes['ATTR_CACHE'] = constant('Doctrine::CACHE_'.strtoupper($value));
                break;

            #cache directory path
            case 'ATTR_CACHE_DIR':
                $value = $this->replaceConstants($value);
                $value = $this->replacePath($value);
                $attributes['ATTR_CACHE_DIR'] = "'".$value."'";
                break;

            #cache time to live
            case 'ATTR_CACHE_TTL':
                $attributes['ATTR_CACHE_TTL'] = $value;
                break;

            #cache size
            case 'ATTR_CACHE_SIZE':
                $attributes['ATTR_CACHE_SIZE'] = $value;
                break;

            #cache slam defense probability (not used?)
            case 'ATTR_CACHE_SLAM':
                $attributes['ATTR_CACHE_SLAM'] = $value;
                break;

            #batch size
            case 'ATTR_BATCH_SIZE':
                $attributes['ATTR_BATCH_SIZE'] = $value;
                break;

            #collection limit
            case 'ATTR_COLL_LIMIT':
                $attributes['ATTR_COLL_LIMIT'] = $value;
                break;

            #event listener
            case 'ATTR_LISTENER':
                $attributes['ATTR_LISTENER'] = $value;
                break;

            #primary key columns
            case 'ATTR_PK_COLUMNS':
                $attributes['ATTR_PK_COLUMNS'] = $value;
                break;

            #primary key type
            case 'ATTR_PK_TYPE':
                $attributes['ATTR_PK_TYPE'] = constant('Doctrine::'.strtoupper($value).'_KEY');
                break;

            #locking (optimistic, pessimistic)
            case 'ATTR_LOCK_MODE':
                $attributes['ATTR_LOCK_MODE'] =  constant('Doctrine::LOCK_'.strtoupper($value));
                break;

            #name prefix (not used?)
            case 'ATTR_NAME_PREFIX':
                $attributes['ATTR_NAME_PREFIX'] = $value;
                break;

            #enable doctrine side validation (true, false)
            case 'ATTR_VLD':
                $attributes['ATTR_VLD'] = $value == 1 ? 'true':'false';
                break;
        }
      }
    }


    $data[] = '$defaultConnection = "'.$defaultConnection.'";';

    foreach($attributes as $key=>$value)
    {
        $data[] = sprintf('$attributes["%s"] = %s;', $key, $value);
    }

    // compile data
    $retval = sprintf("<?php\n".
                      "// auto-generated by myDoctrineConfigHandler\n".
                      "// date: %s\n%s\n?>",
                      date('Y/m/d H:i:s'), implode("\n", $data));

    return $retval;

  }



}
