++ Requirements

Doctrine requires PHP >= 5.2.3+. it doesn't require any external libraries. For database function call abstraction Doctrine uses PDO which comes bundled with the PHP official release that you get from www.php.net. If you use a 3 in 1 package under windows like Uniform Server, MAMP or any other non official package, you may be required to perform additional configurations.

++ Overview

Doctrine is a tool for object-relational mapping in PHP. It sits on top of PDO and is itself divided into two main layers, The DBAL and the ORM. The picture below shows how the layers of Doctrine work together.

[http://www.doctrine-project.org/images/doctrine-layers.jpg Doctrine Layers]

The DBAL(Database Abstraction Layer) completes and extends the basic database abstraction/independance that is already provided by PDO. The DBAL library can be used standalone, if all you want is a powerful database abstraction layer on top of PDO. The ORM layer depends on the DBAL and therefore, when you load the ORM package the DBAL is already included.

++ About Doctrine

The following section tries to explain where Doctrine stands in the world of ORM tools. The Doctrine ORM is mainly built around the [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record], [http://www.martinfowler.com/eaaCatalog/dataMapper.html Data Mapper] and [http://www.martinfowler.com/eaaCatalog/metadataMapping.html Meta Data Mapping] patterns.

Through extending a specific base class named {{Doctrine_Record}}, all the child classes get the typical ActiveRecord interface (save/delete/etc.) and it allows Doctrine to easily participate in & monitor the lifecycles of your records. The real work, however, is mostly forwarded to other components, like the {{Doctrine_Table}} class. This class has the typical Data Mapper interface, {{createQuery()}}, {{find(id)}}, {{findAll()}}, {{findBy*()}}, {{findOneBy*()}} etc. So the ActiveRecord base class enables Doctrine to manage your records and provides them with the typical ActiveRecord interface whilst the mapping footwork is done elsewhere.

The ActiveRecord approach comes with it's typical limitations. The most obvious is the enforcement for a class to extend a specific base class in order to be persistent (a {{Doctrine_Record}}). In general, the design of your domain model is pretty much restricted by the design of your relational model. There is an exception though. When dealing with inheritance structures, Doctrine provides some sophisticated mapping strategies which allow your domain model to diverge a bit from the relational model and therefore give you a bit more freedom. 

Doctrine is in a continuous development process and we always try to add new features that provide more freedom in the modeling of the domain. However, as long as Doctrine remains mainly an ActiveRecord approach, there will always be a pretty large, (forced) similarity of these two models.

The current situation is depicted in the following picture.

[http://code-factory.org/doctrine-manual-images/relational-bounds.jpg Relational Bounds]

As you see in the picture, the domain model can't drift far away from the bounds of the relational model.

After mentioning these drawbacks, it's time to mention some advantages of the ActiveRecord approach. Apart from the (arguably slightly) simpler programming model, it turns out that the strong similarity of the relational model and the (OO) domain model also has an advantage: It makes it relatively easy to provide powerful generation tools, that can create a basic domain model out of an existing relational schema. And as the domain model can't drift far from the relational model due to the reasons above, such generation and synchronization tools can easily be used throughout the development process. Such tools are one of Doctrine's strengths.

We think that these limitations of the ActiveRecord approach are not that much of a problem for the majority of web applications because the complexity of the business domains is often moderate, but we also admit that the ActiveRecord approach is certainly not suited for complex business logic (which is often approached using Domain-Driven Design) as it simply puts too many restrictions and has too much influence on your domain model.

Doctrine is a great tool to drive the persistence of simple or moderately complex domain models(1) and you may even find that it's a good choice for complex domain models if you consider the trade-off between making your domain model more database-centric and implementing all the mapping on your own (because at the time of this writing we are not aware of any powerful ORM tools for PHP that are not based on an ActiveRecord approach).1) Note that complexity != size. A domain model can be pretty large without being complex and vice versa. Obviously, larger domain models have a greater probability of being complex.

Now you already know a lot about what Doctrine is and what it is not. If you would like to dive in now and get started right away, jump straight to the next chapter "Getting Started".

++ Key Concept

The Doctrine Query Language (DQL) is an object query language. It let's you express queries for single objects or full object graphs, using the terminology of your domain model: class names, field names, relations between classes, etc. This is a powerful tool for retrieving or even manipulating objects without breaking the separation of the domain model (field names, class names, ..) from the relational model (table names, column names, ...).DQL looks very much like SQL and this is intended because it makes it relatively easy to grasp for people knowing SQL. There are, however, a few very important differences you should always keep in mind:

Take this example:

<code type="sql">
FROM User u LEFT JOIN u.Phonenumbers where u.level > 1
</code>

The things to notice about this query:

* We select from **classes** and not **tables**. We are selecting from the {{User}} class/model.
* We join along **associations** (u.Phonenumbers)
* We can reference **fields** (u.level)
* There is no join condition (ON x.y = y.x). The associations between your 
classes and how these are expressed in the database are known to Doctrine (You 
need to make this mapping known to Doctrine, of course. How to do that is 
explained later.).

> **NOTE**
> DQL expresses a query in the terms of your domain model (your classes, the attributes they have, the relations they have to other classes, etc.)

It's very important that we speak about classes, fields and associations between classes here. 'Employee' is **not** a table / table name . It may be that the name of the database table the Employee class is mapped to is indeed named Employee but you should nevertheless adhere to this differentiation of the terminology. This may sound nit picky since, due to the ActiveRecord approach, your relational model is often very similar to your domain model but it's really important. The column names are rarely the same as the field names and as soon as inheritance is involved the relational model starts to diverge from the domain model. You can have a class Employee that is in fact mapped to several tables in the database. At this point it should be clear that talking about "selecting from the Employee table" is simply wrong then. And as Doctrine development continues there will be more features available that allow the 2 models to diverge even more.

++ Further Reading

For people new to object-relational mapping and (object-oriented) domain models we recommend the following literature:

The [http://www.martinfowler.com/books.html books by Martin Fowler] cover a lot of the basic ORM terminology, the different approaches of modeling business logic and the patterns involved.

Another good read is about [http://domaindrivendesign.org/books/#DDD Domain Driven Design]. Though serious Domain-Driven Design is currently not possible with Doctrine, this is an excellent resource for good domain modeling, especially in complex business domains, and the terminology around domain models that is pretty widespread nowadays is explained in depth (Entities, Value Objects, Repositories, ...).