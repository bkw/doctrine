++ DSN, the Data Source Name

In order to connect to a database through Doctrine, you have to create a valid DSN(Data Source Name).

Doctrine supports both PEAR DB/MDB2 like data source names as well as PDO style data source names. The following section deals with PEAR like data source names. If you need more info about the PDO-style data source names see the documentation on [http://www.php.net/pdo pdo].

The DSN consists in the following parts:

||~ DSN part ||~ Description ||
|| phptype    ||  Database backend used in PHP (i.e. mysql , pgsql etc.) ||
|| dbsyntax   ||  Database used with regards to SQL syntax etc. ||
|| protocol   ||  Communication protocol to use ( i.e. tcp, unix etc.) ||
|| hostspec   ||  Host specification (hostname[:port]) ||
|| database   ||  Database to use on the DBMS server ||
|| username   ||  User name for login ||
|| password   ||  Password for login ||
|| proto_opts ||  Maybe used with protocol ||
|| option     ||  Additional connection options in URI query string format. Options are separated by ampersand (&). The Following table shows a non complete list of options: ||

**List of options**

||~ Name   ||~ Description ||
|| charset  || Some backends support setting the client charset. ||
|| new_link || Some RDBMS do not create new connections when connecting to the same host multiple times. This option will attempt to force a new connection. ||

The DSN can either be provided as an associative array or as a string. The string format of the supplied DSN is in its fullest form:

<code>
phptype(dbsyntax)://username:password@protocol+hostspec/database?option=value
</code>

Most variations are allowed:

<code>
phptype://username:password@protocol+hostspec:110//usr/db_file.db
phptype://username:password@hostspec/database
phptype://username:password@hostspec
phptype://username@hostspec
phptype://hostspec/database
phptype://hostspec
phptype:///database
phptype:///database?option=value&anotheroption=anothervalue
phptype(dbsyntax)
phptype
</code>

The currently supported PDO database drivers are: 

||~ Driver name ||~ Supported databases ||
|| fbsql        ||  FrontBase ||
|| ibase        ||  InterBase / Firebird (requires PHP 5) ||
|| mssql        ||  Microsoft SQL Server (NOT for Sybase. Compile PHP --with-mssql)   ||
|| mysql        ||  MySQL ||
|| mysqli       ||  MySQL (supports new authentication protocol) (requires PHP 5) ||
|| oci8         ||  Oracle 7/8/9/10  ||
|| pgsql        ||  PostgreSQL  ||
|| querysim     ||  QuerySim   ||
|| sqlite       ||  SQLite 2 ||

A second DSN format supported is

<code>
phptype(syntax)://user:pass@protocol(proto_opts)/database
</code>

If your database, option values, username or password contain characters used to delineate DSN parts, you can escape them via URI hex encodings:  

||~ Character ||~ Hex Code ||
|| :          ||  %3a      ||
|| /          ||  %2f      || 
|| @          ||  %40      || 
|| +          ||  %2b      || 
|| (          ||  %28      || 
|| )          ||  %29      || 
|| ?          ||  %3f      || 
|| =          ||  %3d      || 
|| &          ||  %26      || 

Please note, that some features may be not supported by all database drivers. 

+++ Examples

**Example 1.** Connect to database through a socket

<code>
mysql://user@unix(/path/to/socket)/pear
</code>

**Example 2.** Connect to database on a non standard port

<code>
pgsql://user:pass@tcp(localhost:5555)/pear
</code>

**Example 3.** Connect to SQLite on a Unix machine using options

<code>
sqlite:////full/unix/path/to/file.db?mode=0666
</code>

**Example 4.** Connect to SQLite on a Windows machine using options

<code>
sqlite:///c:/full/windows/path/to/file.db?mode=0666
</code>

**Example 5.** Connect to MySQLi using SSL

<code>
mysqli://user:pass@localhost/pear?key=client-key.pem&cert=client-cert.pem
</code>

++ Opening New Connections

Opening a new database connection in Doctrine is very easy. If you wish to use [www.php.net/PDO PDO] you can just initialize a new PDO object:

<code type="php">
$dsn = 'mysql:dbname=testdb;host=127.0.0.1';
$user = 'dbuser';
$password = 'dbpass';

$dbh = new PDO($dsn, $user, $password);
$conn = Doctrine_Manager::connection($dbh);
</code>

> **TIP**
> Directly passing a PDO instance to {{Doctrine_Manager::connection()}} will not allow Doctrine to be aware of the username and password for the connection, since their is no way to retrieve it from an existing PDO instance. The username and password is required in order for Doctrine to be able to create and drop databases. To get around this you can manually set the username and password option directly on the {{$conn}} object.

<code type="php">
$conn->setOption('username', 'username');
$conn->setOption('password', 'password');
</code>

++ Lazy Database Connecting

Lazy-connecting to database can save a lot of resources. There might be many times where you don't need an actual database connection, hence its always recommended to use lazy-connecting (that means Doctrine will only connect to database when needed).

This feature can be very useful when using for example page caching, hence not actually needing a database connection on every request. Remember connecting to database is an expensive operation.

In the example below we will show you when you create a new Doctrine connection, the connection to the database isn't created until it is actually needed.

<code type="php">
// At this point no actual connection to the database is created
$conn = Doctrine_Manager::connection('mysql://username:password@localhost/test');

// Issuing this query will create the connection
$users = Doctrine_Query::create()
    ->from('User u')
    ->execute();
</code>

++ Managing connections

From the start Doctrine has been designed to work with multiple connections. Unless separately specified Doctrine always uses the current connection for executing the queries.

**Opening and Retrieving Connections**

{{Doctrine_Manager}} provides the static method {{Doctrine_Manager::connection()}} which opens new connection when arguments are given to it and returns the current connection when no arguments have been speficied.

In this example we will show you to open a new connection and how you can retrieve the current connection:

<code type="php">
$conn = Doctrine_Manager::connection('mysql://username:password@localhost/test', 'connection 1');

$conn2 = Doctrine_Manager::connection();

// $conn2 === $conn
</code>

The current connection is the last opened connection. In the next example we will show how you can get the current connection from the {{Doctrine_Manager}} instance:

<code type="php">
$conn2 = Doctrine_Manager::connection('mysql://username2:password2@localhost/test2', 'connection 2');

$conn2 === $manager->getCurrentConnection();
</code>

**Change Current Connection**

You can change the current connection by calling {{Doctrine_Manager::setCurrentConnection()}}. 

<code type="php">
$manager->setCurrentConnection('connection 1');

$manager->getCurrentConnection(); // $conn
</code>

**Iterate over Connections**

You can iterate over the opened connection by simply passing the manager object to a foreach clause. This is possible since {{Doctrine_Manager}} implements special {{IteratorAggregate}} interface.

<code type="php">
foreach($manager as $conn) {

}
</code>

**Get name of Connection Instance**

You can easily get the name of a {{Doctrine_Connection}} instance with the following code:

<code type="php">
$conn = Doctrine_Manager::connection();

$name = $manager->getConnectionName($conn);
</code>

**Close a Connection**

You can easily close a connection and remove it from the Doctrine connection registry with the following code:

<code type="php">
$conn = Doctrine_Manager::connection();

$manager->closeConnection($conn);
</code>

If you wish to close the connection but not remove it from the Doctrine connection registry you can use the following code instead:

<code type="php">
$conn = Doctrine_Manager::connection();
$conn->close();
</code>

**Get all Connections**

You can retrieve an array of all the registered connections by using the {{Doctrine_Manager::getConnections()}} method like below:

<code type="php">
$conns = $manager->getConnections();
foreach ($conns as $conn) {
  
}
</code>

The above is essentially the same as iterating over the {{Doctrine_Manager}} object like we did earlier. Here it is again:

<code type="php">
foreach ($manager as $conn) {
  
}
</code>

**Count the number of Connections**

You can easily get the number of connections from a {{Doctrine_Manager}} object since it implements the {{Countable}} interface.

<code type="php">
$num = count($manager);
</code>

The above is the same as doing:

<code type="php">
$num = $manager->count();
</code>

**Creating/Dropping Databases**

When you create connections using Doctrine, you gain the ability to easily create and drop the databases related to those connections.

This is as simple as using some functions provided in the {{Doctrine_Manager}} or {{Doctrine_Connection}} classes.

**Drop/create database for all connections**

The following code will iterate over all instantiated connections and call the {{dropDatabases()}}/{{createDatabases()}} function on each one:

<code type="php">
$manager->createDatabases();

$manager->dropDatabases();
</code>

**Drop/create database for specific connection**

You can easily drop or create the database for a specific {{Doctrine_Connection}} instance by calling the {{dropDatabase()}}/{{createDatabase()}} function on the connection instance with the following code:

<code type="php">
$conn = Doctrine_Manager::connection(); // Gets the current connection

$conn->createDatabase();

$conn->dropDatabase();
</code>