++ Introduction

Many times you may find classes having similar things within your models. These things may contain anything related to the schema of the component itself (relations, column definitions, index definitions etc.). One obvious way of refactoring the code is having a base class with some classes extending it.

However inheritance solves only a fraction of things. The following subchapters show how many times using {{Doctrine_Template}} is much more powerful and flexible than using inheritance.

{{Doctrine_Template}} is a class templating system. Templates are basically ready-to-use little components that your Record classes can load. When a template is being loaded its {{setTableDefinition()}} and {{setUp()}} methods are being invoked and the method calls inside them are being directed into the class in question.

++ Core Behaviors

Doctrine comes bundled with some templates that offer out of the box functionality for your models. You can enable these templates in your models very easily. You can do it directly in your Doctrine_Records or you can specify them in your yaml schema if you are managing your models with a yaml schema file.

+++ Versionable

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $this->actAs('Versionable', array('versionColumn' => 'version', 'className' => '%CLASS%Version'));
    }
}
</code>

<code type="yaml">
---
User:
  actAs:
    Versionable:
      versionColumn: version
      className: %CLASS%Version
      auditLog: true # Can be used to optionally turn off the audit log history table
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Timestampable

The 2nd argument array is not required. It defaults to all the values that are present in the example below.

<code type="php">                                              
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $options = array(
            'created' =>  array(
                'name'          => 'created_at',    // Name of created column
                'type'          => 'timestamp',     // Doctrine column data type
                'options'       => array(),         // Array of options for column
                'format'        => 'Y-m-d H:i:s',   // Format of date used with PHP date() function(default)
                'disabled'      => false,           // Disable the created column(default)
                'expression'    => 'NOW()',         // Update column with database expression(default=false)
            )
            'updated' =>  array(
                'name'          => 'updated_at',    // Name of updated column(default)
                'type'          => 'timestamp',     // Doctrine column data type(default)
                'options'       => array(),         // Array of options for column(default)
                'format'        => 'Y-m-d H:i:s',   // Format of date used with PHP date() function(default)
                'disabled'      => false,           // Disable the updated column(default)
                'expression'    => 'NOW()',         // Use a database expression to set column(default=false)
                'onInsert'      => true             // Whether or not to set column onInsert(default)
            )
        );

        $this->actAs('Timestampable', $options);
    }
}
</code>

<code type="yaml">
---
User:
  actAs:
    Timestampable:
      created:
        name: created_at
        type: timestamp
        format:Y-m-d H:i:s
      updated:
        name: updated_at
        type: timestamp
        format: Y-m-d H:i:s
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

If you are only interested in using only one of the columns, such as a created_at timestamp, but not a an updated_at field, set the flag disabled=>true for either of the fields as in the example below. 

<code type="yaml">
---
User:
  actAs:
    Timestampable:
      created:
        name: created_at
        type: timestamp
        format:Y-m-d H:i:s
      updated:
        disabled: true
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Sluggable

If you do not specify the columns to create the slug from, it will default to just using the __toString() method on the model.

<code type="php">                                              
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $this->actAs('Sluggable', array('unique'    => true,
                                        'fields'    => array('username'),
                                        'canUpdate' => true));
    }
}
</code>

<code type="yaml">
---
User:
  actAs:
    Sluggable:
      unique: true
      fields: [username]
      canUpdate: true
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

The unique flag will enforce that the slug created is unique. If it is not unique an auto incremented integer will be appended to the slug before saving to database.

The canUpdate flag will allow the users to manually set the slug value to be used when building the url friendly slug.

+++ I18n

{{Doctrine_I18n}} package is a plugin for Doctrine that provides internationalization support for record classes. In the following example we have a NewsItem class with two fields 'title' and 'content'. We want to have the field 'title' with different languages support. This can be achieved as follows:

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }

    public function setUp()
    {
        $this->actAs('I18n', array('fields' => array('title')));
    }
}
</code>

Now the first time you initialize a new NewsItem record Doctrine initializes the plugin that builds the followings things:

1. Record class called NewsItemTranslation
2. Bi-directional relations between NewsItemTranslation and NewsItem

++++ Creating the I18n table

The I18n table can be created as follows:

<code type="php">
$conn->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

$conn->export->exportClasses(array('NewsItem'));
</code>

The following code example executes two sql statements. When using mysql those statements would look like:

<code type="sql">
CREATE TABLE news_item (id INT NOT NULL AUTO_INCREMENT, content TEXT)
CREATE TABLE news_item_translation (id INT NOT NULL, title VARCHAR(200), lang VARCHAR(20))
</code>

Notice how the field 'title' is not present in the news_item table. Since its present in the translation table it would be a waste of resources to have that same field in the main table. Basically Doctrine always automatically removes all translated fields from the main table.

++++ Using I18n

In the following example we add some data with finnish and english translations:

<code type="php">
$item = new NewsItem();
$item->content = 'This is some content. This field is not being translated.';

$item->Translation['FI']->title = 'Joku otsikko';
$item->Translation['EN']->title = 'Some title';
$item->save();
</code>

Now lets find all items and their finnish translations:

<code type="php">
$items = Doctrine_Query::create()
         ->from('NewsItem n')
         ->leftJoin('n.Translation t INDEXBY t.lang')
         ->where('t.lang = ?')
         ->execute(array('FI'));

$items[0]->Translation['FI']->title; // 'joku otsikko'
</code>

+++ NestedSet

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('NestedSet', array('hasManyRoots' => true, 'rootColumnName' => 'root_id'));
    }
}
</code>

<code type="yaml">
---
User:
  actAs:
    NestedSet:
      hasManyRoots: true
      rootColumnName: root_id
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Searchable

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('Searchable', array('fields' => array('title', 'content')));
    }
}
</code>

<code type="yaml">
---
User:
  actAs:
    Searchable:
      fields: [title, content]
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Geographical

The below is only a demo. The geographical behavior can be used with any data record for determining the number of miles or kilometers between 2 records.

<code type="php">
class Zipcode extends Doctrine_Record
{
  public function setTableDefinition()
  {
    $this->hasColumn('zipcode', 'string', 255);
    $this->hasColumn('city', 'string', 255);
    $this->hasColumn('state', 'string', 2);
    $this->hasColumn('county', 'string', 255);
    $this->hasColumn('zip_class', 'string', 255);
  }

  public function setUp()
  {
    parent::setUp();
    $this->actAs('Geographical');
  }
}
</code>

<code type="yaml">
Zipcode:
  actAs: [Geographical]
  columns:
    zipcode: string(255)
    city: string(255)
    state: string(2)
    county: string(255)
    zip_class: string(255)
</code>

The geographical plugin automatically adds the latitude and longitude columns to the records used for calculating distance between 2 records. Below you will find some example usage:

<code type="php">
$zipcode1 = Doctrine::getTable('Zipcode')->findOneByZipcode('37209');
$zipcode2 = Doctrine::getTable('Zipcode')->findOneByZipcode('37388');

// get distance between to zipcodes
echo $zipcode1->getDistance($zipcode2, $kilometers = false);

// Get the 50 closest zipcodes that are not in the same city
$query = $zipcode1->getDistanceQuery();
$query->orderby('miles asc');
$query->addWhere($query->getRootAlias() . '.city != ?', $zipcode1->city);
$query->limit(50);

$result = $query->execute();

foreach ($result as $zipcode) {
  echo $zipcode->city . " - " . $zipcode->miles . "<br/>"; // $zipcode->kilometers
}
</code>

Get some sample zip code data to test this

http://www.populardata.com/zip_codes.zip

Download and import the csv file with the following code

<code type="php">
function parseCsvFile($file, $columnheadings = false, $delimiter = ',', $enclosure = "\"")
{
    $row = 1;
    $rows = array();
    $handle = fopen($file, 'r');
   
    while (($data = fgetcsv($handle, 1000, $delimiter, $enclosure)) !== FALSE) {
   
        if (!($columnheadings == false) && ($row == 1)) {
            $headingTexts = $data;
        } elseif (!($columnheadings == false)) {
            foreach ($data as $key => $value) {
                unset($data[$key]);
                $data[$headingTexts[$key]] = $value;
            }
            $rows[] = $data;
        } else {
            $rows[] = $data;
        }
        $row++;
    }
   
    fclose($handle);
    return $rows;
}

$array = parseCsvFile('zipcodes.csv', false);

foreach ($array as $key => $value) {
    $zipcode = new Zipcode();
    $zipcode->fromArray($value);
    $zipcode->save();
}
</code>

This chapter describes the usage of various plugins availible for Doctrine. You'll also learn how to create your own plugins. In order to grasp the concepts of this chapter you should already be familiar with the theory behind {{Doctrine_Template}} and {{Doctrine_Record_Generator}}. When refering to plugins we refer to class packages that use templates, generators and listeners extensively. All the introduced components in this chapter can be considered 'core' plugins, that means they reside at the Doctrine main repository. There are other official plugins too which can be found at the homesite of the Sensei project (www.sensei-project.org).

Usually plugins use generators side-to-side with template classes (classes that extend {{Doctrine_Template}}). The common workflow is:

* A new template is being initiliazed
* The template creates the generator and calls initialize() method
* The template is attached to given class

As you may already know templates are used for adding common definitions and options to record classes. The purpose of generators is much more complex. Usually they are being used for creating generic record classes dynamically. The definitions of these generic classes usually depend on the owner class. For example the columns of the auditlog versioning class are the columns of the parent class with all the sequence and autoincrement definitions removed.

+++ Versionable

Doctrine versionable behavior provides a full versioning solution. Lets say we have a NewsItem class that we want to be versioned. This functionality can be applied by simply adding $this->actAs('Versionable') into your record setup. 

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        // the versioning plugin needs version column
        $this->hasColumn('version', 'integer');
    }

    public function setUp()
    {
        $this->actAs('Versionable');
    }
}
</code>

Now when we have defined this record to be versionable, Doctrine does internally the following things:

* It creates a class called NewsItemVersion on-the-fly, the table this record is pointing at is news_item_version
* Everytime a NewsItem object is deleted / updated the previous version is stored into news_item_version
* Everytime a NewsItem object is updated its version number is increased.

++++ Creating the version table

As with all other plugins, the plugin-table, in this case the table that holds the different versions, can be created by enabling Doctrine::EXPORT_PLUGINS. The easiest way to set this is by setting the value of Doctrine::ATTR_EXPORT to Doctrine::EXPORT_ALL. The following example shows the usage:

<code type="php">
$conn->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

$conn->export->exportClasses(array('NewsItem'));
</code>

The following code example executes two sql statements. When using mysql those statements would look like:

<code type="sql">
CREATE TABLE news_item (id INT NOT NULL AUTO_INCREMENT, title VARCHAR(200), content TEXT, version INTEGER)
CREATE TABLE news_item_version (id INT NOT NULL, title VARCHAR(200), content TEXT, version INTEGER)
</code>

++++ Using versioning

<code type="php">
$newsItem = new NewsItem();
$newsItem->title = 'No news is good news';
$newsItem->content = 'All quiet on the western front';

$newsItem->save();
$newsItem->version; // 1

$newsItem->title = 'A different title';
$newsItem->save();
$newsItem->version; // 2
</code>

++++ Reverting changes

{{Doctrine_Record}} provides a method called revert() which can be used for reverting to specified version. Internally Doctrine queries the version table and fetches the data for given version. If the given version is not found a {{Doctrine_Record_Exception}} is being thrown.

<code type="php">
$newsItem->revert(1);

$newsItem->title; // No news is good news
</code>

++++ Advanced usage

There are many options for the versioning plugin. Sometimes you may want to use other version column than 'version'. This can be achieved by giving the options parameter to actAs() method.

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        // the versioning plugin needs version column
        $this->hasColumn('news_version', 'integer');
    }

    public function setUp()
    {
        $this->actAs('Versionable', array('versionColumn' => 'news_version'));
    }
}
</code>

You can also control the name of the versioning record and the name of the version table with option attributes 'className' and 'tableName'.

+++ Soft-delete

Soft-delete is a very simple model behavior which will overrides the delete() functionality and adds a delete column. When delete() is called, instead of deleting the record from the database, a delete flag is set to 1. Below is an example of how to create a model with the SoftDelete behavior being used.

<code type="php">
class SoftDeleteTest extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', null, array('primary' => true));
    }
    
    public function setUp()
    {
        $this->actAs('SoftDelete');
    }
}
</code>

<code type="yaml">
---
SoftDeleteTest:
  actAs: [SoftDelete]
  columns:
    name:
      type: string
      primary: true
</code>

Now lets put the plugin in action.

> **NOTE**
> You are required to enable DQL callbacks in order for all executed queries to have the dql callbacks executed on them. In the SoftDelete behavior they are used to filter the select statements to exclude all records where the deleted flag is set with an additional WHERE condition.

<code type="php">
// Enable dql callbacks.
Doctrine_Manager::getInstance()->setAttribute('use_dql_callbacks', true);

// save a new record
$record = new SoftDeleteTest();
$record->name = 'new record';
$record->save();

$record->delete();
var_dump($record->deleted); // true

// Querying for records excludes deleted records automatically.
$q = Doctrine_Query::create()
        ->from('SoftDeleteTest t');

echo $q->count(); // This would be 0, it would exclude the record saved above because the delete flag was set
// The following SQL would have been executed to get this count
// SELECT COUNT(DISTINCT s.name) AS num_results FROM soft_delete_test s WHERE s.deleted = ? GROUP BY s.name

echo $q->getSql(); // SELECT s.name AS s__name, s.something AS s__something, s.deleted AS s__deleted FROM soft_delete_test s WHERE s.deleted = ?
</code>

++ Simple templates

In the following example we define a template called TimestampTemplate. Basically the purpose of this template is to add date columns 'created' and 'updated' to the record class that loads this template. Additionally this template uses a listener called Timestamp listener which updates these fields based on record actions.

<code type="php">
class TimestampListener extends Doctrine_Record_Listener
{
    public function preInsert(Doctrine_Event $event)
    {
        $event->getInvoker()->created = date('Y-m-d', time());
        $event->getInvoker()->updated = date('Y-m-d', time());
    }
    public function preUpdate(Doctrine_Event $event)
    {
        $event->getInvoker()->created = date('Y-m-d', time());
        $event->getInvoker()->updated = date('Y-m-d', time());
    }
}

class TimestampTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('created', 'date');
        $this->hasColumn('updated', 'date');

        $this->setListener(new TimestampListener());
    }
}
</code>

Lets say we have a class called Blog that needs the timestamp functionality. All we need to do is to add actAs() call in the class definition.

<code type="php">
class Blog extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }
    public function setUp()
    {
        $this->actAs('TimestampTemplate');
    }
}
</code>


++ Templates with relations

Many times the situations tend to be much more complex than the situation in the previous chapter. You may have model classes with relations to other model classes and you may want to replace given class with some extended class.

Consider we have two classes, {{User}} and {{Email}}, with the following definitions:

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');
    }
    public function setUp()
    {
        $this->hasMany('Email', array('local' => 'id', 'foreign' => 'user_id'));
    }
}

class Email extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('address', 'string');
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id', 'foreign' => 'id'));
    }
}
</code>

Now if we extend the User and Email classes and create, for example, classes ExtendedUser and ExtendedEmail, the ExtendedUser will still have a relation to the Email class - not the ExtendedEmail class. We could of course override the setUp() method of the User class and define relation to the ExtendedEmail class, but then we lose the whole point of inheritance. Doctrine_Template can solve this problem elegantly with its dependency injection solution.

In the following example we'll define two templates, UserTemplate and EmailTemplate, with almost identical definitions as the User and Email class had.

<code type="php">
class UserTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');
    }
    public function setUp()
    {
        $this->hasMany('EmailTemplate as Email', array('local' => 'id', 'foreign' => 'user_id'));
    }
}

class EmailTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('address', 'string');
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('UserTemplate as User', array('local' => 'user_id', 'foreign' => 'id'));
    }
}
</code>

Notice how we set the relations. We are not pointing to concrete Record classes, rather we are setting the relations to templates. This tells Doctrine that it should try to find concrete Record classes for those templates. If Doctrine can't find these concrete implementations the relation parser will throw an exception, but before we go ahead of things, here are the actual record classes:

<code type="php">
class User extends Doctrine_Record
{
    public function setUp()
    {
        $this->actAs('UserTemplate');
    }
}

class Email extends Doctrine_Record
{
    public function setUp()
    {
        $this->actAs('EmailTemplate');
    }
}
</code>

Now consider the following code snippet. This does NOT work since we haven't yet set any concrete implementations for the templates.

<code type="php">
$user = new User();
$user->Email; // throws an exception
</code>

The following version works. Notice how we set the concrete implementations for the templates globally using Doctrine_Manager.

<code type="php">
$manager = Doctrine_Manager::getInstance();
$manager->setImpl('UserTemplate', 'User')
        ->setImpl('EmailTemplate', 'Email');

$user = new User();
$user->Email;
</code>

The implementations for the templates can be set at manager, connection and even at the table level.

++ Delegate methods

Besides from acting as a full table definition delegate system, Doctrine_Template allows the delegation of method calls. This means that every method within the loaded templates is available in the record that loaded the templates. Internally the implementation uses magic method called __call() to achieve this functionality.

Lets take an example: we have a User class that loads authentication functionality through a template.

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('fullname', 'string', 30);
    }

    public function setUp()
    {
        $this->actAs('AuthTemplate');
    }
}

class AuthTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 16);
        $this->hasColumn('password', 'string', 16);
    }
    public function login($username, $password)
    {
        // some login functionality here
    }
}
</code>

Now you can simply use the methods found in AuthTemplate within the User class as shown above.

<code type="php">
$user = new User();

$user->login($username, $password);
</code>

You can get the record that invoked the delegate method by using the getInvoker() method of Doctrine_Template. Consider the AuthTemplate example. If we want to have access to the User object we just need to do the following:

<code type="php">
class AuthTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 16);
        $this->hasColumn('password', 'string', 16);
    }
    public function login($username, $password)
    {
        // do something with the Invoker object here
        $object = $this->getInvoker();
    }
}
</code>

++ Multiple Templates

Each class can consists of multiple templates. If the templates contain similar definitions the most recently loaded template always overrides the former.

++ Creating plugins

This subchapter provides you the means for creating your own plugins. Lets say we have various different Record classes that need to have one-to-many emails. We achieve this functionality by creating a generic plugin which creates Email classes on the fly.

We start this task by creating a plugin called EmailPlugin with setTableDefinition() method. Inside the setTableDefinition() method various helper methods can be used for easily creating the dynamic record definition. Commonly the following methods are being used:

<code type="php">
public function initOptions()
public function buildLocalRelation()
public function buildForeignKeys(Doctrine_Table $table)
public function buildForeignRelation($alias = null)
public function buildRelation() // calls buildForeignRelation() and buildLocalRelation()
</code>

<code type="php">
class EmailPlugin extends Doctrine_Record_Generator
{
    public function initOptions()
    {
        $this->setOption('className', '%CLASS%Email');
    }

    public function buildRelation()
    {
    	  $this->buildForeignRelation('Emails');
        $this->buildLocalRelation();
    }
    
    public function setTableDefinition()
    {
        $this->hasColumn('address', 'string', 255, array('email'  => true,
                                                         'primary' => true));
    }
}
</code>

++ Nesting plugins

Below is an example of several behaviors to give a complete wiki database that is versionable, searchable, sluggable, and full I18n.

<code type="php">
class Wiki extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 255);
        $this->hasColumn('content', 'string');
    }

    public function setUp()
    {
        $options = array('fields' => array('title', 'content'));
        $auditLog = new Doctrine_Template_Versionable($options);
        $search = new Doctrine_Template_Searchable($options);
        $slug = new Doctrine_Template_Sluggable(array('fields' => array('title')));
        $i18n = new Doctrine_Template_I18n($options);

        $i18n->addChild($auditLog)
             ->addChild($search)
             ->addChild($slug);

        $this->actAs($i18n);

        $this->actAs('Timestampable');
    }
}
</code>

<code type="yaml">
---
WikiTest:
  actAs:
    I18n:
      fields: [title, content]
      actAs:
        Versionable:
          fields: [title, content]
        Searchable:
          fields: [title, content]
        Sluggable:
          fields: [title]
  columns:
    title: string(255)
    content: string
</code>

++ Generating Files

By default with behaviors the classes which are generated are evaluated at run-time and no files containing the classes are ever written to disk. This can be changed with a configuration option. Below is an example of how to configure the I18n behavior to generate the classes and write them to files instead of evaluating them at run-time.

<code type="php">
class NewsArticle extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 255);
        $this->hasColumn('body', 'string', 255);
        $this->hasColumn('author', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('I18n', array('fields'          => array('title', 'body'),
                                   'generateFiles'   => true,
                                   'generatePath'    => '/path/to/generate'));
    }
}
</code>

Now the behavior will generate a file instead of generating the code and using eval() to evaluate it at runtime.