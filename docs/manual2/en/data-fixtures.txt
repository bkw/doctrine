Data fixtures are meant for loading small sets of test data through your models to populate your database with data to test against. The data fixtures are often used side by side with some kind of unit/functional testing suite.

++ Dumping

You can dump data to fixtures file in many different formats to help you get started with writing your data fixtures. You can dump your data fixtures to one big yaml file like the following:

<code type="php">
Doctrine::dumpData('data.yml');
</code>

Or you can optionally dump all data to individual files. One yaml file per model like the following:

<code type="php">
Doctrine::dumpData('directory', true);
</code>

++ Importing

Importing data fixtures is just as easy as dumping. You can use the {{loadData()}} function:

<code type="php">
Doctrine::loadData('data.yml');
</code>

You can either specify an individual yml file like we have done above, or you can specify an entire directory:

<code type="php">
Doctrine::loadData('directory');
</code>

If you want to append the imported data to the already existing data then you need to use the second argument of the {{loadData()}} function. If you don't specify the second argument as true then the data will be purged before importing.

Here is how you can append instead of purging:

<code type="php">
Doctrine::loadData('data.yml', true);
</code>

++ Writing

You can write your fixtures files manually and load them in to your applications. Below is a sample {{data.yml}} fixtures file. You can also split your data fixtures file up in to multiple files. Doctrine will read all fixtures files and parse them, then load all data.

Imagine a schema with the following relationships:

* Resource hasMany Tag as Tags
* Resource hasOne ResourceType as Type
* ResourceType hasMany Resource as Resources
* Tag hasMany Resource as Resources

> **NOTE**
> All row keys across all yaml data fixtures must be unique. For example below tutorial, doctrine, help, cheat are all unique.

<code type="yaml">
Resource:
  Resource_1:
    name: Doctrine Video Tutorial
    Type: Video
    Tags: [tutorial, doctrine, help]
  Resource_2:
    name: Doctrine Cheat Sheet
    Type: Image
    Tags: [tutorial, cheat, help]

ResourceType:
  Video:
    name: Video
  Image:
    name: Image

Tag:
  tutorial:
    name: tutorial
  doctrine:
    name: doctrine
  help:
    name: help
  cheat:
    name: cheat
</code>

You could optionally specify the Resources each tag is related to instead of specifying the Tags a Resource has.

<code type="yaml">
Tag:
  tutorial:
    name: tutorial
    Resources: [Resource_1, Resource_2]
  doctrine:
    name: doctrine
    Resources: [Resource_1]
  help:
    name: help
    Resources: [Resource_1, Resource_2]
  cheat:
    name: cheat
    Resources: [Resource_1]
</code>

Now you can load those data fixtures by simply calling {{loadData()}} and give it the path to the above {{data.yml}}.

<code type="php">
Doctrine::loadData('/path/to/data.yml');
</code>

++ Fixtures For Nested Sets

Writing a fixtures file for a nested set tree is slightly different from writing regular fixtures files. The structure of the tree is defined like the following:

<code type="yaml">
Category:
  Category_1:
    title: Categories # the root node
    children:
      Category_2:
        title: Category 1
      Category_3:
        title: Category 2
        children:
          Category_4:
            title: Subcategory of Category 2
</code>

> **NOTE**
> Notice how the children of each node is specified under a key named {{children}}. This is a special syntax that models with the {{NestedSet}} behavior enabled on look for.

++ Fixtures For I18n

The fixtures for the {{I18n}} aren't anything custom since the {{I18n}} really is just a normal set of relationships that are built on the fly dynamically:

<code type="yaml">
Article:
  Article_1:
    name: Test article
    Translation:
      en:
        title: Title of article
        body: Body of article
      fr:
        title: French title of article
        body: French body of article
</code>