++ Introduction

The purpose of schema files is to allow you to manage your model definitions directly from a yaml file rather then editing php code. The yaml schema file is parsed and used to generate all your model definitions/classes. This makes Doctrine model definitions much more portable.

Schema files support all the normal things you would write with manual php code. Component to connection binding, relationships, attributes, templates/behaviors, indexes, etc.

++ Short Hand Syntax

Doctrine offers the ability to specify schema in a short hand syntax. A lot of the schema parameters have values they default to, this allows us to abbreviate the syntax and let Doctrine just use its defaults. Below is an example of schema taking advantage of all the shorthand features.

**NOTE**
The detect_relations option will attempt to guess relationships based on column names. In the example below Doctrine knows that User hasOne Contact and will automatically define the relationship.

<code type="yaml">
detect_relations: true

User:
  columns:
    username: string
    password: string
    contact_id: integer

Contact:
  columns:
    first_name: string
    last_name: string
    phone: string
    email: string
    address: string
</code>

++ Expanded Syntax

Here is the none short hand form of the above schema.

<code type="yaml">
User:
  columns:
    username:
      type: string(255)
    password:
      type: string(255)
    contact_id:
      type: integer
  relations:
    Contact:
      class: Contact
      local: contact_id
      foreign: id
      foreignAlias: User
      foreignType: one
      type: one

Contact:
  columns:
    first_name:
      type: string(255)
    last_name:
      type: string(255)
    phone:
      type: string(255)
    email:
      type: string(255)
    address:
      type: string(255)
  relations:
    User:
      class: User
      local: id
      foreign: contact_id
      foreignAlias: Contact
      foreignType: one
      type: one
</code>

In the above example we do not define the detect_relations option, instead we manually define the relationships so we have complete control over the configuration of the local and foreign key, the type and alias of relationship on each end of the relationship.

++ Relationships

When specifying relationships it is only necessary to specify the relationship on the end where the foreign key exists. When the schema file is parsed, it inflects the relationship and builds the opposite end automatically. If you specify the other end of the relationship manually, the auto generation will have no effect.

+++ Detect Relations

Doctrine offers the ability to specify a detect_relations options. This feature provides automatic relationship building based on column names. If you have a User model with a contact_id and a class with the name Contact exists, it will automatically create the relationships between the two.

+++ Customizing Relationships

Doctrine only requires that you specify the relationship on the end where the foreign key exists. The opposite end of the relationship will be inflected and built on the opposite end. The schema syntax offers the ability to customize the relationship alias and type of the opposite end. This is good news because it means you can maintain all the relevant relationship information in one place. Below is an example of how to customize the alias and type of the opposite end of the relationship. It demonstrates the relationships User hasOne Contact and Contact hasOne User as UserModel. Normally it would have automatically generated User hasOne Contact and Contact hasMany User. The foreignType and foreignAlias keywords allow you to customize the foreign relationship.

<code type="yaml">
User:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
  relations:
    Contact:
      foreignType: one
      foreignAlias: UserModel

Contact:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
</code>

You can quickly detect and create the relationships between two models with the detect_relations option like below.

<code type="yaml">
detect_relations: true

User:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    avatar_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)

Avatar:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
    image_file:
      type: string(255)
</code>

The resulting relationships will be User hasOne Avatar and Avatar hasMany User. 

+++ One to One

<code type="yaml">
User:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
  relations:
    Contact:
      foreignType: one

Contact:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
</code>

+++ One to Many

<code type="yaml">
User:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)

Phonenumber:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
    user_id:
      type: integer(4)
  relations:
    User:
      foreignAlias: Phonenumbers
</code>

+++ Many to Many

<code type="yaml">
User:
  columns:
    id:
      type: integer(4)
      autoincrement: true
      primary: true
    username:
      type: string(255)
    password:
      type: string(255)
  attributes:
    export: all
    validate: true

Group:
  tableName: group_table
  columns:
    id:
      type: integer(4)
      autoincrement: true
      primary: true
    name:
      type: string(255)
  relations:
    Users:
      foreignAlias: Groups
      class: User
      refClass: GroupUser

GroupUser:
  columns:
    group_id:
      type: integer(4)
      primary: true
    user_id:
      type: integer(4)
      primary: true
  relations:
    Group:
      foreignAlias: GroupUsers
    User:
      foreignAlias: GroupUsers
</code>

This creates a set of models where User hasMany Groups, Group hasMany Users, GroupUser hasOne User and GroupUser hasOne Group.

++ Features & Examples

+++ Connection Binding

If you're not using schema files to manage your models, you will normally use this code to bind a component to a connection name with the following code:

Create a connection with code like below:

<code type="php">
Doctrine_Manager::connection('mysql://jwage:pass@localhost/connection1', 'connection1');
</code>

Now somewhere in your Doctrine bootstrapping of Doctrine oyu would bind the model to that connection

<code type="php">
Doctrine_Manager::connection()->bindComponent('User', 'conn1');
</code>

Schema files offer the ability to bind it to a specific connection by specifying the connection parameter. If you do not specify the connection the model will just use the current connection instance.

<code type="yaml">
User:
  connection: connection1
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
</code>

+++ Attributes

Doctrine offers the ability to set attributes for your generated models directly in your schema files similar to how you would if you were manually writing your Doctrine_Record child classes.

<code type="yaml">
User:
  connection: connection1
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
  attributes:
    export: none
    validate: false
</code>

+++ Enums

To use enum columns in your schema file you must specify the type as enum and specify an array of values for the possible enum values.

<code type="yaml">
TvListing:
 tableName: tv_listing
 actAs: [Timestampable]
 columns:
   notes:
     type: string
   taping:
     type: enum
     length: 4
     values: ['live', 'tape']
   region:
     type: enum
     length: 4
     values: ['US', 'CA']
</code>

+++ ActAs

You can attach behaviors to your models with the actAs option. You can specify
<code type="yaml">
User:
  connection: connection1
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
# This is an optional syntax which will just use the the defaults which are specified below
# Since they are defaults it is not necessary to type it out
#  actAs: [Timestampable, Sluggable]
  actAs:
    Timestampable:
    Sluggable:
      fields: [username]
      name: slug    # defaults to 'slug'
      type: string  # defaults to 'clob'
      length: 255   # defaults to null. clob doesn't require a length
</code>

+++ Listeners

If you have a listener you'd like attached to a model, you can specify them directly in the yml as well.

<code type="yaml">
User:
  listeners: [ MyCustomListener ]
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
</code>

The above syntax will generated a base class as follows.

<code type="php">
class BaseUser extends Doctrine_Record
{
   ...
   
   public setUp()
   {
       ...
       $this->addListener(new MyCustomListener());
   }
}
</code>

+++ Options

Specify options for your tables and when Doctrine creates your tables from your models the options will be set on the create table statement.

<code type="yaml">
User:
  connection: connection1
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)
  options:
    type: INNODB
    collate: utf8_unicode_ci
    charset: utf8
</code>

+++ Indexes

Please see chapter [doc basic-schema-mapping :index :name] for more information about indexes and their options.

schema.yml
<code type="yml">
UserProfile:
  columns:
    user_id:
      type: integer
      length: 4
      primary: true
      autoincrement: true
    first_name:
      type: string
      length: 20
    last_name:
      type: string
      length: 20
  indexes:
    name_index:
      fields:
        first_name:
          sorting: ASC
          length: 10
          primary: true
        last_name: []
      type: unique
</code>

This is the PHP line of code that is auto-generated inside setTableDefinition() inside your base model class.

<code type="php">
$this->index('name_index', array('fields' => array('first_name' => array('sorting'  => 'ASC',
                                                                         'length'   => '10',
                                                                         'primary'  => true ),
                                                   'last_name' => array()),
                                 'type' => 'unique'));
</code>

+++ Inheritance

Simple inheritance. Read about more about [doc relations:inheritance:simple-inheritance :index :name]. Any columns or relations added to the children classes will be moved to the parent.

<code type="yaml">
Entity:
  columns:
    name: string(255)
    username: string(255)
    password: string(255)

User:
  inheritance:
    extends: Entity
    type: simple

Group:
  inheritance:
    extends: Entity
    type: simple
</code>

Concrete inheritance. Read about more about [doc relations:inheritance:concrete-inheritance :index :name]

<code type="yaml">
TextItem:
  columns:
    topic: string(255)

Comment:
  inheritance:
    extends: TextItem
    type: concrete
  columns:
    content: string(300)
</code>

Column aggregation inheritance. Read about more about [doc relations:inheritance:column-aggregation-inheritance :index :name]. Like simple inheritance, any columns or relationships added to the children will be automatically removed and moved to the parent.

<code type="yaml">
Entity:
  columns:
    name: string(255)
    type: string(255)         # Optional, will be automatically added when it is specified in the child class

User:
  inheritance:
    extends: Entity
    type: column_aggregation  # Optional, it is implied if a keyField or keyValue is present
    keyField: type            # Optional, will default to 'type' and add it to the parent class if type is column aggregation
    keyValue: User            # Optional, will default to the name of the child class if type is column aggregation
  columns:
    username: string(255)
    password: string(255)

Group:
  inheritance:
    extends: Entity
    type: column_aggregation
    keyField: type
    keyValue: Group
  columns:
    description: string(255)
</code>

+++ Column Aliases

If you want the ability alias a column name as something other than the column name in the database this is possible with the " as alias_name" string after the column name.

Example:
<code type="yaml">
User:
  columns:
    login:
      name: login as username
      type: string(255)
    password:
      type: string(255)
</code>

The above example would allow you to access the login column name from the alias "username".

+++ Packages

Doctrine offers the "package" parameter which will generate the models in to sub folders. With large schema files this will allow you to better organize your schemas in to folders.

<code type="yaml">
User:
  package: User
  columns:
    username: string(255)
</code>

The model files from this schema file would be put in a folder named User. You can specify more sub folders by doing "package: User.Models" and the models would be in User/Models

+++ Global Schema Information

Doctrine schemas allow you to specify certain parameters that will apply to all of the models defined in the schema file. Below you can find an example on what global parameters you can set for schema files.

List of global parameters:

||~ Name            ||~ Description                                           ||
|| connection       || Name of connection to bind the models to.              ||
|| attributes       || Array of attributes for models.                        ||
|| actAs            || Array of behaviors for the models to act as.           ||
|| options          || Array of tables options for the models.                ||
|| package          || Package to put the models in.                          ||
|| inheritance      || Array of inheritance information for models            ||
|| detect_relations || Whether or not to try and detect foreign key relations ||

Now here is an example schema where we use some of the above global parameters:

<code type="yaml">
connection: conn_name1
actAs: [Timestampable]
options:
  type: INNODB
package: User
detect_relations: true

User:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    contact_id:
      type: integer(4)
    username:
      type: string(255)
    password:
      type: string(255)

Contact:
  columns:
    id:
      type: integer(4)
      primary: true
      autoincrement: true
    name:
      type: string(255)
</code>

All of the settings at the top will be applied to every model which is defined in that yaml file.

++ Using Schema Files

Once you have defined your schema files you need some code to 

You can use the following set of options when building models:

||~ Name                  ||~ Default               ||~ Description                               ||
|| packagesPrefix         || Package                || What to prefix the middle package models with. ||
|| packagesPath           || #models_path#/packages || Path to write package files. ||
|| generateBaseClasses    || true                   || Whether or not to generate abstract base models containing the definition and a top level class which is empty extends the base. ||
|| generateTableClasses   || true                   || Whether or not to generate a table class for each model. ||
|| baseClassesDirectory   || generated              || Name of the folder to generate the base class definitions in. ||
|| baseClassName          || {{Doctrine_Record}}    || Name of the base Doctrine_Record class. ||
|| suffix                 || .php                   || Extension for your generated models. ||

Now we can use some of the above options to configure our model generation to be slightly different.

<code type="php">
$options = array(
  'packagesPrefix'  =>  'Plugin',
  'baseClassName'   =>  'MyDoctrineRecord',
  'suffix'          =>  '.class.php'
);

// This code will generate the models for schema.yml at /path/to/generate/models
Doctrine::generateModelsFromYaml('/path/to/directory/with/yaml/schema/files', '/path/to/generate/models', $options);
</code>