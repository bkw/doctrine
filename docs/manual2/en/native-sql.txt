++ Introduction

Doctrine_RawSql provides a convenient interface for building raw sql queries. Similar to Doctrine_Query, Doctrine_RawSql provides means for fetching arrays and objects. Whichever way you prefer.

Using raw sql for fetching might be useful when you want to utilize database specific features such as query hints or the CONNECT keyword in Oracle.

Creating a Doctrine_RawSql object is easy:

<code type="php">
$q = new Doctrine_RawSql();
</code>

Optionally a connection parameter can be given and it accepts an instance of {{Doctrine_Connection}}. You learned how to create connections in the [doc connections :name] chapter.

<code type="php">
$q = new Doctrine_RawSql($conn);
</code>

++ Component Queries

The first thing to notice when using {{Doctrine_RawSql}} is that you always have to place the fields you are selecting in curly brackets {}. Also for every selected component you have to call {{addComponent()}}.

The following example should clarify the usage of these:

<code type="php">
$q = new Doctrine_RawSql();

$q->select('{u.*}')
  ->from('user')
  ->addComponent('user', 'User');

$users = $q->execute();
$users[0]; // User object
</code>

> **NOTE**
> Note above that we tell that {{user}} table is bound to class called {{User}} by using the {{addComponent()}} method.

Pay attention to following things:

* Fields must be in curly brackets.
* For every selected table there must be one {{addComponent()}} call.

++ Fetching from Multiple Components

When fetching from multiple components the {{addComponent()}} calls become a bit more complicated as not only do we have to tell which tables are bound to which components, we also have to tell the parser which components belongs to which.

Consider the following models {{User}} and {{Phonenumber}} where {{User}} has many {{Phonenumber}} and {{Phonenumber}} has one {{User}}.

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
    }

    public function setUp()
    {
        $this->hasMany('Phonenumber', array(
                'local' => 'id',
                'foreign' => 'user_id'
            )
        );
    }
}

class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('phonenumber', 'string', 20);
        $this->hasColumn('user_id', 'integer');
    }

    public function setUp()
    {
        $this->hasOne('User', array(
                'local' => 'user_id',
                'foreign' => 'id',
                'onDelete' => 'CASCADE'
            )
        );
    }
}
</code>

In the following example we fetch all {{users}} and their {{phonenumbers}}. First create a new {{Doctrine_RawSql}} object and add the select parts:

<code type="php">
$q = new Doctrine_RawSql();
$q->select('{u.*}, {p.*}');
</code>

Now we need to add the {{FROM}} part to the query with the join to the phonenumber table from the user table and map everything together:

<code type="php">
$q->from('user u LEFT JOIN phonenumber p ON u.id = p.user_id')
</code>

Now we tell that {{user}} table is bound to class called {{User}} we also add an alias for {{User}} class called {{u}}. This alias will be used when referencing the {{User}} class.

<code type="php">
$q->addComponent('u', 'User u');
</code>

Now we add another component that is bound to table {{phonenumber}}:

<code type="php">
$q->addComponent('p', 'u.Phonenumber p');
</code>

> **NOTE**
> Notice how we reference that the {{Phonenumber}} class is the User's phonenumber.

Now we can execute the {{Doctrine_RawSql}} query just like if you were executing a {{Doctrine_Query}} object:

<code type="php">
$users = $q->execute();
echo get_class($users);                      // Doctrine_Collection
echo get_class($users[0]);                   // User
echo get_class($users[0]['Phonenumber'][0]); // Phonenumber
</code>