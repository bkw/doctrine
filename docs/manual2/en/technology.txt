++ Architecture

Doctrine is divided into 3 main packages:

* Doctrine CORE
 * Doctrine
 * Doctrine_Manager
 * Doctrine_Connection
 * Doctrine_Compiler
 * Doctrine_Exception
 * Doctrine_Formatter
 * Doctrine_Object
 * Doctrine_Null
 * Doctrine_Event
 * Doctrine_Overloadable
 * Doctrine_Configurable
 * Doctrine_EventListener

* Doctrine DBAL
 * Doctrine_Expression_Driver
 * Doctrine_Export
 * Doctrine_Import
 * Doctrine_Sequence
 * Doctrine_Transaction
 * Doctrine_DataDict

Doctrine DBAL is also divided into driver packages.

* Doctrine ORM
 * Doctrine_Record
 * Doctrine_Table
 * Doctrine_Relation
 * Doctrine_Expression
 * Doctrine_Query
 * Doctrine_RawSql
 * Doctrine_Collection
 * Doctrine_Tokenizer

There are also plugins for Doctrine:

* Doctrine_Validator
* Doctrine_Hook
* Doctrine_View
* Doctrine_Tree + Doctrine_Node

++ Design Patterns Used

GoF (Gang of Four) design patterns used:

* [http://www.dofactory.com/Patterns/PatternSingleton.aspx Singleton], for forcing only one instance of {{Doctrine_Manager}}
* [http://www.dofactory.com/Patterns/PatternComposite.aspx Composite], for leveled configuration
* [http://www.dofactory.com/Patterns/PatternFactory.aspx Factory], for connection driver loading and many other things
* [http://www.dofactory.com/Patterns/PatternObserver.aspx Observer], for event listening
* [http://www.dofactory.com/Patterns/PatternFlyweight.aspx Flyweight], for efficient usage of validators
* [http://www.dofactory.com/Patterns/PatternFlyweight.aspx Iterator], for iterating through components (Tables, Connections, Records etc.)
* [http://www.dofactory.com/Patterns/PatternState.aspx State], for state-wise connections
* [http://www.dofactory.com/Patterns/PatternStrategy.aspx Strategy], for algorithm strategies

Enterprise application design patterns used:

* [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record], Doctrine is an implementation of this pattern
* [http://www.martinfowler.com/eaaCatalog/unitOfWork.html UnitOfWork], for maintaining a list of objects affected in a transaction
* [http://www.martinfowler.com/eaaCatalog/identityField.html Identity Field], for maintaining the identity between record and database row
* [http://www.martinfowler.com/eaaCatalog/metadataMapping.html Metadata Mapping], for Doctrine DataDict
* [http://www.martinfowler.com/eaaCatalog/dependentMapping.html Dependent Mapping], for mapping in general, since all records extend {{Doctrine_Record}} which performs all mappings
* [http://www.martinfowler.com/eaaCatalog/foreignKeyMapping.html Foreign Key Mapping], for one-to-one, one-to-many and many-to-one relationships
* [http://www.martinfowler.com/eaaCatalog/associationTableMapping.html Association Table Mapping], for association table mapping (most commonly many-to-many relationships)
* [http://www.martinfowler.com/eaaCatalog/lazyLoad.html Lazy Load], for lazy loading of objects and object properties
* [http://www.martinfowler.com/eaaCatalog/queryObject.html Query Object], DQL API is actually an extension to the basic idea of Query Object pattern

++ Speed

: **Lazy initialization** : For collection elements

: **Subselect fetching** : Doctrine knows how to fetch collections efficiently using a subselect.

: **Executing SQL statements later, when needed** : The connection never issues an INSERT or UPDATE until it is actually 
needed. So if an exception occurs and you need to abort the transaction, some statements will never actually be issued. 
Furthermore, this keeps lock times in the database as short as possible (from the late UPDATE to the transaction end).

: **Join fetching** : Doctrine knows how to fetch complex object graphs using joins and subselects

: **Multiple collection fetching strategies** : Doctrine has multiple collection fetching strategies for performance tuning.

: **Dynamic mixing of fetching strategies** : Fetching strategies can be mixed and for example users can be fetched in a 
batch collection while users' phonenumbers are loaded in offset collection using only one query.

: **Driver specific optimizations** : Doctrine knows things like bulk-insert on mysql

: **Transactional single-shot delete** : Doctrine knows how to gather all the primary keys of the pending objects in 
delete list and performs only one sql delete statement per table.

: **Updating only the modified columns.** : Doctrine always knows which columns have been changed.

: **Never inserting/updating unmodified objects.** : Doctrine knows if the the state of the record has changed.

: **PDO for database abstraction** : PDO is by far the fastest availible database abstraction layer for php.