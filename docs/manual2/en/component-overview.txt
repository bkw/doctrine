In the previous chapters we have just barely began to skim the surface. We created a very simple bootstrap and test script where we have been performing small tests as we learn more and more about Doctrine.

In this chapter will go over each of the main components that make up Doctrine and what each of their roles are so that in later chapters you will understand terminology and the purpose of the mentioned classes.

++ Manager

The {{Doctrine_Manager}} class is a singleton and is the root of the configuration hierarchy and is used as a facade for controlling several aspects of Doctrine. You can retrieve the singleton instance with the following code.

<code type="php">
// test.php

// ...
$manager = Doctrine_Manager::getInstance();
</code>

+++ Retrieving Connections

<code type="php">
// test.php

// ...
$connections = $manager->getConnections();
foreach ($connections as $connection) {
    echo $connection->getName() . '<br/>';
}
</code>

The {{Doctrine_Manager}} implements an iterator so you can simple loop over the $manager variable to loop over the connections.

<code type="php">
// test.php

// ...
foreach ($manager as $connection) {
    echo $connection->getName() . '<br/>';
}
</code>

> **NOTE**
> We won't discuss all the connection management functionality possible by {{Doctrine_Manager}} here. You will learn more later about this topic in the [doc connections :name] chapter.

++ Connection

{{Doctrine_Connection}} is a wrapper for database connection. The connection is typically an instance of PDO but because of how Doctrine is designed, it is possible to design your own adapters that mimic the functionality that PDO provides.

The {{Doctrine_Connection}} class handles several things:

* Handles database portability things missing from PDO (eg. LIMIT / OFFSET emulation)
* Keeps track of {{Doctrine_Table}} objects
* Keeps track of records
* Keeps track of records that need to be updated / inserted / deleted
* Handles transactions and transaction nesting
* Handles the actual querying of the database in the case of INSERT / UPDATE / DELETE operations
* Can query the database using DQL. You will learn more about DQL in the [doc dql-doctrine-query-language :name] chapter.
* Optionally validates transactions using Doctrine_Validator and gives full information of possible errors.

+++ Available Drivers

Doctrine has drivers for every PDO-supported database. The supported databases are:

* FreeTDS / Microsoft SQL Server / Sybase
* Firebird/Interbase 6
* Informix
* Mysql
* Oracle
* Odbc
* PostgreSQL
* Sqlite

+++ Creating Connections

<code type="php">
// bootstrap.php

// ...
$conn = Doctrine_Manager::connection('mysql://username:password@localhost/test', 'connection 1');
</code>

+++ Flushing the Connection

When you create new {{User}} records you can flush the connection and save all un-saved objects for that connection. Below is an example:

<code type="php">
// test.php

// ...
$user1 = new User();
$user1->username = 'Jack';

$user2 = new User();
$user2->username = 'jwage';

$conn->flush();
</code>

Calling {{Doctrine_Connection::flush()}} will save all unsaved record instances for that connection. You could of course optionally call {{save()}} on each record instance and it would be the same thing.

<code type="php">
$user1->save();
$user2->save();
</code>

++ Table

{{Doctrine_Table}} holds the schema information specified by the given component (record). For example if you have a {{User}} class that extends {{Doctrine_Record}}, each schema definition call gets delegated to a unique table object that holds the information for later use.

Each {{Doctrine_Table}} is registered by {{Doctrine_Connection}}. You can retrieve the table object for each component easily which is demonstrated right below.

For example, lets say we want to retrieve the table object for the User class. We can do this by simply giving {{User}} as the first argument for the {{Doctrine::getTable()}} method.

+++ Getting a Table Object

In order to get table object for specified record just call {{Doctrine_Record::getTable()}}.

<code type="php">
// test.php

// ...
$userTable = Doctrine::getTable('User');
</code>

+++ Getting Column Information

You can retrieve the column definitions set in {{Doctrine_Record}} by using the appropriate {{Doctrine_Table}} methods. If you need all information of all columns you can simply use:

<code type="php">
// test.php

// ...
$columns = $userTable->getColumns();
</code>

Sometimes this can be an overkill. The following example shows how to retrieve the column names as an array:

<code type="php">
// test.php

// ...
$names = $userTable->getColumnNames();
</code>

+++ Getting Relation Information

You can also get an array of all the {{Doctrine_Relation}} objects by simply calling {{Doctrine_Table::getRelations()}} like the following:

<code type="php">
// test.php

// ...
$relations = $userTable->getRelations();

foreach ($relations as $relation) {
    echo $relation->getLocal();
    echo $relation->getForeign();
}
</code>

You can get the {{Doctrine_Relation}} object for an individual relationship by using the {{Doctrine_Table::getRelation()}} method.

First though we need to actually have a relationship defined between {{User}} and another component. For this example we'll setup a relationship to another model named {{Phonenumber}}:

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 255);
    }

    public function setUp()
    {
        $this->hasMany('Phonenumber as Phonenumbers', array(
                'local' => 'id',
                'foreign' => 'user_id'
            )
        );
    }
}

class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('user_id', 'integer');
        $this->hasColumn('phonenumber', 'string', 55);
    }

    public function setUp()
    {
        $this->hasOne('User', array(
                'local' => 'user_id',
                'foreign' => 'id'
            )
        );
    }
}
</code>

Here is the same example in YAML format. You can read more about yaml in the [doc yaml-schema-files :name] chapter:

<code type="yaml">
User:
  columns:
    name: string(255)

Phonenumber:
  columns:
    user_id: integer
    phonenumber: string(55)
  relations:
    User:
      foreignAlias: Phonenumbers
</code>

Now you can retrieve the relationship object for the {{Phonenumbers}} relationship:

<code type="php">
$relation = $userTable->getRelation('Phonenumbers');
</code>

You can debug all the information of a relationship by using the {{toArray()}} method and using {{print_r()}} to inspect it.

<code type="php">
$array  = $relation->toArray();
print_r($array);
</code>

+++ Finder Methods

{{Doctrine_Table}} provides basic finder methods. These finder methods are very fast to write and should be used if you only need to fetch data from one database table. If you need queries that use several components (database tables) use {{Doctrine_Connection::query()}}.

You can easily find an individual user by its primary key by using the {{find()}} method:

<code type="php">
$user = $userTable->find(2);
</code>

You can also use the {{findAll()}} method to retrieve a collection of all {{User}} records in the database:

<code type="php">
foreach($userTable->findAll() as $user) {
    echo $user->name;
}
</code>

> **CAUTION**
> The {{findAll()}} method is not recommended as it will return all records in the database and if you need to retrieve information from relationships it will lazily load that data causing high query counts. You can learn how to retrieve records and their related records efficiently by reading the [doc dql-doctrine-query-language :name] chapter.

You can also retrieve a set of records with a DQL where condition by using the {{findByDql()}} method:

<code type="php">
foreach($userTable->findByDql("name LIKE '%?%'", 'John') as $user) {
    echo $user->created;
}
</code>

Doctrine also offers some additional magic finder methods that can be read about in the [doc dql-doctrine-query-language:magic-finders :name] section of the DQL chapter.

++++ Custom Table Classes

Adding custom table classes is very easy. Only thing you need to do is name the classes as [componentName]Table and make them extend {{Doctrine_Table}}. So for the {{User}} model we would create a class like the following:

<code type="php">
class UserTable extends Doctrine_Table
{
}
</code>

+++ Custom Finders

You can add custom finder methods to your custom table object. These finder methods may use fast {{Doctrine_Table}} finder methods or [doc dql-doctrine-query-language DQL API] ({{Doctrine_Query::create()}}).

<code type="php">
class UserTable extends Doctrine_Table
{
    public function findByName($name)
    {
        return Doctrine_Query::create()
            ->from('User u')
            ->where('u.name LIKE ?', "%$name%")
            ->execute();
    }
}
</code>

Doctrine will check if a child {{Doctrine_Table}} class called {{UserTable}} exists when calling {{getTable()}} and if it does, it will return an instance of that instead of the default {{Doctrine_Table}}.

<code type="php">
$userTable = Doctrine::getTable('User');

echo get_class($userTable); // UserTable

$users = $userTable->findByName("Jack");
</code>

> **NOTE**
> The above example where we add a {{findByName()}} method is made possible automatically by the magic finder methods. You can read about them in the [doc dql-doctrine-query-language:magic-finders :name] section of the DQL chapter.

++ Record

Doctrine represents tables in your RDBMS with child {{Doctrine_Record}} classes. These classes are where you define your schema information, options, attributes, etc. Instances of these child classes represents records in the database and you can get and set properties on these objects.

+++ Properties

Each assigned column property of {{Doctrine_Record}} represents a database table column. You will learn more about how to define your models in the [doc models-explained :name] chapter.

Now accessing the columns is easy:

<code type="php">
$userTable = Doctrine::getTable('User');

$user = $userTable->find(3);
</code>

Access property through overloading

<code type="php">
$name = $user->name;
</code>

Access property with get()

<code type="php">
$name = $user->get('name);
</code>

Access property with ArrayAccess interface

<code type="php">
$name = $user['name'];
</code>

> **TIP**
> The recommended way to access column values is by using the ArrayAccess as it makes it easy to switch between record and array fetching when needed which you will learn about a little later.

Iterating through the properties of a record can be done in similar way as iterating through an array - by using the foreach construct. This is possible since {{Doctrine_Record}} implements a magic IteratorAggregate interface.

<code type="php">
foreach ($user as $field => $value) {

}
</code>

As with arrays you can use the isset() for checking if given property exists and unset() for setting given property to null.

We can easily check if a property named 'name' exists in a if conditional:

<code type="php">
if (isset($user['name'])) {

}
</code>

If we want to unset the name property we can do it using the {{unset()}} function in php:

<code type="php">
unset($user['name']);
</code>

When you have set values for record properties you can get an array of the modified fields and values using {{Doctrine_Record::getModified()}}

<code type="php">
$user['name'] = 'Jack Daniels';
$user['age'] = 100;

print_r($user->getModified()); // array('name' => 'Jack Daniels', 'age' => 100);
</code>

You can also simply check if a record is modified by using the {{Doctrine_Record::isModified()}} method:

<code type="php">
echo $user->isModified() ? 'Modified':'Not Modified';
</code>

Sometimes you may want to retrieve the column count of given record. In order to do this you can simply pass the record as an argument for the count() function. This is possible since {{Doctrine_Record}} implements a magic Countable interface. The other way would be calling the count() method.

<code type="php">
$colCount = $record->count();
$colCount = count($record);
</code>

{{Doctrine_Record}} offers a special method for accessing the identifier of given record. This method is called {{identifier()}} and it returns an array with identifier field names as keys and values as the associated property values.

<code type="php">
$user['name'] = 'Jack Daniels';
$user->save();

print_r($user->identifier()); // array('id' => 1)
</code>

A common case is that you have an array of values which you need to assign to a given record. It may feel awkward and clumsy to set these values separately. No need to worry though, {{Doctrine_Record}} offers a way for merging a given array or record to another

The {{merge()}} method iterates through the properties of the given record or array and assigns the values to the object

<code type="php">
$values = array(
    'name' => 'someone',
    'age'  => 11,
    'unknownproperty' => '...'
);

// notice that here the unknownproperty won't get assigned
// as the User class doesn't have a column with that name
$user->merge($values);

echo $user->name; // someone
echo $user->age; // 11

echo $user->unknownproperty; // throws exception
</code>

You can also merge a one records values in to another like the following:

<code type="php">
$user1 = new User();
$user1->name = 'jwage';

$user2 = new User();
$user2->merge($user1);

echo $user2->name; // jwage
</code>

> **NOTE**
> {{Doctrine_Record}} also has a {{fromArray()}} method which is identical to {{merge()}} and only exists for consistency with the {{toArray()}} method.

+++ Retrieving Existing Records

Doctrine provides many ways for record retrieval. The fastest ways for retrieving existing records are the finder methods provided by {{Doctrine_Table}}. If you need to use more complex queries take a look at the DQL API.

You can find objects by using the {{Doctrine_Query}} object. It provides a nice interface for building complete and complex DQL queries.

<code type="php">
$users = Doctrine_Query::create()
    ->from('User u')
    ->where("u.name LIKE '%?%'", 'John')
    ->execute();
</code>

> **NOTE**
> All of the finders below provided by {{Doctrine_Table}} use instances of {{Doctrine_Query}} for executing the queries. The objects are built dynamically internally and executed.
>
>Using {{Doctrine_Query}} instances are highly recommend when accessing multiple objects through relationships. If you don't you will have high query counts as the data will be lazy loaded.

<code type="php">
$userTable = Doctrine::getTable("User");
</code>

Now you can find a {{User}} record by its primary key:

<code type="php">
$user = $userTable->find(2);
</code>

Get all the users from the {{User}} model:

<code type="php">
$users = $userTable->findAll();
foreach($users as $user) {
    echo $user->name;
}
</code>

Find {{User}} records with a specified DQL where condition:

<code type="php">
$users = $userTable->findByDql("name LIKE '%?%'", 'John');
foreach($users as $user) {
    echo $user->created;
}
</code>

Doctrine also provides some magic finders where you can find one or a collection of records by any specified column in the model.

<code type="php">
$user = $userTable->findOneByName('jon'); // find user named jon
$users = $userTable->findByAge(10); // find users with age of 10
</code>

> **NOTE**
> The documented magic finders above are made possibly by using PHP's {{[http://us3.php.net/__call __call()]}} overloading functionality. The undefined functions are forwarded to {{Doctrine_Table::__call()}} where the {{Doctrine_Query}} objects are built, executed and returned to the user.

+++ Updating Records

Updating objects is very easy, you just call the {{Doctrine_Record::save()}} method. The other way is to call {{Doctrine_Connection::flush()}} which saves all objects. It should be noted though that flushing is a much heavier operation than just calling save method.

<code type="php">
$userTable = Doctrine::getTable('User');

$user = $userTable->find(2);

if ($user !== false) {
    $user->name = 'Jack Daniels';

    $user->save();
}
</code>

Sometimes you may want to do a direct update. In direct update the objects aren't loaded from database, rather the state of the database is directly updated. In the following example we use DQL UPDATE statement to update all users.

Run a query to make all user names lowercase:

<code type="php">
Doctrine_Query::create()
    ->update('User u')
    ->set('u.name', 'LOWER(u.name)')
    ->execute();
</code>

You can also run an update using objects if you already know the identifier of the record. When you use the {{Doctrine_Record::assignIdentifier()}} method it sets the record identifier and changes the state so that calling {{Doctrine_Record::save()}} performs an update instead of insert.

<code type="php">
$user = new User();
$user->assignIdentifer(1);
$user->name = 'jwage';
$user->save();
</code>

+++ Replacing Records

Replacing records is simple. If you instantiate a new object and save it and then late instantiate another new object with the same primary key or unique index value which already exists in the database, then it will replace/update that row in the database instead of inserting a new one. Below is an example.

First, imagine a User model where username is a unique index.

<code type="php">
$user = new User();
$user->username = 'jwage';
$user->password = 'changeme';
$user->save();
</code>

Issues the following query

<code type="sql">
INSERT INTO user (username, password) VALUES (?,?) ('jwage', 'changeme')
</code>

Now lets create another new object and set the same username but a different password.

<code type="php">
$user = new User();
$user->username = 'jwage';
$user->password = 'newpassword';
$user->replace();
</code>

Issues the following query

<code type="sql">
REPLACE INTO user (id,username,password) VALUES (?,?,?)    (null, 'jwage', 'newpassword')
</code>

The record is replaced/updated instead of a new one being inserted

+++ Refreshing Records

Sometimes you may want to refresh your record with data from the database, use {{Doctrine_Record::refresh()}}.

<code type="php">
$user = Doctrine::getTable('User')->find(2);
$user->name = 'New name';
</code>

Now if you use the {{Doctrine_Record::refresh()}} method it will select the data from the database again and update the properties of the instance.

<code type="php">
$user->refresh();
</code>

+++ Refreshing relationships

The {{Doctrine_Record::refresh()}} method can also refresh the already loaded record relationships, but you need to specify them on the original query.

First lets retrieve a {{User}} with its associated {{Groups}} and a {{Group}} with its associated {{Users}}:

<code type="php">
$user = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Groups')
    ->where('id = ?')
    ->fetchOne(array(1));

$group = Doctrine_Query::create()
    ->from('Group g')
    ->leftJoin('g.Users')
    ->where('id = ?')
    ->fetchOne(array(1));
</code>

Now lets link the retrieved {{User}} and {{Group}} through a {{UserGroup}} instance:

<code type="php">
$userGroup = new UserGroup();
$userGroup->user_id = $user->id;
$userGroup->group_id = $group->id;
$userGroup->save();
</code>

Now if we call {{Doctrine_Record::refresh(true)}} it will refresh the record and its relationships loading the newly created reference we made above:

<code type="php">
$user->refresh(true);
$group->refresh(true);
</code>

You can also lazily refresh all defined relationships of a model using {{Doctrine_Record::refreshRelated()}}:

<code type="php">
$user = Doctrine::getTable('User')->findOneByName('jon');
$user->refreshRelated();
</code>

If you want to refresh an individual specified relationship just pass the name of a relationship to the {{refreshRelated()}} function and it will lazily load the relationship:

<code type="php">
$user->refreshRelated('Phonenumber');
</code>

+++ Deleting Records

Deleting records in Doctrine is handled by {{Doctrine_Record::delete()}}, {{Doctrine_Collection::delete()}} and {{Doctrine_Connection::delete()}} methods.

<code type="php">
$userTable = Doctrine::getTable("User");

$user = $userTable->find(2);

// deletes user and all related composite objects
if($user !== false) {
    $user->delete();
}
</code>

If you have a {{Doctrine_Collection}} of {{User}} records you can call {{delete()}} and it will loop over all records calling {{Doctrine_Record::delete()}} for you.

<code type="php">
$users = $userTable->findAll();

// delete all users and their related composite objects
$users->delete();
</code>

+++ Using Expression Values

There might be situations where you need to use SQL expressions as values of columns. This can be achieved by using {{Doctrine_Expression}} which converts portable DQL expressions to your native SQL expressions.

Lets say we have a class called event with columns timepoint(datetime) and name(string). Saving the record with the current timestamp can be achieved as follows:

<code type="php">
$event = new Event();
$event->name = 'Rock festival';
$event->timepoint = new Doctrine_Expression('NOW()');
$event->save();
</code>

The above code would issue the following SQL query:

<code type="sql">
INSERT INTO event (name, timepoint) VALUES ('Rock festival', NOW())
</code>

+++ Getting Record State

Every {{Doctrine_Record}} has a state. First of all records can be transient or persistent. Every record that is retrieved from database is persistent and every newly created record is considered transient. If a {{Doctrine_Record}} is retrieved from database but the only loaded property is its primary key, then this record has a state called proxy.

Every transient and persistent {{Doctrine_Record}} is either clean or dirty. {{Doctrine_Record}} is clean when none of its properties are changed and dirty when at least one of its properties has changed.

A record can also have a state called locked. In order to avoid infinite recursion in some rare circular reference cases Doctrine uses this state internally to indicate that a record is currently under a manipulation operation.

Below is a table containing all the different states a record can be in with a short description of it:

||~ Name            ||~ Description                                           ||
|| {{Doctrine_Record::STATE_PROXY}}   || Record is in proxy state meaning its persistent but not all of its properties are loaded from the database. ||
|| {{Doctrine_Record::STATE_TCLEAN}}  || Record is transient clean, meaning its transient and none of its properties are changed. ||
|| {{Doctrine_Record::STATE_TDIRTY}}  || Record is transient dirty, meaning its transient and some of its properties are changed. ||
|| {{Doctrine_Record::STATE_DIRTY}}   || Record is dirty, meaning its persistent and some of its properties are changed. ||
|| {{Doctrine_Record::STATE_CLEAN}}   || Record is clean, meaning its persistent and none of its properties are changed. ||
|| {{Doctrine_Record::STATE_LOCKED}}  || Record is locked. ||

You can easily get the state of a record by using the {{Doctrine_Record::state()}} method:

<code type="php">
$user = new User();

if ($user->state() == Doctrine_Record::STATE_TCLEAN) {
    echo 'Record is new and clean';
}
</code>

+++ Getting Object Copy

Sometimes you may want to get a copy of your object (a new object with all properties copied). Doctrine provides a simple method for this: Doctrine_Record::copy().

<code type="php">
$copy = $user->copy();
</code>

Notice that copying the record with copy() returns a new record (state TDIRTY) with the values of the old record, and it copies the relations of that record. If you do not want to copy the relations too, you need to use copy(false).

<code type="php">
// get a copy of user without the relations
$copy = $user->copy(false);
</code>

Using the PHP {{clone}} functionality simply uses this {{copy()}} functionality internally:

<code type="php">
$copy = clone $user;
</code>

+++ Saving a Blank Record

By default Doctrine doesn't execute when save() is being called on an unmodified record. There might be situations where you want to force-insert the record even if it has not been modified. This can be achieved by assigning the state of the record to Doctrine_Record::STATE_TDIRTY.

<code type="php">
$user = new User();
$user->state('TDIRTY');
$user->save();

echo $user->id; // 1
</code>

+++ Mapping Custom Values

There might be situations where you want to map custom values to records. For example values that depend on some outer sources and you only want these values to be available at runtime not persisting those values into database. This can be achieved as follows:

<code type="php">
$user->mapValue('isRegistered', true);

$user->isRegistered; // true
</code>

+++ Serializing

Sometimes you may want to serialize your record objects (possibly for caching purposes). Records can be serialized, but remember: Doctrine cleans all relations, before doing this. So remember to persist your objects into database before serializing them.

<code type="php">
$string = serialize($user);

$user = unserialize($string);
</code>

+++ Checking Existence

Very commonly you'll need to know if given record exists in the database. You can use the exists() method for checking if given record has a database row equivalent.

<code type="php">
$record = new User();

$record->exists(); // false

$record->name = 'someone';
$record->save();

$record->exists(); // true
</code>

+++ Function Callbacks for Columns

{{Doctrine_Record}} offers a way for attaching callback calls for column values. For example if you want to trim certain column, you can simply type:

<code type="php">
$record->call('trim', 'column1');
</code>

++ Collection

{{Doctrine_Collection}} is a collection of records (see Doctrine_Record). As with records the collections can be deleted and saved using {{Doctrine_Collection::delete()}} and {{Doctrine_Collection::save()}} accordingly.

When fetching data from database with either DQL API (see {{Doctrine_Query}}) or rawSql API (see {{Doctrine_RawSql}}) the methods return an instance of {{Doctrine_Collection}} by default.

The following example shows how to initialize a new collection:

<code type="php">
$users = new Doctrine_Collection('User');

// adding some data
$users[0]->name = 'Arnold';

$users[1]->name = 'Somebody';

// finally save it!
$users->save();
</code>

+++ Accessing Elements

You can access the elements of {{Doctrine_Collection}} with {{set()}} and {{get()}} methods or with ArrayAccess interface.

<code type="php">
$userTable = Doctrine::getTable("User");
$users = $userTable->findAll();
</code>

Accessing elements with ArrayAccess interface

<code type="php">
$users[0]->name = "Jack Daniels";

$users[1]->name = "John Locke";
</code>

Accessing elements with get()

<code type="php">
echo $users->get(1)->name;
</code>

+++ Adding new Elements

When accessing single elements of the collection and those elements (records) don't exist Doctrine auto-adds them.

In the following example we fetch all users from database (there are 5) and then add couple of users in the collection.

As with PHP arrays the indexes start from zero.

<code type="php">
$users = $userTable->findAll();

echo count($users); // 5

$users[5]->name = "new user 1";
$users[6]->name = "new user 2";
</code>

You could also optionally omit the 5 and 6 from the array index and it will automatically increment just as a PHP array would:

<code type="php">
$users[]->name = 'new user 3'; // key is 7
$users[]->name = 'new user 4'; // key is 8
</code>

+++ Getting Collection Count

The {{Doctrine_Collection::count()}} method returns the number of elements currently in the collection.

<code type="php">
$users = $userTable->findAll();

echo $users->count();
</code>

Since {{Doctrine_Collection}} implements Countable interface a valid alternative for the previous example is to simply pass the collection as an argument for the count() function.

<code type="php">
echo count($users);
</code>

+++ Saving the Collection

Similar to {{Doctrine_Record}} the collection can be saved by calling the {{save()}} method. When {{save()}} gets called Doctrine issues {{save()}} operations an all records and wraps the whole procedure in a transaction.

<code type="php">
$users = $userTable->findAll();

$users[0]->name = 'Jack Daniels';

$users[1]->name = 'John Locke';

$users->save();
</code>

+++ Deleting the Collection

Doctrine Collections can be deleted in very same way is Doctrine Records you just call delete() method. As for all collections Doctrine knows how to perform single-shot-delete meaning it only performs one database query for the each collection.

For example if we have collection of users. When deleting the collection of users doctrine only performs one query for this whole transaction. The query would look something like:

<code type="sql">
DELETE FROM user WHERE id IN (1,2,3, ... ,N)
</code>

+++ Key Mapping

Sometimes you may not want to use normal indexing for collection elements. For example in some cases mapping primary keys as collection keys might be useful. The following example demonstrates how this can be achieved.

Map the id column

<code type="php">
$user = new User();

$user->setAttribute(Doctrine::ATTR_COLL_KEY, 'id');
</code>

Now user collections will use the values of id column as element indexes:

<code type="php">
$users = Doctrine::getTable('User')->findAll();

foreach($users as $id => $user) {
    echo $id . $user->name;
}
</code>

You may want to map the name column:

<code type="php">
$user = new User();

$user->setAttribute(Doctrine::ATTR_COLL_KEY, 'name');
</code>

Now user collections will use the values of name column as element indexes:

<code type="php">
$users = Doctrine::getTable('User')->findAll();

foreach($users as $name => $user) {
    echo $name . $user->type;
}
</code>

> **CAUTION**
> Note this would only be advisable if the {{name}} column is unique otherwise you will have cases where data cannot be hydrated properly.

+++ Loading Related Records

Doctrine provides means for efficiently retrieving all related records for all record elements. That means when you have for example a collection of users you can load all phonenumbers for all users by simple calling the {{loadRelated()}} method.

However, in most cases you don't need to load related elements explicitly, rather what you should do is try to load everything at once by using the DQL API and JOINS.

The following example uses three queries for retrieving users, their phonenumbers and the groups they belong to.

<code type="php">
$users = Doctrine_Query::create()
    ->from('User u')
    ->execute();
</code>

Now lets load phonenumbers for all users

<code type="php">
$users->loadRelated('Phonenumber');

foreach($users as $user) {
    echo $user->Phonenumber[0]->phonenumber;
    // no additional db queries needed here
}
</code>

The {{loadRelated()}} works an any relation, even associations:

<code type="php">
$users->loadRelated('Group');

foreach($users as $user) {
    echo $user->Group[0]->name;
}
</code>

The example below shows how to do this more efficiently by using the DQL API.

Write a {{Doctrine_Query}} that loads everything in one query:

<code type="php">
$users = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Phonenumber p')
    ->leftJoin('u.Group g')
    ->execute();
</code>

Now when we use the Phonenumbers and Groups no additional database queries are needed:

<code type="php">
foreach($users as $user) {
    echo $user->Phonenumber->phonenumber;
    echo $user->Group->name;
}
</code>

++ Validator

Validation in Doctrine is a way to enforce your business rules in the model part of the MVC architecture. You can think of this validation as a gateway that needs to be passed right before data gets into the persistent data store. The definition of these business rules takes place at the record level, that means in your active record model classes (classes derived from {{Doctrine_Record}}). The first thing you need to do to be able to use this kind of validation is to enable it globally. This is done through the {{Doctrine_Manager}}.

<code type="php">
$manager = Doctrine_Manager::getInstance()
$manager->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_ALL);
</code>

Once you enabled validation, you'll get a bunch of validations automatically:

* Data type validations: All values assigned to columns are checked for the right type. That means if you specified

A column of your record as type 'integer', Doctrine will validate that any values assigned to that column are of this type. This kind of type validation tries to be as smart as possible since PHP is a loosely typed language. For example 2 as well as "7" are both valid integers whilst "3f" is not. Type validations occur on every column (since every column definition needs a type).

* Length validation: As the name implies, all values assigned to columns are validated to make sure that the value does not exceed the maximum length.

You can combine the following constants by using bitwise operations: {{VALIDATE_ALL}}, {{VALIDATE_TYPES}}, {{VALIDATE_LENGTHS}}, {{VALIDATE_CONSTRAINTS}}, {{VALIDATE_NONE}}.


For example to enable all validations except length validations you would use:

<code>
$manager->setAttribute(Doctrine::ATTR_VALIDATE, VALIDATE_ALL & ~VALIDATE_LENGTHS);
</code>

You can read more about this topic in the [doc data-validation :name] chapter.

+++ More Validation

The type and length validations are handy but most of the time they're not enough. Therefore Doctrine provides some mechanisms that can be used to validate your data in more detail.

Validators are an easy way to specify further validations. Doctrine has a lot of predefined validators that are frequently needed such as {{email}}, {{country}}, {{ip}}, {{range}} and {{regexp}} validators. You find a full list of available validators in the [doc data-validation :name] chapter. You can specify which validators apply to which column through the 4th argument of the {{hasColumn()}} method. If that is still not enough and you need some specialized validation that is not yet available as a predefined validator you have three options:

* You can write the validator on your own.
* You can propose your need for a new validator to a Doctrine developer.
* You can use validation hooks.

The first two options are advisable if it is likely that the validation is of general use and is potentially applicable in many situations. In that case it is a good idea to implement a new validator. However if the validation is special it is better to use hooks provided by Doctrine:

* {{validate()}} (Executed every time the record gets validated)
* {{validateOnInsert()}} (Executed when the record is new and gets validated)
* {{validateOnUpdate()}} (Executed when the record is not new and gets validated)

If you need a special validation in your active record you can simply override one of these methods in your active record class (a descendant of {{Doctrine_Record}}). Within these methods you can use all the power of PHP to validate your fields. When a field does not pass your validation you can then add errors to the record's error stack. The following code snippet shows an example of how to define validators together with custom validation:

<code type="php">
class User extends Doctrine_Record
{
    public function setUp()
    {
        $this->hasOne('Email', array('local' => 'email_id'));
    }

    public function setTableDefinition()
    {
        // no special validators used only types
        // and lengths will be validated
        $this->hasColumn('name', 'string', 15);
        $this->hasColumn('email_id', 'integer');
        $this->hasColumn('created', 'integer', 11);
    }

    // Our own validation
    protected function validate()
    {
        if ($this->name == 'God') {
            // Blasphemy! Stop that! ;-)
            // syntax: add(<fieldName>, <error code/identifier>)
            $this->getErrorStack()->add('name', 'forbiddenName');
        }
    }
}

class Email extends Doctrine_Record
{
    public function setTableDefinition()
    {
        // validators 'email' and 'unique' used
        $this->hasColumn('address','string', 150, array('email', 'unique'));
    }
}
</code>

+++ Valid or Not Valid

Now that you know how to specify your business rules in your models, it is time to look at how to deal with these rules in the rest of your application.

++++ Implicit Validation

Whenever a record is going to be saved to the persistent data store (i.e. through calling {{$record->save()}}) the full validation procedure is executed. If errors occur during that process an exception of the type {{Doctrine_Validator_Exception}} will be thrown. You can catch that exception and analyze the errors by using the instance method {{Doctrine_Validator_Exception::getInvalidRecords()}}. This method returns an ordinary array with references to all records that did not pass validation. You can then further explore the errors of each record by analyzing the error stack of each record. The error stack of a record can be obtained with the instance method {{Doctrine_Record::getErrorStack()}}. Each error stack is an instance of the class {{Doctrine_Validator_ErrorStack}}. The error stack provides an easy to use interface to inspect the errors.

++++ Explicit Validation

You can explicitly trigger the validation for any record at any time. For this purpose {{Doctrine_Record}} provides the instance method {{Doctrine_Record::isValid()}}. This method returns a boolean value indicating the result of the validation. If the method returns false, you can inspect the error stack in the same way as seen above except that no exception is thrown, so you simply obtain the error stack of the record that didnt pass validation through {{Doctrine_Record::getErrorStack()}}.

The following code snippet shows an example of handling implicit validation which caused a {{Doctrine_Validator_Exception}}.

<code type="php">
try {
    $user->name = "this is an example of too long name";
    $user->Email->address = "drink@@notvalid..";
    $user->save();
} catch(Doctrine_Validator_Exception $e) {
    $userErrors = $user->getErrorStack();
    $emailErrors = $user->Email->getErrorStack();

    /* Inspect user errors */
    foreach($userErrors as $fieldName => $errorCodes) {
        switch ($fieldName) {
            case 'name':
                // $user->name is invalid. inspect the error codes if needed.
            break;
        }
    }

    /* Inspect email errors */
    foreach($emailErrors as $fieldName => $errorCodes) {
        switch ($fieldName) {
            case 'address':
                // $user->Email->address is invalid. inspect the error codes if needed.
            break;
        }
    }
}
</code>

> **TIP**
> You could also use $e->getInvalidRecords(). The direct way used above is just more simple when you know the records you're dealing with.

You can also retrieve the error stack as a nicely formatted string for easy use in your applications:

<code type="php">
echo $user->getErrorStackAsString();
</code>

It would output an error string that looks something like the following:

<code>
Validation failed in class User

1 field had validation error:

* 1 validator failed on name (length)
</code>

++ Profiler

{{Doctrine_Connection_Profiler}} is an event listener for {{Doctrine_Connection}}. It provides flexible query profiling. Besides the SQL strings the query profiles include elapsed time to run the queries. This allows inspection of the queries that have been performed without the need for adding extra debugging code to model classes.

{{Doctrine_Connection_Profiler}} can be enabled by adding it as an event listener for Doctrine_Connection.

<code type="php">
$profiler = new Doctrine_Connection_Profiler();

$conn->setListener($profiler);
</code>

+++ Basic Usage

Perhaps some of your pages is loading slowly. The following shows how to build a complete profiler report from the connection:

<code type="php">
$time = 0;
foreach ($profiler as $event) {
    $time += $event->getElapsedSecs();
    echo $event->getName() . " " . sprintf("%f", $event->getElapsedSecs()) . "<br>\n";
    echo $event->getQuery() . "<br>\n";
    $params = $event->getParams();
    if( ! empty($params)) {
        var_dump($params);
    }
}
echo "Total time: " . $time  . "<br>\n";
</code>

> **TIP**
> Frameworks like [http://www.symfony-project.com symfony], [http://framework.zend.com Zend], etc. offer web debug toolbars that use this functionality provided by Doctrine for reporting the number of queries executed on every page.

++ Locking Manager

> **NOTE**
> The term 'Transaction' does not refer to database transactions here but to the general meaning of this term.

Locking is a mechanism to control concurrency. The two most well known locking strategies are optimistic and pessimistic locking. The following is a short description of these two strategies from which only pessimistic locking is currently supported by Doctrine.

+++ Optimistic Locking

The state/version of the object(s) is noted when the transaction begins. When the transaction finishes the noted state/version of the participating objects is compared to the current state/version. When the states/versions differ the objects have been modified by another transaction and the current transaction should fail. This approach is called 'optimistic' because it is assumed that it is unlikely that several users will participate in transactions on the same objects at the same time.

+++ Pessimistic Locking

The objects that need to participate in the transaction are locked at the moment the user starts the transaction. No other user can start a transaction that operates on these objects while the locks are active. This ensures that the user who starts the transaction can be sure that noone else modifies the same objects until he has finished his work.

Doctrine's pessimistic offline locking capabilities can be used to control concurrency during actions or procedures that take several HTTP request and response cycles and/or a lot of time to complete.

+++ Examples

The following code snippet demonstrates the use of Doctrine's pessimistic offline locking capabilities.

At the page where the lock is requested get a locking manager instance:

<code type="php">
$lockingManager = new Doctrine_Locking_Manager_Pessimistic();
</code>

> **TIP**
> Ensure that old locks which timed out are released before we try to acquire our lock 300 seconds = 5 minutes timeout. This can be done by using the {{releaseAgedLocks()}} method.

<code type="php">
try
{
    $lockingManager->releaseAgedLocks(300);

    // Try to get the lock on a record
    $gotLock = $lockingManager->getLock(
    // The record to lock. This can be any Doctrine_Record
                        $myRecordToLock,
    // The unique identifier of the user who is trying to get the lock
                       'Bart Simpson'
               );

    if($gotLock)
    {
        echo "Got lock!";
        // ... proceed
    }
    else
    {
        echo "Sorry, someone else is currently working on this record";
    }
} catch(Doctrine_Locking_Exception $dle) {
    echo $dle->getMessage();
    // handle the error
}
</code>

At the page where the transaction finishes get a locking manager instance:

<code type="php">
$lockingMngr = new Doctrine_Locking_Manager_Pessimistic();

try
{
    if ($lockingMngr->releaseLock($myRecordToUnlock, 'Bart Simpson'))
    {
        echo "Lock released";
    }
    else
    {
        echo "Record was not locked. No locks released.";
    }
}
catch(Doctrine_Locking_Exception $dle)
{
    echo $dle->getMessage();
    // handle the error
}
</code>

+++ Technical Details

The pessimistic offline locking manager stores the locks in the database (therefore 'offline'). The required locking table is automatically created when you try to instantiate an instance of the manager and the {{ATTR_CREATE_TABLES}} is set to TRUE. This behavior may change in the future to provide a centralized and consistent table creation procedure for installation purposes.

++ Views

Database views can greatly increase the performance of complex queries. You can think of them as cached queries. {{Doctrine_View}} provides integration between database views and DQL queries.

+++ Using Views

Using views on your database using Doctrine is easy. We provide a nice {{Doctrine_View}} class which provides functionality for creating, dropping and executing views.

The {{Doctrine_View}} class integrates with the {{Doctrine_Query}} class by saving the SQL that would be executed by {{Doctrine_Query}}.

First lets create a new {{Doctrine_Query}} instance to work with:

<code type="php">
$q = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Phonenumber p')
    ->limit(20);
</code>

Now lets create the {{Doctrine_View}} instance and pass it the {{Doctrine_Query}} instance as well as a {{name}} for identifying that database view:

<code type="php">
$view  = new Doctrine_View($q, 'MyView');
</code>

Now we can easily create the view by using the {{Doctrine_View::create()}} method:

<code type="php">
$view->create();
</code>

Alternatively if you want to drop the database view you use the {{Doctrine_View::drop()}} method:

<code type="php">
$view->drop();
</code>

Using views are extremely easy. Just use the {{Doctrine_View::execute()}} for executing the view and returning the results just as a normal {{Doctrine_Query}} object would do.

<code type="php">
$coll  = $view->execute();

foreach ($coll as $record) {
    print_r($record->toArray());
}
</code>

++ Conclusion

So now we have gone over almost all of the major components that make up Doctrine as well as introducing some of the common API operations encountered when using Doctrine on a day-to-day basis.

The examples used in this chapter aren't meant for you to be testing in your bootstrap/test environment. Their only purpose is for you to be introduced to the API of the major components. We will start again with real code examples you can test in the [doc introduction-to-models :name] chapter. First we will take a deeper look at connections in the [doc connections next chapter].