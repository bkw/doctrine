Doctrine supports three types of inheritance strategies which can be mixed together. The three types are simple, concrete and column aggregation. You will learn about these three different types of inheritance and how to use them in this chapter.

++ Simple

Simple inheritance is the easiest and simplest inheritance to use. In simple inheritance all the child classes share the same columns as the parent and all information is stored in the parent table.

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);
    }
}

class User extends Entity 
{ }

class Group extends Entity 
{ }
</code>

++ Concrete

Concrete inheritance creates separate tables for child classes. However in concrete inheritance each class generates a table which contains all columns (including inherited columns). In order to use concrete inheritance you'll need to add explicit {{parent::setTableDefinition()}} calls to child classes as shown below.

<code type="php">
class TextItem extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('topic', 'string', 100);
    }
}

class Comment extends TextItem
{
    public function setTableDefinition() 
    {
        parent::setTableDefinition();    

        $this->hasColumn('content', 'string', 300);
    }
}
</code>

In concrete inheritance you don't necessarily have to define additional columns, but in order to make Doctrine create separate tables for each class you'll have to make iterative {{setTableDefinition()}} calls.

In the following example we have three database tables called {{entity}}, {{user}} and {{group}}. {{Users}} and {{groups}} are both {{entities}}. The only thing we have to do is write 3 classes ({{Entity}}, {{Group}} and {{User}}) and make iterative {{setTableDefinition()}} method calls.

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);
    }
}

class User extends Entity 
{
    public function setTableDefinition() 
    {
        // the following method call is needed in
        // concrete inheritance
        parent::setTableDefinition();
    }
}

class Group extends Entity 
{
    public function setTableDefinition() 
    {
        // the following method call is needed in
        // concrete inheritance
        parent::setTableDefinition();
    }
}
</code>

++ Column Aggregation

In the following example we have one database table called {{entity}}. {{Users}} and {{groups}} are both {{entities}} and they share the same database table.

The {{entity}} table has a column called {{type}} which tells whether an {{entity}} is a {{group}} or a {{user}}. Then we decide that {{users}} are type 1 and groups type 2.

The only thing we have to do is to create 3 records (the same as before) and add the call to the {{Doctrine_Table::setSubclasses()}} method from the parent class.

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);

        // this column is used for column
        // aggregation inheritance
        $this->hasColumn('type', 'integer', 11);

        $this->setSubclasses(array(
                'User'  => array('type' => 1),
                'Group' => array('type' => 2)
            )
        );
    }
}

class User extends Entity
{ }

class Group extends Entity
{ }
</code>

This feature also enable us to query the {{Entity}} table and get a {{User}} or {{Group}} object back if the returned object matches the constraints set in the parent class.

See the code example below for an example of this. First lets save a new {{User}} object:

<code type="php">
$user = new User();
$user->name = 'Bjarte S. Karlsen';
$user->username = 'meus';
$user->password = 'rat';
$user->save();
</code>

Now lets save a new {{Group}} object:

<code type="php">
$group = new Group();
$group->name = 'Users';
$group->username = 'users';
$group->password = 'password';
$group->save();
</code>

Now if we query the {{Entity}} model for the id of the {{User}} we created, the {{Doctrine_Query}} will return an instance of {{User}}.

<code type="php">
$q = Doctrine_Query::create()
    ->from('Entity e')
    ->where('e.id = ?');

$user = $q->fetchOne(array($user->id));
echo get_class($user); // User
</code>

If we do the same thing as above but for the {{Group}} record, it will return an instance of {{Group}}.

<code type="php">
$q = Doctrine_Query::create()
    ->from('Entity e')
    ->where('e.id = ?');

$group = $q->fetchOne(array($group->id));

echo get_class($group); // Group
</code>

> **NOTE**
> The above is possible because of the {{type}} column. Doctrine knows which class each record was created by, so when data is being hydrated it can be hydrated in to the appropriate sub-class.