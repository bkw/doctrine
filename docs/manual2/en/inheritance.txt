Doctrine supports three types of inheritance strategies which can be mixed together. The three types are simple, concrete and column aggregation. You will learn about these three different types of inheritance and how to use them in this chapter.

> **NOTE**
> For this chapter lets delete all our existing schemas and models from our test environment we created and have been using in the earlier chapters.

<code>
$ rm schema.yml
$ touch schema.yml
$ rm -rf models/*
</code>

++ Simple

Simple inheritance is the easiest and simplest inheritance to use. In simple inheritance all the child classes share the same columns as the parent and all information is stored in the parent table.

<code type="php">
// models/Entity.class.php

class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created_at', 'timestamp');
        $this->hasColumn('update_at', 'timestamp');
    }
}
</code>

Now lets create a {{User}} model that extends {{Entity}}:

<code type="php">
// models/User.class.php

class User extends Entity 
{ }
</code>

Do the same thing for the {{Group}} model:

<code type="php">
// models/Group.class.php

class Group extends Entity 
{ }
</code>

Here is the same example in YAML format. You can read more about YAML in the [doc yaml-schema-files :name] chapter:

<code type="yaml">
# schema.yml

# ...
Entity:
  columns:
    username: string(20)
    password: string(16)
    created_at: timestamp
    updated_at: timestamp

User:
  inheritance:
    extends: Entity
    type: column_aggregation
    keyField: type
    keyValue: 1

Group:
  inheritance:
    extends: Entity
    type: column_aggregation
    keyField: type
    keyValue: 2
  columns:
    name: string(30)
</code>

Lets check the SQL that is generated by the above models:

<code type="php">
// test.php

// ...
$sql = Doctrine::generateSqlFromArray(array('Entity', 'User', 'Group'));
echo $sql[0];
</code>

The above code would output the following SQL query:

<code type="sql">
CREATE TABLE entity (id BIGINT AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(16), created_at DATETIME, updated_at DATETIME, type VARCHAR(255), name VARCHAR(30), PRIMARY KEY(id)) ENGINE = INNODB
</code>

> **NOTE**
> When using YAML schema files you are able to define columns in the child classes but when the YAML is parsed the columns are moved to the parent for you automatically. This is only a convenience to you so that you can organize your columns easier.

++ Concrete

Concrete inheritance creates separate tables for child classes. However in concrete inheritance each class generates a table which contains all columns (including inherited columns). In order to use concrete inheritance you'll need to add explicit {{parent::setTableDefinition()}} calls to child classes as shown below.

<code type="php">
// models/TextItem.class.php

class TextItem extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('topic', 'string', 100);
    }
}
</code>

Now lets create a model named {{Comment}} that extends {{TextItem}} and add an extra column named {{content}}:

<code type="php">
// models/Comment.class.php

class Comment extends TextItem
{
    public function setTableDefinition() 
    {
        parent::setTableDefinition();    

        $this->hasColumn('content', 'string', 300);
    }
}
</code>

Here is the same example in YAML format. You can read more about YAML in the [doc yaml-schema-files :name] chapter:

<code type="yaml">
# schema.yml

# ...
TextItem:
  columns:
    topic: string(100)

Comment:
  inheritance:
    extends: TextItem
    type: concrete
  columns:
    content: string(300)
</code>

Lets check the SQL that is generated by the above models:

<code type="php">
// test.php

// ...
$sql = Doctrine::generateSqlFromArray(array('TextItem', 'Comment'));
echo $sql[0] . "\n";
echo $sql[1];
</code>

The above code would output the following SQL query:

<code type="sql">
CREATE TABLE text_item (id BIGINT AUTO_INCREMENT, topic VARCHAR(100), PRIMARY KEY(id)) ENGINE = INNODB
CREATE TABLE comment (id BIGINT AUTO_INCREMENT, topic VARCHAR(100), content TEXT, PRIMARY KEY(id)) ENGINE = INNODB
</code>

In concrete inheritance you don't necessarily have to define additional columns, but in order to make Doctrine create separate tables for each class you'll have to make iterative {{setTableDefinition()}} calls.

In the following example we have three database tables called {{entity}}, {{user}} and {{group}}. {{Users}} and {{groups}} are both {{entities}}. The only thing we have to do is write 3 classes ({{Entity}}, {{Group}} and {{User}}) and make iterative {{setTableDefinition()}} method calls.

<code type="php">
// models/Entity.class.php

class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);
    }
}

// models/User.class.php

class User extends Entity 
{
    public function setTableDefinition() 
    {
        // the following method call is needed in
        // concrete inheritance
        parent::setTableDefinition();
    }
}

// models/Group.class.php
class Group extends Entity 
{
    public function setTableDefinition() 
    {
        // the following method call is needed in
        // concrete inheritance
        parent::setTableDefinition();
    }
}
</code>

Here is the same example in YAML format. You can read more about YAML in the [doc yaml-schema-files :name] chapter:

<code type="yaml">
Entity:
  columns:
    name: string(30)
    username: string(20)
    password: string(16)
    created: integer(11)

User:
  inheritance:
    extends: Entity
    type: concrete

Group:
  tableName: groups
  inheritance:
    extends: Entity
    type: concrete
</code>

Lets check the SQL that is generated by the above models:

<code type="php">
// test.php

// ...
$sql = Doctrine::generateSqlFromArray(array('Entity', 'User', 'Group'));
echo $sql[0] . "\n";
echo $sql[1] . "\n";
echo $sql[2] . "\n";
</code>

The above code would output the following SQL query:

<code type="sql">
CREATE TABLE user (id BIGINT AUTO_INCREMENT, name VARCHAR(30), username VARCHAR(20), password VARCHAR(16), created BIGINT, PRIMARY KEY(id)) ENGINE = INNODB
CREATE TABLE groups (id BIGINT AUTO_INCREMENT, name VARCHAR(30), username VARCHAR(20), password VARCHAR(16), created BIGINT, PRIMARY KEY(id)) ENGINE = INNODB
CREATE TABLE entity (id BIGINT AUTO_INCREMENT, name VARCHAR(30), username VARCHAR(20), password VARCHAR(16), created BIGINT, PRIMARY KEY(id)) ENGINE = INNODB
</code>

++ Column Aggregation

In the following example we have one database table called {{entity}}. {{Users}} and {{groups}} are both {{entities}} and they share the same database table.

The {{entity}} table has a column called {{type}} which tells whether an {{entity}} is a {{group}} or a {{user}}. Then we decide that {{users}} are type 1 and groups type 2.

The only thing we have to do is to create 3 records (the same as before) and add the call to the {{Doctrine_Table::setSubclasses()}} method from the parent class.

<code type="php">
// models/Entity.class.php

class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created_at', 'timestamp');
        $this->hasColumn('update_at', 'timestamp');

        $this->setSubclasses(array(
                'User'  => array('type' => 1),
                'Group' => array('type' => 2)
            )
        );
    }
}

// models/User.class.php
class User extends Entity
{ }

// models/Group.class.php
class Group extends Entity
{ }
</code>

Here is the same example in YAML format. You can read more about YAML in the [doc yaml-schema-files :name] chapter:

<code type="yaml">
Entity:
  columns:
    username: string(20)
    password: string(16)
    created_at: timestamp
    updated_at: timestamp

User:
  inheritance:
    extends: Entity
    type: column_aggregation
    keyField: type
    keyValue: 1

Group:
  inheritance:
    extends: Entity
    type: column_aggregation
    keyField: type
    keyValue: 2
</code>

Lets check the SQL that is generated by the above models:

<code type="php">
// test.php

// ...
$sql = Doctrine::generateSqlFromArray(array('Entity', 'User', 'Group'));
echo $sql[0];
</code>

The above code would output the following SQL query:

<code type="sql">
CREATE TABLE entity (id BIGINT AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(16), created_at DATETIME, updated_at DATETIME, type VARCHAR(255), PRIMARY KEY(id)) ENGINE = INNODB
</code>

> **NOTE**
> Notice how the {{type}} column was automatically added. This is how column aggregation inheritance knows which model each record in the database belongs to.

This feature also enable us to query the {{Entity}} table and get a {{User}} or {{Group}} object back if the returned object matches the constraints set in the parent class.

See the code example below for an example of this. First lets save a new {{User}} object:

<code type="php">
// test.php

// ...
$user = new User();
$user->name = 'Bjarte S. Karlsen';
$user->username = 'meus';
$user->password = 'rat';
$user->save();
</code>

Now lets save a new {{Group}} object:

<code type="php">
// test.php

// ...
$group = new Group();
$group->name = 'Users';
$group->username = 'users';
$group->password = 'password';
$group->save();
</code>

Now if we query the {{Entity}} model for the id of the {{User}} we created, the {{Doctrine_Query}} will return an instance of {{User}}.

<code type="php">
// test.php

// ...
$q = Doctrine_Query::create()
    ->from('Entity e')
    ->where('e.id = ?');

$user = $q->fetchOne(array($user->id));

echo get_class($user); // User
</code>

If we do the same thing as above but for the {{Group}} record, it will return an instance of {{Group}}.

<code type="php">
// test.php

// ...
$q = Doctrine_Query::create()
    ->from('Entity e')
    ->where('e.id = ?');

$group = $q->fetchOne(array($group->id));

echo get_class($group); // Group
</code>

> **NOTE**
> The above is possible because of the {{type}} column. Doctrine knows which class each record was created by, so when data is being hydrated it can be hydrated in to the appropriate sub-class.

We can also query the individual {{User}} or {{Group}} models:

<code type="php">
$q = Doctrine_Query::create()
    ->select('u.id')
    ->from('User u');

echo $q->getSql();
</code>

The above call to {{getSql()}} would output the following SQL query:

<code type="sql">
SELECT e.id AS e__id FROM entity e WHERE (e.type = '1')
</code>

> **NOTE**
> Notice how the {{type}} condition was automatically added to the query so that it will only return records that are of type {{User}}.

++ Conclusion

Now that we've learned about how to take advantage of PHPs inheritance features with our models we can move on to learning about Doctrine [doc behaviors :name]. This is one of the most sophisticated and useful features in Doctrine for accomplishing complex models with small and easy to maintain code.