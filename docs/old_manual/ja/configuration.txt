++ 序文
<code type="php">
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_LISTENER, new MyListener());
</code>


++ 構成のレベル
Doctrineは3つのレベルの構成構造を持ちます。configuration属性をグローバル、接続、テーブルレベルで設定できます。下のレベルと上のレベルで同じ属性が設定されている場合、もっとも上の属性が常に使用されます。例えばグローバルレベルでユーザーが最初fetchmodeを{{Doctrine::FETCH_BATCH}}に設定する場合{{example}}テーブルのfetchmodeを{{Doctrine::FETCH_LAZY}}にします。レイジー取得戦略は'example'テーブルのレコードが取得されるときはいつでも使用されます。

: **グローバルレベル** : グローバルレベルに設定された属性はすべての接続とそれぞれの接続のすべてのテーブルに影響を与えます。
: **接続レベル** : 接続レベルに設定された属性はその接続のそれぞれのテーブルに影響を与えます。    
: **テーブルレベル** : テーブルレベルに設定された属性はそのテーブルのみに影響を与えます。

次の例ではグローバルレベルで属性を設定します:
<code type="php">
// グローバルレベル属性を設定する
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_ALL);
</code>

次の例において与えられた接続上でグローバル属性をオーバーライドします。
<code type="php">
// 接続レベルの属性を設定する
// (この接続上でグローバルレベルの属性をオーバーライドする)

$conn = $manager->openConnection(new PDO('dsn', 'username', 'pw'));

$conn->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_NONE);
</code>

最後の例においてテーブルレベルで接続レベル属性を再度オーバーライドします。
<code type="php">
// テーブルレベルの属性を設定する
// (このテーブル上で接続/グローバルレベル属性をオーバーライドする)

$table = $conn->getTable('User');

$table->setAttribute(Doctrine::ATTR_LISTENER, new UserListener());
</code>


++ 一般的な属性
+++ ポータビリティ

それぞれのデータベース管理システム(DBMS database management system)は 独自の振る舞いを持ちます。例えば、データベースの中には出力においてフィールド名を大文字で始めるもの、小文字で始めるもの、そのままにするものが存在します。これらの特異的な行動はあなたのスクリプトを他のサーバー型に移植することを困難にします。Doctrineはこれらの困難を打ち勝つために努力するのであなたのプログラムは変更無しに複数のDBMS間を切り替えることができます。

ポータビリティ構成オプションを使用してどのポータビリティモードを有効にするか制御できます。構成オプションは{{factrory()}}と{{setOption()}}を通して設定されます。

ポータビリティモードはビット単位なので、{{|}}を使用して結合したり{{^}}を使用して削除できます。どのようにするのかは下記のセクションの例をご覧下さい。

++++ ポータビリティモードの定数


: {{Doctrine::PORTABILITY_ALL}} (デフォルト) : すべてのポータビリティ機能を有効にします。これはデフォルトの設定です。

: {{Doctrine::PORTABILITY_DELETE_COUNT}} : 削除された列の数のレポートを強制します。DBMSの中には{{DELETE FROM}} テーブル名のクエリを単に実行しただけでは削除された列の数をカウントしないものがあります。このモードは{{WHERE 1=1}}を{{DELETE}}クエリの最後に追加することでそのようなDBMSを騙してカウントするように伝えます。

: {{Doctrine::PORTABILITY_EMPTY_TO_NULL}} : データと主力において空の文字列の値をnullに変換します。必要なのはOracleが空の文字列をnullと見なす一方で、多くの他のDBMSは空とnullの違いを知っているからです。

: {{Doctrine::PORTABILITY_ERRORS}} : 他のDBMSと互換性がある、あるドライバのあるエラーメッセージを作成します。

: {{Doctrine::PORTABILITY_FIX_ASSOC_FIELD_NAMES}} : これは連想配列の取得でキーから修飾子を除去します。例えば、SQLiteのようなDBMSの中には、クエリーに修飾子が含まれる場合、連想取に対してデフォルトで省略無しの修飾子付きの名前を使用するものがあります。

: {{Doctrine::PORTABILITY_FIX_CASE}} : すべてのメソッドでテーブルとフィールドの名前を小文字もしくは大文字に変換します。状況は{{CASE_LOWER}}(デフォルト)もしくは{{CASE_UPPER}}のどちらに設定されている{{field_case}}によります。

: {{Doctrine::PORTABILITY_NONE}} : すべてのポータビリティ機能をオフにします 

: {{Doctrine::PORTABILITY_NUMROWS}} : Oracleで{{numRows()}}を動作させるハックを有効にします

: {{Doctrine::PORTABILITY_EXPR}} : ポータブルであない表現が使われたときにDQLのAPIに例外をスローさせます。

: {{Doctrine::PORTABILITY_RTRIM}} : すべてのデータ取得に対してデータ出力の右trimします。これは自動的に固定長の文字の値を右trimし、可変長の文字の値を右trimしないとしても、DMMSのドライバには適用されません。


++++ 例
 
小文字化とトリミングに対してポータビリティを有効にするために{{setAttribute()}}を使います

<code type="php">
$conn->setAttribute('portability',
        Doctrine::PORTABILITY_FIX_CASE | Doctrine::PORTABILITY_RTRIM);
</code>

トリミングを除いてすべてのポータビリティオプションを有効にするために{{setAttribute()}}を使います

<code type="php">
$conn->setAttribute('portability',
        Doctrine::PORTABILITY_ALL ^ Doctrine::PORTABILITY_RTRIM);
</code>


+++ 識別子のクォーティング

{{quoteIdentifier()}}でDB識別子(テーブルとフィールド名)にquoteできます。区切りの形式は使用されているデータベースドライバによります。

注: 区切りされた識別子を使えるからといって使うべきであることは意味しません。一般的にそれらは問題の解決よりも問題を引き起こすことになります。ともかく、フィールド名として予約語がある場合必要になることがあります(この場合、できるなら変更することをお勧めします)。

Doctrine内部のメソッドの中にはクエリーを生成するものがあります。Doctrineの{{quote_identifier}}属性を有効にすることでこれらの生成されたクエリーで識別子をクォートするようDoctrineに伝えることができます。すべてのユーザーが提供したクエリーに対してこのオプションは無関係です。

次の区切りされた識別子を使用することでポータビリティは壊れます: 

* バクティック (`) -- MySQLのため
* ダブルクォート(") -- Oracleのため
* 大括弧([ もしくは ]) -- Accessのため

区切りされた識別子は次のドライバの元で一般的に正しく動作することが知られています: 

* Mssql
* Mysql
* Oracle
* Pgsql
* Sqlite
* Firebird

{{ATTR_QUOTE_IDENTIFIER}}オプションを使うとき、フィールド識別子のｓべては自動的に結果のSQL命令文でクォートされます:

<code type="php">
$conn->setAttribute(Doctrine::ATTR_QUOTE_IDENTIFIER, true);
</code>

はすべてのフィールド名がバクティック演算子'`'(MySQL)でクォートされたSQL命令文になります。

<code type="sql">
SELECT * FROM `sometable` WHERE `id` = '123'
</code>

対照:

<code type="sql">
SELECT * FROM sometable WHERE id='123'
</code>


+++ エクスポートする

export属性はクラスをエクスポートするときに何をエクスポートすべきなのかDoctrineに伝えます。

export()を呼び出すときに何もエクスポートしたくない場合:

<code type="php">
$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_NONE);
</code>

テーブルのみ(制約無し)をエクスポートするため:

<code type="php">
$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_TABLES);
// もしくは次の方法で
$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL ^ Doctrine::EXPORT_CONSTRAINTS);
</code>

すべて(テーブルと制約)をエクスポートするため:

<code type="php">
$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);
</code>

+++ イベントリスナー

<code type="php">
// デフォルトのイベントリスナーを設定する
$manager->setAttribute(Doctrine::ATTR_LISTENER, new MyListener());
</code>
++ 命名規約の属性

命名規約の属性はテーブル、インデックスとシーケンスなどの異なるデータベース関連の要素のネーミングに影響します。データベースからスキーマをクラスにインポートするときとクラスをデータベースにエクスポートするとき、基本的にすべての命名規約は両方の方法に影響します。

ですのでデフォルトではDoctrineのインデックスに対する命名規約は%s_idxです。あなたが設定したインデックスが特別な接尾辞を取得するだけでなくインポートされたクラスも接尾辞無しの同等のものにマップされたそれらのインデックスを取得します。これはすべての命名規約属性に当てはまります。

+++ インデックス名の形式

Doctrine::ATTR_IDXNAME_FORMATはインデックスの命名規約を変更するために使われます。デフォルトではDoctrineは[name]_idxのフォーマットを使用します。'ageindex'という名前のインデックスの定義は実際には'ageindex_idx'に変換されます。

<code type="php">
// インデックスの命名規約を変更する
$manager->setAttribute(Doctrine::ATTR_IDXNAME_FORMAT, '%s_index');
</code>

+++ シーケンス名の形式

Doctrine::ATTR_IDXNAME_FORMATと同じように、Doctrine::ATTR_SEQNAME_FORMAT はシーケンスの命名規約を変更するために使われます。デフォルトではDoctrineは[name]_seq,の形式を使うので、hence creating a new sequence with the name of 'mysequence'の名前を持つ新しいシーケンスは'mysequence_seq'という名前のシーケンスの作成につながります。

<code type="php">
// シーケンスの命名規約を変更する
$manager->setAttribute(Doctrine::ATTR_IDXNAME_FORMAT, '%s_sequence');
</code>

+++ テーブル名の形式

+++ データベース名の形式

<code type="php">
// データベースの命名規約を変更する
$manager->setAttribute(Doctrine::ATTR_DBNAME_FORMAT, 'myframework_%s');
</code>

++ バリデーション属性

Doctrineはバリデートするものを完全に制御する方法を提供します。バリデーションの手続きはDoctrine::ATTR_VALIDATEで制御されます。

バリデーションモードはビット単位なので、{{|}}を使用して組み合わせたり、{{^}}で除去できます。方法は下記の例をご覧下さい。

+++ バリデーションモード定数

: {Doctrine::VALIDATE_NONE} : 全体のバリデーションの手続きを無効にします。これはデフォルトの値です。

: {Doctrine::VALIDATE_LENGTHS} : Doctrineにすべてのフィールドの長さをバリデートさせます。

: {Doctrine::VALIDATE_TYPES} : Doctrineにすべてのフィールドの型をバリデートさせます。Doctrineは型のバリデーションをゆるめます。これは例えば'13.3'の値を持つ文字列は整数としてではなく'13'として渡されます。

: {Doctrine::VALIDATE_CONSTRAINTS} : Doctrineにnotnull,emailといったすべてのフィールド制約をバリデートさせます。

: {Doctrine::VALIDATE_ALL} : すべてのバリデーションをオンにします。

+++ 例

すべてのバリデーションをオンにします:

<code type="php">
$manager->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_ALL);
</code>

長さと型をバリデートし制約はバリデートしない:

<code type="php">
$manager->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_LENGTHS | Doctrine::VALIDATE_TYPES);
</code>
