この章ではDoctrineで利用できる様々なプラグインを説明します。プラグインというときDoctrine_Pluginを拡張するクラスを指します。この章のすべてのコンポーネントは'コア'プラグインとして考えられています。すなわちDoctrineのメインリポジトリに設置されていることを意味します。Sensei project (www.sensei-project.org)のホームサイトにも他の公式プラグインが存在します。

通常プラグインはテンプレートクラス(Doctrine_Templateを拡張するクラス)で隅々で使われています。共通のワークフローは以下の通りです:

# 新しいテンプレートが初期化される
# テンプレートがプラグインとbuildPluginDefinition()メソッドを作成する
# テンプレートが与えられたクラスに追加される

すでにご存じのようにテンプレートは共通のクラスとテンプレートをレコードクラスに追加するために使われます。プラグインの目的はより遙かに複雑です。通常それらは一般的なレコードクラスを動的に作るために使われています。これらの一般的なクラスの定義はオーナーのクラスによります。たとえば、auditlogバージョニングクラスのカラムはすべてのシーケンスと除去されたオートインクリメントの定義を持つ親クラスのカラムです。



++ I18nによる国際化

Doctrine_I18nはレコードクラスに対して国際化のサポートを提供するDoctrineのためのプラグインです。次の例において2つのフィールドの'title'と'content'を持つNewsItemクラスがあるとします。'title'フィールドに異なる言語サポートを持たせたいとします。これは次のように実現できます:

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }

    public function setUp()
    {
        $this->actAs('I18n', array('fields' => array('title')));
    }
}
</code>

新しいNewsItemレコードを初期化したときにDoctrineは次の内容をビルドするプラグインを初期化します:

1. NewsItemTranslationという名前のレコードクラス
2. NewsItemTranslationとNewsItem間の双方向のリレーション

+++ I18nテーブルを作成する

I18nテーブルは次のように作成できます:

<code type="php">
$conn->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

$conn->export->exportClasses(array('NewsItem'));
</code>

次のコードの例は2つのSQL命令文を実行します。mysqlを使うときこれらの命令文は次のようになります:

<code>
CREATE TABLE news_item (id INT NOT NULL AUTO_INCREMENT, content TEXT)
CREATE TABLE news_item_translation (id INT NOT NULL, title VARCHAR(200), lang VARCHAR(20))
</code>

'title'フィールドはnews_itemテーブルに含まれないことに注意してください。 translationテーブルにそれが存在するので、メインテーブルに同じフィールドがあるのはリソースの無駄遣いです。基本的にDoctrineは常にメインテーブルからすべてのtranslatedテーブルを削除します。

+++ I18nを使う

次の例においてフィンランド語と英語の翻訳を持つデータを追加します:

<code type="php">
$item = new NewsItem();
$item->content = 'This is some content. This field is not being translated.';

$item->Translation['FI']->title = 'Joku otsikko';
$item->Translation['EN']->title = 'Some title';
$item->save();
</code>

すべての項目とそれらのフィンランド語訳を見つけてみましょう:

<code type="php">
$items = Doctrine_Query::create()
         ->from('NewsItem n')
         ->leftJoin('n.Translation t INDEXBY t.lang')
         ->where('t.lang = ?')
         ->execute(array('FI'));

$items[0]->Translation['FI']->title; // 'joku otsikko'
</code>


++ AuditLogとバージョニング
Doctrine_AuditLogはフルバージョニングの解決方法を提供します。バージョニングしたいNewsItemクラスがあるとします。この機能は単に$this->actAs('Versionable')をレコードに追加するだけで適用されます。 

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        // バージョニングプラグインはversionカラムが必要
        $this->hasColumn('version', 'integer');
    }

    public function setUp()
    {
        $this->actAs('Versionable');
    }
}
</code>

このレコードをバージョニングができるとき、Doctrineは内部で次のことを行います:

* NewsItemVersionというクラスが直接作成され、このレコードが指定するテーブルはnews_item_version
* NewsItemオブジェクトが削除/更新されるたびに前のバージョンがnews_item_versionに保存される
* NewsItemオブジェクトが更新されるたびにバージョン番号が増える。

+++ バージョンテーブルを作成する

すべてのほかのプラグインと同様に、プラグインテーブルは、この場合、異なるバージョンを持つテーブルは、Doctrine::EXPORT_PLUGINSを有効にすることで作成できます。これを設定するためにもっとも簡単な方法はDoctrine::ATTR_EXPORTの値をDoctrine::EXPORT_ALLに設定することです。次の例は使い方を示します:

<code type="php">
$conn->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

$conn->export->exportClasses(array('NewsItem'));
</code>

次のコード例は2つのSQL命令文を実行します。MySQLを使うときこれらの命令文は次のようになります:

<code>
CREATE TABLE news_item (id INT NOT NULL AUTO_INCREMENT, title VARCHAR(200), content TEXT, version INTEGER)
CREATE TABLE news_item_version (id INT NOT NULL, title VARCHAR(200), content TEXT, version INTEGER)
</code>

+++ バージョニングを使う

<code type="php">
$newsItem = new NewsItem();
$newsItem->title = 'No news is good news';
$newsItem->content = 'All quiet on the western front';

$newsItem->save();
$newsItem->version; // 1

$newsItem->title = 'A different title';
$newsItem->save();
$newsItem->version; // 2
</code>

+++ 変更をリバートする

Doctrine_Recordは特定のバージョンにリバートするために使えるrevert()メソッドを提供します。内部ではDoctrineはversionテーブルのクエリーを行い与えられたバージョンに対してデータを取得します。与えら他バージョンが見つからない場合、Doctrine_Record_Exceptionがスローされます。

<code type="php">
$newsItem->revert(1);

$newsItem->title; // ニュースがないことがよいニュース
</code>

+++ 上級の使い方

バージョニングプラグインに対してたくさんのオプションがあります。時々'version'以外の別のカラムを使いたいことがあります。これはオプションのパラメータをactAs()メソッドに追加することで実現できます。

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        // バージョニングプラグインはversionカラムが必要
        $this->hasColumn('news_version', 'integer');
    }

    public function setUp()
    {
        $this->actAs('Versionable', array('versionColumn' => 'news_version'));
    }
}
</code>

versioningレコードの名前と'className'と'tableName'属性を持つversionテーブルの名前も制御できます。

++ フック
++ Soft-delete

Soft-deleteは次の振る舞いを実現するためのとてもシンプルなプラグインです: レコードが削除されたとき削除されたものはデータベースから削除されません。通常レコードはレコードの状態(削除されたもしくは存在する)を伝える'deleted'のよな特別なフィールドが含まれます。

次のコードスニペットはこの種の振る舞いを実現するために必要なことを示しています。2つのイベントフック: preDeleteとpostDeleteを定義する方法に注目してください。preDeleteフックがskipOperation()コールで実際の削除オペレーションをスキップする方法にも注目してください。イベントフックに関して詳細な情報は[doc event-listeners :index :name]の章をご覧ください。

<code type="php">
class SoftDeleteTest extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', null, array('primary' => true));
        $this->hasColumn('deleted', 'boolean', 1);
    }
    public function preDelete($event)
    {
        $event->skipOperation();
    }
    public function postDelete($event)
    {
        $this->deleted = true;
        $this->save();
    }
}
</code>

ではプラグインをアクションに設置します:

<code type="php">

// 新しいレコードを保存する
$record = new SoftDeleteTest();
$record->name = 'new record';
$record->save();

$record->delete();
var_dump($record->deleted); // true
</code>

++ プラグインを作成する

この節では独自のプラグインを作る方法を説明します。この章のコンセプトを理解するためにすでにDoctrine_Templateのアイディアにすでに慣れ親しんでいることが前提です。 

一対多のEメールを持つことが必要な様々な異なるRecordクラスがあるとします。この機能はEmailクラスをまとめて作成する一般的なプラグインを作成することで実現します・

buildDefinition()メソッドでEmailPluginという名前のプラグインを作ることからこのタスクを始めます。

<code type="php">
class EmailPlugin extends Doctrine_Plugin
{
    public function initOptions()
    {
        $this->setOption('className', '%CLASS%Email');
    }
    
    public function buildDefinition()
    {
        // 外部キーの定義をビルドする
        $fk = $this->buildForeignKeys($this->_options['table']);

        $relations = $this->buildRelation($fk);

        $columns['address'] = array('type'   => 'string',
                                    'length' => 255,
                                    'email'  => true,
                                    'primary' => true);
        $columns += $fk;
        
        $this->generateClassDefinition(array(), $columns, $relations);
    }
}
</code>

++ プラグインを入れ子にする

