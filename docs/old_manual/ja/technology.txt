++ アーキテクチャ
Doctrineは3つのメインのパッケージに分割されます:

* Doctrine CORE
 * Doctrine
 * Doctrine_Manager
 * Doctrine_Connection
 * Doctrine_Compiler
 * Doctrine_Exception
 * Doctrine_Formatter
 * Doctrine_Object
 * Doctrine_Null
 * Doctrine_Event
 * Doctrine_Overloadable
 * Doctrine_Configurable
 * Doctrine_EventListener

* Doctrine DBAL
 * Doctrine_Expression_Driver
 * Doctrine_Export
 * Doctrine_Import
 * Doctrine_Sequence
 * Doctrine_Transaction
 * Doctrine_DataDict

Doctrine DBALはドライバパッケージにも分割されます。

* Doctrine ORM
 * Doctrine_Record
 * Doctrine_Table
 * Doctrine_Relation
 * Doctrine_Expression
 * Doctrine_Query
 * Doctrine_RawSql
 * Doctrine_Collection
 * Doctrine_Tokenizer

Doctrineのためのプラグインもあります:

* Doctrine_Validator
* Doctrine_Hook
* Doctrine_View
* Doctrine_Tree + Doctrine_Node


++ 使われているデザインパターン
使われているGoF (Gang of Four)のデザインパターンです:

* [http://www.dofactory.com/Patterns/PatternSingleton.aspx Singleton]、一つの{{Doctrine_Manager}}のインスタンスを強制するため
* [http://www.dofactory.com/Patterns/PatternComposite.aspx Composite]、leveled configurationのために
* [http://www.dofactory.com/Patterns/PatternFactory.aspx Factory]、接続ドライバのローディングと多くの他のことに対して
* [http://www.dofactory.com/Patterns/PatternObserver.aspx Observer]、イベントリスニングのため
* [http://www.dofactory.com/Patterns/PatternFlyweight.aspx Flyweight]、バリデータの効率的な使い方のため
* [http://www.dofactory.com/Patterns/PatternFlyweight.aspx Iterator], コンポーネントを通したイテレートのため(テーブル、接続、レコードなど)
* [http://www.dofactory.com/Patterns/PatternState.aspx State], ステートワイズな接続のために
* [http://www.dofactory.com/Patterns/PatternStrategy.aspx Strategy]、アルゴリズム戦略のために

使われているエンタープライズなアプリケーションデザインパターン:

* [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?ActiveRecord 和訳])、Doctrineはこのパターンの実装です
* [http://www.martinfowler.com/eaaCatalog/unitOfWork.html UnitOfWork]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?UnitofWork 和訳])、トランザクションで影響のあるオブジェクトのリストを維持するため
* [http://www.martinfowler.com/eaaCatalog/identityField.html Identity Field]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?IdentityField 和訳])、レコードとデータベースの列の間の識別を維持するため
* [http://www.martinfowler.com/eaaCatalog/metadataMapping.html Metadata Mapping]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?MetadataMapping 和訳])、Doctrine DataDictのため
* [http://www.martinfowler.com/eaaCatalog/dependentMapping.html Dependent Mapping]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?cmd=view&p=DependentMapping&key=Dependent%2BMapping 和訳])、一般的なマッピングのため、すべてのレコードはすべてのマッピングを実行する{{Doctrine_Record}}を拡張するため
* [http://www.martinfowler.com/eaaCatalog/foreignKeyMapping.html Foreign Key Mapping]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?ForeignKeyMapping 和訳])、一対一、一対多、多対多のリレーションシップ
* [http://www.martinfowler.com/eaaCatalog/associationTableMapping.html Association Table Mapping]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?AssociationTableMapping 和訳])、アソシエーションテーブルマッピングのため(もっともよくあるのは多対多のリレーションシップ)
* [http://www.martinfowler.com/eaaCatalog/lazyLoad.html Lazy Load]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?LazyLoad 和訳])、オブジェクトとオブジェクトのプロパティの遅延ロードのため
* [http://www.martinfowler.com/eaaCatalog/queryObject.html Query Object]([http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?QueryObject 和訳])、DQLのAPIはQuery Objectパターンのアイディアの拡張です


++ スピード
: **初期化の遅延** : コレクション要素のため

: **subselectによる取得** : Doctrineはsubselectを使い効率的にコレクションを取得する方法を知っています。

: **必要なときに、後でSQL命令文を実行する** : 接続は必要になるまで決してINSERTもしくはUPDATEを発行しません。So 例外が発生してトランザクションを中止する必要がある場合、命令文の中には実際に決して実行されないものがあります。さらにこれによってできる限りロックの時間を短くします(最後のUPDATEからトランザクションの終了まで)。

: **Joinによる取得** : Doctrineはjoinとsubselectを利用して複雑オブジェクトグラフの取得方法を知っています。

: **複数のコレクション取得戦略** : Doctrineはパフォーマンス調整のために複数のコレクション取得戦略を持ちます。

: **取得戦略の動的なミックス** : 取得戦略はミックスできます。たとえばユーザーがバッチコレクションに取得できる一方でユーザーの電話番号は一つのクエリーのみを使ってオフセットコレクションにロードできます。

: **ドライバ固有の最適化** : Doctrineはmysql上のblk-insertのようなことを知っています

: **トランザクション上の単発の削除** : Doctrineは削除リストに追加オブジェクトのすべての主キーを集める方法とテーブルごとに一つのSQLのdelete命令文のみを実行する方法を知っています。

: **修正されたカラムのみ更新する** : Doctrineはどのカラムが変更されたのか常に知っています。

: **修正されていないオブジェクトをinsert/updateしない。** : Doctrineはレコードの状態が変更されたかどうか知っています。

: **データベース抽象化のためのPDO** : PDOはPHPで利用できる最速のデータベース抽象化レイヤーです。


++ 内部の最適化
