++ 序文
パフォーマンスは大きなサイズのアプリケーションに対してすべての方法の中でとても重要な面を持ちます。Doctrineはオブジェクトリレーショナルマッピングと同様にデータベース抽象化レイヤーを提供する大きな抽象化ライブラリを持ちます。一方でこれはポータビリティと開発の簡単化などの多大な恩恵を提供するのでパフォーマンスの観点から欠点につながることは必然的です。この章ではDoctrineのベストなパフォーマンスを作り出すための手助けになります。


++ コンパイル
Doctrineはとても大きなフレームワークで通常はたくさんのファイルがそれぞれのリクエストに含まれます。これは多くのオーバーヘッドをもたらします。このためこれらのファイルオペレーションは複数のクエリーをデータベースサーバーに送るのと同じぐらい時間を消費します。ファイルごとのクラスのクリーンな分離は開発環境ではうまく動作をしますが、プロジェクトが商業ディストリビューションになるとスピードはファイルごとのクラスのクリーンな分離の運営慣習より勝ります。

Doctrineはこの問題を解決するために{{compile()}}メソッドを提供します。compileメソッドはもっともよく使われるoctrineコンポーネントの単独のファイルを作成し、これはスクリプトのトップにインクルードできます。デフォルトではファイルは{{Doctrine.compiled.php}}という名前でDoctrineのrootに作成されます。

コンパイルの実行は複数のファイル(最悪の場合何十ものファイル)の代わりにもっともよく使われれるdoctrineランタイムコンポーネントの単独のファイルを作るための方法でパフォーマンスを一桁改善できることもあります。失敗する場合、{{Doctrine_Exception}}は詳細なエラーをスローします。

<code type="php">
Doctrine::compile();
// 他のスクリプト上で:
require_once('path_to_doctrine/Doctrine.compiled.php');
</code>


++ 必要なもののみを取得する
おそらくもっとも重要なルールは実際に必要なデータのみを取得することです。これはささいなことに聞こえるかもしれませんが怠惰もしくは利用できる可能性に関する知識の欠如は多くの不必要なオーバーヘッドにつながります。

次の例を見てみましょう:
<code type="php">
$record = $table->find($id);
</code>

このようなコードを書いているあなた自身を何度見たことでしょう？この方法は便利ですがあなたが必要ではないことがよくあります。上記の例はデータベースからレコードのすべてのカラムを引き出しそのデータを新しく作成されたオブジェクトに投入します。これは必要のないネットワークトラフィックを意味するだけでなくDoctrineが決して使わないオブジェクトにデータを投入しなければならないことを意味します。
<code>
SELECT * FROM ... 
</code> がアプリケーションにとって悪いことでこれはDoctrineを使用するときにも当てはまることをあなたがご存じなのは私もよく承知しております。実際Doctrineを使うとき、必要のないデータをオブジェクトに投入するのは時間の無駄なのでこの方法はいっそう悪いです。

このカテゴリに属する別の重要なルールは: **本当にオブジェクトが必要なときのみオブジェクトを取得する**ということです。最近までこの文章はまったく意味をなしませんでしたが最近のDoctrineに追加されたものの一つはオブジェクトグラフの代わりに"配列グラフ"を取得する能力です。なぜ最初にオブジェクトリレーショナルマッパーを使うのか？なので最初これは奇妙に聞こえるかもしれません。それに関して少し考えてみましょう。PHPは元々優れたOOPのためにたくさんの機能が強化された手続き型言語です。配列はPHPを使う際にもっとも効率的なデータ構造です。オブジェクトは複雑なビジネスロジックを実現するために使われるときにもっとも価値があります。その恩恵がないときにデータを割高なオブジェクト構造で包むのはリソースの無駄遣いです。記事に対して関連したデータを持つすべてのコメントを取得し、後で表示するためにそれらをビューに渡している、次の仮のコードをご覧ください:
<code type="php">
$comments = $query->select("c.id, ...")->from("Comment c")
        ->leftJoin("c.foo f")
        ->leftJoin("f.bar b")
        ->where("c.article_id = ?")
        ->execute(array(1));
$view->comments = $comments;
</code>

配列の代わりにビューでオブジェクトの恩恵を考えたことがありますか？ビューでビジネスロジックを実行しようとしていないでしょうか？一つのパラメータによって不要な処理作業を省くことができます:

<code type="php">
 ... ->execute(array(1), Doctrine::HYDRATE_ARRAY);
</code> 
これは一連の入れ子のPHP配列を返します。いくつかのコメントを取得したことを前提とすると、次のようになります:
<code>
array(5) (
    [0] => array(
        'title' => 'Title1',
        'message' => 'Hello there! I like donuts!',
        'author' => array(
            'first_name' => 'Bart',
            'last_name' => 'Simpson'   
        )
    ),
    [1] => array(
        'title' => 'Title2',
        'message' => 'Hullo!',
        'author' => array(
            'first_name' => 'Homer',
            'last_name' => 'Simpson'   
        )
    ),
    ...
)
</code>

'author'は'comment'の関連コンポーネントでサブの配列になります。データに対して常に配列構文を使う場合、配列の取得に切り替えるためには追加パラメータを追加することしか必要ありません。次のコードは取得スタイルに関係なく動作します:

<code type="php">
foreach ($comments as $comment) {
    echo $comment['title'] . '<br />';
    echo $comment['message'] . '<br />';
    echo $comment['author']['first_name'] . ' - ' . $comment['author']['last_name'] . '<br />';
}
</code> 

**表示するためにデータをビューに渡すようなリードオンリーのデータが必要なときは常に配列の取得が最良の選択肢です。そして筆者の経験によれば、大抵の場合大きな容量のデータを取得するとき表示目的のみです。そしてオブジェクトの代わりに配列を取得する場合これがまさにベストなパフォーマンスの利益を得るケースです。**


++ クラスファイルをバンドルする
Doctrineもしくは他の大きなOOライブラリもしくは大量のファイルを含む必要のあるフレームワークを使うとき、通常のHTTPリクエストが非常に膨れあがります。リクエストあたり50-100が含まれるのはまれです。これはたくさんのディスクオペレーションにつながるので重大なパフォーマンスの影響があります。これは開発環境において問題がありませんが、製品には適しません。この問題を対処するための水晶補ほうはもっとも使うライブラリのクラスを本番用に単独のファイルにバンドルして不要な空白、改行とコメントを除去することです。この方法によってバイトコードキャッシュ(次のセクションで説明)無しで大きくパフォーマンスの改善ができます。バンドルファイルを作る最良の方法はおそらく自動化ビルド処理、すなわちPhingで行うことです。


++ バイトコードキャッシュを使う
APCのようなバイトコードキャッシュは実行に先駆けてPHPによって生成されるバイトコードをキャッチします。このことが意味するのはファイルの解析とバイトコードの作成は一度だけですべてのリクエスト上では行われないことです。これは大きなライブラリかつ/もしくはフレームワークを使うときにとりわけ便利です。製品のために搭載するファイルを伴う場合これによって重要なパフォーマンスの改善をできます。バイトコードキャッシュを最大限利用するためにマニュアルページをご覧ください。これらのキャッシュの大半は必要に応じてキャッシュを最適化できる多くのコンフィギュレーションオプションを持つからです。


++ 他のティップス
**DQLパーサーを手助けする**
DQLを使うことに関して2つの可能な方法があります。最初の方法は平文のDQLクエリーを書いてDoctrine_Connection::query($dql)に渡すことです。2番目の方法はDoctrine_Query objectと流暢なインターフェイスを使うことです。とてもシンプルなクエリー以外は後者が望ましいです。理由はDoctrine_QueryオブジェクトとそのメソッドはDQLパーサーのライフを少し簡単にするからです。行う必要のあるクエリー解析の量を減らすのでそれゆえ速くなります。

**効率的なリレーションの取り扱い**
2つのコンポーネント間のリレーションを追加するとき次のようなことをすべき**ではありません**:
<code type="php">
// role - user間の多対多を前提
$user->roles[] = $newRole;
</code> 
これはデータベースからまだロードされていないユーザーのすべてのロールをロードします！新しいリンクを一つ追加するためだけに！代わりに次のことをしてください:
<code type="php">
// ロール - ユーザー間の多対多を前提とする、UserRoleXrefはクロスリファレンステーブル
$ref = new UserRoleXref();
$ref->role_id = $role_id;
$ref->user_id = $user_id;
$ref->save();
</code>