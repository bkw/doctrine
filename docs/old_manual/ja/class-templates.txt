++ 序文

モデルの範囲内で同じような内容を持つクラスを何度も見つかることがあります。これらのことはコンポーネント自身のスキーマと関係するものを含むことがあります(リレーション、カラムの定義、インデックスの定義など)。コードをリファクタリングする一つの明快な方法は複数のクラスが拡張する基本クラスを持つことです。

しかしながら継承が解決する問題はごく一部でしかありません。次の節ではDoctrine_Templateを使うことが継承よりもどれだけ遙かに強力で柔軟であることを示します。

Doctrine_Templateはクラステンプレートシステムです。
テンプレートは基本的に使う準備が出来ていてRecordクラスがロードできる小さなコンポーネントです。テンプレートがロードされているときsetTableDefinition()とsetUp()メソッドは呼び出されそれらの内部のメソッドコールは求められたクラスに従います。

++ シンプルなテンプレート

次の例においてTimestampTemplateという名前のテンプレートを定義します。基本的にテンプレートの目的はこのテンプレートをロードする日付カラムの'created'と'updated'をレコードクラスに追加することです。加えてこのテンプレートはレコードアクションに基づいてこれらのフィールドを更新するTimestampリスナーという名前のリスナーを使用します。

<code type="php">
class TimestampListener extends Doctrine_Record_Listener
{
    public function preInsert(Doctrine_Event $event)
    {
        $event->getInvoker()->created = date('Y-m-d', time());
        $event->getInvoker()->updated = date('Y-m-d', time());
    }
    public function preUpdate(Doctrine_Event $event)
    {
        $event->getInvoker()->created = date('Y-m-d', time());
        $event->getInvoker()->updated = date('Y-m-d', time());
    }
}
class TimestampTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('created', 'date');
        $this->hasColumn('updated', 'date');

        $this->setListener(new TimestampListener());
    }
}
</code>

タイムスタンプの機能を必要とするBlogと呼ばれるクラスを考えてみましょう。必要なことはactAs()コールをクラス定義に追加することです。

<code type="php">
class Blog extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }
    public function setUp()
    {
        $this->actAs('TimestampTemplate');
    }
}
</code>


++ リレーションを持つテンプレート

前の章の状況よりも遙かに複雑になりことはよくあります。他のモデルクラスへのリレーションを持ったモデルクラスを持ち、与えられたクラスをいくつかの拡張されたクラスで置き換えたい場合があります。

次の2つのクラスを考えてみましょう。UserとEmailは次の定義を持ちます:

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');
    }
    public function setUp()
    {
        $this->hasMany('Email', array('local' => 'id', 'foreign' => 'user_id'));
    }
}
class Email extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('address', 'string');
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id', 'foreign' => 'id'));
    }
}
</code>

UserとEmailクラスを拡張し、例えば、ExtendedUserとExtendedEmailをクラスを作成する場合、ExtendedUserはまだEmailクラスとの関係を持ち、ExtendedEmail クラスとは関係を持ちません。もちろん UserクラスのsetUp()メソッドをオーバーライドしてExtendedEmailクラスへのリレーションを定義できますが、継承の全体の本質的な部分を失います。Doctrine_Templateはdependency injection(DI 依存性の注入)の方法でエレガントにこの問題を解決できます。

次の例において2つのテンプレートを定義します。UserTemplateとEmailTemplateで、UserとEmailクラスの定義とほぼ同じ定義を持ちます。

<code type="php">
class UserTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');
    }
    public function setUp()
    {
        $this->hasMany('EmailTemplate as Email', array('local' => 'id', 'foreign' => 'user_id'));
    }
}
class EmailTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('address', 'string');
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('UserTemplate as User', array('local' => 'user_id', 'foreign' => 'id'));
    }
}
</code>

どのようにリレーションを定義したのかに注目して下さい。Recordクラスを具体化することを目指すのではなく、リレーションをテンプレートに設定しています。This tells Doctrineがこれらのテンプレートに対して具体的なRecordクラスを見つけるようにすべきであることを伝えます。Doctrineがこれらの具体的な実装を見つけることができない場合リレーションパーサーは例外をスローしますが、先に進む前に、ここで実際のレコードクラスを見てみましょう:

<code type="php">
class User extends Doctrine_Record
{
    public function setUp()
    {
        $this->actAs('UserTemplate');
    }
}
class Email extends Doctrine_Record
{
    public function setUp()
    {
        $this->actAs('EmailTemplate');
    }
}
</code>

次のコードスニペットを考えてみましょう。まだテンプレートに対して具体的な実装を設定していないのでこれは動作しません。

<code type="php">
$user = new User();
$user->Email; // 例外をスローする
</code>

次のバージョンは動作します。Doctrine_Managerをグローバルに使用してテンプレートに対して具体的な実装を設定する方法に注目して下さい。

<code type="php">
$manager = Doctrine_Manager::getInstance();
$manager->setImpl('UserTemplate', 'User')
        ->setImpl('EmailTemplate', 'Email');

$user = new User();
$user->Email;
</code>

テンプレートに対する実装はマネージャー、接続とテーブルレベルでさえ設定できます。

++ 委譲メソッド

フルテーブル定義デリゲートシステムとしてのアクションに加えて、Doctrine_Templateはメソッドコールのデリゲーションを可能にします。ロードされたテンプレートの範囲内ですべてのメソッドはテンプレートをロードしたレコードで利用できます。内部ではこの機能を実現するために実装は__call()マジックメソッドを使用します。

例を考えてみましょう: テンプレートを通して認証機能をロードするUserクラスがあるとします。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('fullname', 'string', 30);
    }
    public function setUp()
    {
        $this->actAs('AuthTemplate');
    }
}
class AuthTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 16);
        $this->hasColumn('password', 'string', 16);
    }
    public function login($username, $password)
    {
        // ここで何らかのログイン機能
    }
}
</code>

上記で示されるようにUserクラスの範囲内でAuthTemplateで見つかるメソッドを簡単に使うことができます。

<code type="php">
$user = new User();

$user->login($username, $password);
</code>

Doctrine_TemplateのgetInvoker()メソッドを使用することでデリゲートメソッドを呼び出すレコードを取得できます。AuthTemplateの例を考えてみましょう。Userオブジェクトにアクセスしたい場合次のことを行う必要があります:

<code type="php">
class AuthTemplate extends Doctrine_Template
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 16);
        $this->hasColumn('password', 'string', 16);
    }
    public function login($username, $password)
    {
        // Invokerオブジェクトで何を行う
        $object = $this->getInvoker();
    }
}
</code>

++ 複数のテンプレートと連携する

それぞれのクラスは複数のテンプレートから構成されます。テンプレートが同じような定義を持つ場合もっとも最近ロードされたテンプレートが常に前のものをオーバーライドします。

++ コアテンプレート

Doctrineはモデルに対してすぐ使える機能を提供するいくつかのテンプレートと一緒に配布されています。モデルでこれらのテンプレートを簡単に有効にできます。You can do it directly in your Doctrine_Recordsで直接行うかYAMLスキーマファイルでモデルを管理している場合、YAMLスキーマで指定できます。

+++ Versionable
PHPの例
<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $this->actAs('Versionable', array('versionColumn' => 'version', 'className' => '%CLASS%Version'));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    Versionable:
      versionColumn: version
      className: %CLASS%Version
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Timestampable

2番目の引数の配列が要求されます。それは下記で示されるすべての値のデフォルト値を設定します。

PHPの例
<code type="php">                                              
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $this->actAs('Timestampable', array('created' =>  array('name'    =>  'created_at',
                                                                'type'    =>  'timestamp',
                                                                'format'  =>  'Y-m-d H:i:s',
                                                                'disabled' => false,
                                                                'options' =>  array()),
                                            'updated' =>  array('name'    =>  'updated_at',
                                                                'type'    =>  'timestamp',
                                                                'format'  =>  'Y-m-d H:i:s',
                                                                'disabled' => false,
                                                                'options' =>  array())));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    Timestampable:
      created:
        name: created_at
        type: timestamp
        format:Y-m-d H:i:s
        options: []
      updated:
        name: updated_at
        type: timestamp
        format: Y-m-d H:i:s
        options: []
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

updated_atではなくcreated_atフィールドのタイムスタンプのような、カラムの一つを使うことのみに関心があるのなら、下記の例のようにフィールドのどちらかに対してflag disabled=>true を設定して下さい。

YAMLの例
<code type="yaml">
---
User:
  actAs:
    Timestampable:
      created:
        name: created_at
        type: timestamp
        format:Y-m-d H:i:s
        options: []
      updated:
        disabled: true
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Sluggable
slug(ナメクジ・のろのろしたもの)を作成するためにカラムを指定しない場合、モデル上でtoString()メソッドを使用してデフォルト値を設定するだけです。

PHPの例
<code type="php">                                              
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }
    
    public function setUp()
    {
        $this->actAs('Sluggable', array('columns' => array('username')));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    Sluggable:
      columns: [username]
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ I18n
PHPの例
<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('I18n', array('fields' => array('title')));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    I18n:
      fields: [title]
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ NestedSet
PHPの例
<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('NestedSet', array('hasManyRoots' => true, 'rootColumnName' => 'root_id'));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    NestedSet:
      hasManyRoots: true
      rootColumnName: root_id
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>

+++ Searchable
PHPの例
<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('username', 'string', 125);
        $this->hasColumn('password', 'string', 255);
    }

    public function setUp()
    {
        $this->actAs('Searchable', array('fields' => array('title', 'content')));
    }
}
</code>

YAMLの例
<code type="yaml">
---
User:
  actAs:
    Searchable:
      fields: [title, content]
  columns:
    username:
      type: string(125)
    password:
      type: string(255)
</code>
