++ 序文
多くのユーザーはいつかSQLデータベースで階層データを取り扱い階層データの管理はリレーショナルデータベースが意図するものではないと疑いなく学びます。リレーショナルデータベースのテーブルは(XMLのように)階層的ではありませんが、シンプルにフラットなリストです。階層データはリレーショナルデータベーステーブルでは自然に表現されない親子関係を持ちます。

私達の目的のために、階層データは(項目のrootが親を持たないことを除いて)それぞれの項目が一つの親とゼロもしくは複数の子供を持つデータのコレクションです。階層データは例えばフォーラムやメーリングリストのスレッド、ビジネスの組織表、コンテントマネジメントカテゴリや製品カテゴリなどを含む様々な種類のデータベースアプリケーションで見つかります。

階層データモデルにおいて、データは木のような構造に組織化されます。ツリー構造によって親/子の関係を使用して情報を繰り返すことができます。ツリーデータ構造の説明に関しては [http://en.wikipedia.org/wiki/Tree_data_structure ここ]をご覧下さい。

リレーショナルデータベースでツリー構造への主要な取り組み方は3つあります。次の通りです:

* 隣接リストモデル(Adjacency List Model)
* 入れ子集合モデル(Nested Set Model)(もしくは修正先行順木の走査アルゴリズム(Modified Pre-order Tree Traversal Algorithm)として知られる) 
* 経路実体化モデル（Path Emuneration Model)

これらは次の章もしくは以下のURLで説明されています

* [http://www.dbazine.com/oracle/or-articles/tropashko4 http://www.dbazine.com/oracle/or-articles/tropashko4]
* [http://dev.mysql.com/tech-resources/articles/hierarchical-data.html http://dev.mysql.com/tech-resources/articles/hierarchical-data.html] (日本語訳:[http://lists.mysql.com/mysql-ja/242 階層化されたデータをMySQLで扱う])


++ 隣接リスト
まだ実装されていません 


++ 入れ子集合
+++ 導入

入れ子集合はとても速い読み込みアクセスを提供する階層データを貯蔵するための解決方法です。しかしながら、入れ子集合ツリーを更新するとより大きな負荷がかかります。それゆえこの解決方法は書き込みよりも読み込みが頻繁な階層に対して最適です。ウェブの性質のため、これは大抵のWebアプリケーションに当てはまります。

入れ子集合の詳細な情報に関しては下記の記事をご覧下さい:

* [http://www.sitepoint.com/article/hierarchical-data-database/2 http://www.sitepoint.com/article/hierarchical-data-database/2]
* [http://dev.mysql.com/tech-resources/articles/hierarchical-data.html http://dev.mysql.com/tech-resources/articles/hierarchical-data.html]  (日本語訳:[http://lists.mysql.com/mysql-ja/242 階層化されたデータをMySQLで扱う])


+++ セットアップする

モデルを入れ子集合としてセットアップするために、次のコードをモデルのテーブル定義に追加しなければなりません。

<code type="php">
...
    public function setTableDefinition() {
        ...

        $this->actAs('NestedSet');       

       ...
    }
...
</code>

"actAs"はDoctrine(Doctrine_Template_*クラス)に搭載されたテンプレートをロードする便利なメソッドです。もっと一般的な代替方法は次のようになります:

<code type="php">
...
    public function setTableDefinition() {
        ...

        $this->actAs('Doctrine_Template_NestedSet');       

       ...
    }
...
</code>

Doctrineのテンプレーティングモデルに関する詳細な情報は[doc class-templates :index :name]の章で見つかります。これらのテンプレートはいくつかの機能性をモデルに追加します。入れ子集合の例において、モデルは3つの追加フィールドを取得します: "lft"、"rgt"、"level"です。"lft"と"rgt"を気にする必要はまったくありません。これらはツリー構造を管理するために内部で使用されるからです。しかしながら、"level"フィールドはあなたに影響があります。なぜならツリーの範囲内のノードの深さを表す整数の値だからです。0のレベルはrootのノードを意味します。1はrootノードなどの子供を意味します。ノードから"level"フィールドを読むことで適切なインデンデーションを持ったツリーを簡単に表示できます。 

**lft、rgtレベルに割り当ててはなりません。これらは入れ子集合の実装によって透過的に管理されるからです。**

+++ 単独のテーブルで1以上のツリー

入れ子集合実装を設定することでテーブルが複数のrootのノードを持つことができるので、それゆえ同じテーブルの範囲内で複数のツリーを持つことができます。

下記の例は上記のセットアップに基づいて複数のrootをセットアップして使用する方法の例を示します:

<code type="php">
...
    public function setTableDefinition() {
        ...
        $options = array('hasManyRoots' => true,  // 多くのrootを有効にする
                 'rootColumnName' => 'root_id');  // rootのカラムをセットする。デフォルトは'root_id'
        $this->actAs('NestedSet', $options);       

       ...
    }
...
</code>

ツリー間を区別するために使用されるrootColumnNameはカラムです。これは入れ子集合の実装によって行われます。しかしながら、新しいrootノードを作成したい場合"root_id"を手動で設定するオプションがあります。入れ子集合の実装はそれを再組織化します。同じ方法で"root_id"を気にすることなく異なるツリー間でノードを移動させることができます。このすべてがあなたのために取り扱われます。

+++ ツリーと連携する

入れ子集合としてモデルをセットアップすることを成功した後でそれで動作させることができます。Working with Doctrineの入れ子集合実装で動作させることは2つのクラスがすべてです: Doctrine_Tree_NestedSetとDoctrine_Node_NestedSetです。これらはDoctrine_Tree_InterfaceとDoctrine_Node_Interfaceインターフェイスの入れ子集合実装です。ツリーオブジェクトはテーブルオブジェクトになりノードオブジェクトはレコードオブジェクトになりますこれは次のようになります:
<code type="php">
  // $connはいくつかのDoctrine_Connectionのインスタンスであることを前提とする
  $treeObject = $conn->getTable('MyNestedSetModel')->getTree();
  // ... フルツリーインターフェイスは$treeObject上で利用可能

  // $entityはMyNestedSetModelの一つのインスタンスであることを前提とする
  $nodeObject = $entity->getNode();
  // ...フルノードインターフェイスは$nodeObject上で利用可能
</code>  

次の節でノードとツリークラスを所有しもっとよく使われるオペレーションをデモンストレートするコードスニペットを見ます。

++++ rootノードを作成する

<code type="php">
...
$root = new MyNestedSetModel();
$root->name = 'root';
$treeObject = $conn->getTable('MyNestedSetModel')->getTree();
$treeObject->createRoot($root); // $root->save()を内部で呼び出す
...
</code>

++++ ノードをインサートする

<code type="php">
...
// $someOtherRecordはMyNestedSetModelのインスタンスであることを前提とする
$record = new MyNestedSetModel();
$record->name = 'somenode';
$record->getNode()->insertAsLastChildOf($someOtherRecord); // $record->save()を内部で呼び出す
...
</code>

++++ ノードを削除する

<code type="php">
...
// $recordはMyNestedSetModelのインスタンスであることを前提とする
$record->getNode()->delete(); // $record->delete()を内部で呼び出す。レコード上ではなくノード上で削除することが重要である。さもなければツリーを破損させてしまうことがある。
...
</code>

ノードを削除するとそのノードのすべての子孫も削除されます。ですので子孫を削除したくない場合、ノードを削除する前に必ず子孫をどこか別の場所に移動させて下さい。

++++ ノードを移動する

<code type="php">
...
// $recordと$someOtherRecordの両方がMyNestedSetModelのインスタンスであることを前提とする
$record->getNode()->moveAsLastChildOf($someOtherRecord);
...
</code>

4つの移動メソッドが存在します: moveAsLastChildOf($other)、 moveAsFirstChildOf($other)、moveAsPrevSiblingOf($other)と moveAsNextSiblingOf($other)です。メソッド名は文字通りの意味です。

++++ ノードを調査うる

<code type="php">
...
// $recordはMyNestedSetModelのインスタンスであることを前提
$isLeaf = $record->getNode()->isLeaf(); // true/false
$isRoot = $record->getNode()->isRoot(); // true/false
...
</code>

++++ シブリング(兄弟)を調査して取得する

<code type="php">
...
// $recordはMyNestedSetModelのインスタンスであることを前提とする
$hasNextSib = $record->getNode()->hasNextSibling(); // true/false
$haPrevSib = $record->getNode()->hasPrevSibling(); // true/false

$nextSib = $record->getNode()->getNextSibling(); // 次のシブリングが存在しない場合はfalseを、さもなければ兄弟を返す
$prevSib = $record->getNode()->getPrevSibling(); // 以前のシブリングがそんざいしなければfalseを、そうでなければ兄弟を返す

$siblings = $record->getNode()->getSiblings(); // すべてのシブリングの配列
...
</code>

++++ 子供 / 親 / 子孫 / 祖先を調査して取得する

<code type="php">
...
// $recordがMyNestedSetModelのインスタンスであることを前提とする
$hasChildren = $record->getNode()->hasChildren(); // true/false
$hasParent = $record->getNode()->hasParent(); // true/false

$firstChild = $record->getNode()->getFirstChild(); // 最初の子供が存在しない場合はfalseを、そうでなければ子供を帰す
$lastChild = $record->getNode()->getLastChild(); // 最後の子供が存在しない場合はfalseを、そうでなければ子供を返す
$parent = $record->getNode()->getParent(); // 親が存在しない場合はfalseを、そうでなければ親を帰す

$children = $record->getNode()->getChildren(); // 子供達が存在しない場合はfalseを、そうでなければ子供達を返す
// !!! 重要: getChildren()は直接の子孫のみを返します。すべての子孫が欲しい場合はgetDescendants()を使って下さい !!!

$descendants = $record->getNode()->getDescendants(); //子孫が存在しない場合はfalseを、そうでなければ子孫を返す
$ancestors = $record->getNode()->getAncestors(); // 祖先がそんざいしなければfalseを、そうでなければ祖先を返す

$numChildren = $record->getNode()->getNumberChildren(); // 子供達の数を返す
$numDescendants = $record->getNode()->getNumberDescendants(); // 子孫の数を返す

...
</code>

getDescendants()とgetAncestors()の両方はブランチの結果の"depth"を指定するために使うことができるパラメータを受け取ります。例えばgetDescendants(1) は直接の子孫のみを取得します(下記では子孫はレベル1で、getChildren()と同じです)。同じ方法でgetAncestors(1)は直接の祖先(親)などのみを取得します。getAncestors()はこのノードからrootまでもしくは指定したある祖先までのパスを決定するために便利です(すなわちパンくずナビゲーションを構築するため)。

++++ シンプルな例: ツリーを表示する

<code type="php">
...
$treeObject = $conn->getTable('MyNestedSetModel')->getTree();
$tree = $treeObject->fetchTree();
foreach ($tree as $node) {
    echo str_repeat('&nbsp;&nbsp;', $node['level']) . $node['name'] . '<br />';
}
...
</code>

+++ 高度な使い方

以前のセクションでDoctirneの入れ子集合の実装の基本的な使い方を説明しました。このセクションではさらに一歩進めます。

++++ リレーションを持つツリーを取得する

もしソフトウェア開発者に要求しているのであれば質問は既にあなたの頭の中に入っているかもしれません: "関連したデータを持つツリー/ブランチを取得する方法は？"。シンプルな例: カテゴリのツリーを表示したいが、それぞれのカテゴリの関連したデータも表示したい場合、このカテゴリでもっともホットな製品の詳細を考えてみましょう。前のセクションで見たようなツリーを取得してｔりーをイテレートしている間にリレーションにアクセスすることは可能ですがたくさんの不要なデータベースクエリを生み出します。幸運にも、Doctrine_Queryと入れ子集合実装のある程度の柔軟性が助けになります。入れ子集合実装はデータベースのすべての動作に関してDoctrine_Queryオブジェクトを使用します。入れ子集合実装の基本クエリオブジェクトにアクセスすることで入れ子集合を使用している間にDoctrine_Queryの全パワーを開放できます。次のコードスニペットをご覧下さい:

<code type="php">
$query = new Doctrine_Query();
$query->select("cat.name, hp.name, m.name")->from("Category cat")
        ->leftJoin("cat.hottestProduct hp")
        ->leftJoin("hp.manufacturer m");
$treeObject = $conn->getTable('Category')->getTree();
$treeObject->setBaseQuery($query);
$tree = $treeObject->fetchTree();
$treeObject->resetBaseQuery();
</code>

必要な関連データをすべて持つツリーが存在し、すべては一つのクエリーに統合されます。

さらに推し進めることができます。"Improving Performance"の章で言及したようにそれが必要なときのみにオブジェクトを取得すべきです。ですので表示目的(リードオンリー)のみのためにツリーが必要な場合、次のようにできます:

<code type="php">
$query = new Doctrine_Query();
$query->select("base.name, hp.name, m.name")->from("Category base")
        ->leftJoin("base.hottestProduct hp")
        ->leftJoin("hp.manufacturer m")
        ->setHydrationMode(Doctrine::HYDRATE_ARRAY);
$treeObject = $conn->getTable('Category')->getTree();
$treeObject->setBaseQuery($query);
$tree = $treeObject->fetchTree();
$treeObject->resetBaseQuery();
</code>

これで$treeに素晴らしく構造化されたデータを得てレコードでともかく配列アクセスを使う場合、この変更はコードの他の部分に影響を与えません。クエリを修正するこのメソッドはすべてのノードツリーメソッド(getAncestors()、getDescendants()、 getChildren()、getParent()、...)に対して使用できます。クエリを作成し、ツリーオブジェクト上の基本クエリとして設定し適切なメソッドを実行します。


++ 経路実体化
まだ実装されていません


++ 例
