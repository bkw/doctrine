++ リレーションを取り扱う
+++ 関連レコードを作成する

Doctrineで関連したレコードにアクセスすることは簡単です: レコードプロパティに関してまさにゲッターとセッターを使うことができます。

上記の3つの方法を使うことができますが、配列の可搬性のために最後のものが推奨されます。

<code type="php">
$user->Email;

$user->get('Email');

$user['Email'];
</code>

一対一関係の存在しないレコードにアクセスするとき、Doctrineは自動的にオブジェクトを作成します。例えば次のコードが可能です:

<code type="php">
$user = new User();
$user->name = 'some user';

$user->Email->address = 'some@one.info';
// ユーザーと関連したEメールを保存します
$user->save();
</code>

一対多関係のレコードをアクセスするとき、Doctrineは関連したコンポーネントに対してDoctrine_Collectionを作成します。ユーザーと電話番号を持ちそれぞれの関係が一対多とします。上記で示されたように電話番号を簡単に追加できます:

<code type="php">
$user = new User();
$user->name = 'some user';

$user->Phonenumber[]->phonenumber = '123 123';
$user->Phonenumber[]->phonenumber = '456 123';
$user->Phonenumber[]->phonenumber = '123 777';

// ユーザーと関連した電話番号を保存します
$user->save();
</code>

+++ 関連レコードを取得する

以前の節とまったく同じ{{Doctrine_Record}}メソッドで関連したレコードを取得できます。まだ読み込みされていない関連したコンポーネントにアクセスするときはDoctrineは取得に対して一つのSQL SELECT命令文を使用するのでご注意下さい。そういうわけで次の例では4つのSQLのSELECTを実行します。

<code type="php">
$user = $conn->getTable('User')->find(5);

print $user->Email['address'];

print $user->Phonenumber[0]->phonenumber;

print $user->Group[0]->name;
</code>

これをより効率的に行うにはDQLを使用します。次の例ではユーザーは関連コンポーネントの取得に対して一つのSQLクエリのみを使用しています。

<code type="php">
$user = Doctrine_Query::create()
        ->from('User u')
        ->leftJoin('u.Email e')
        ->leftJoin('u.Phonenumber p')
        ->leftJoin('u.Group g')
        ->execute();

print $user->Email['address'];

print $user->Phonenumber[0]->phonenumber;

print $user->Group[0]->name;
</code>


+++ 関連レコードを更新する

それぞれの関連した個別のオブジェクトと/照合順序に対するsaveを呼び出す、もしくは他のオブジェクトを所有するオブジェクト上でsaveを呼び出すことで関連したレコードを保存することができます。すべての追加オブジェクトを保存する{{Doctrine_Connection::flush}}も呼び出すこともできます。

<code type="php">
$user->Email['address'] = 'koskenkorva@drinkmore.info';

$user->Phonenumber[0]->phonenumber = '123123';

$user->save();

// Eメールと電話番号を保存します
</code>


+++ 関連レコードを削除する

レコードもしくは照合上で{{delete()}}メソッドを呼び出すことで関連したレコードを個別に削除できます。

<code type="php">
$user->Email->delete();

$user->Phonenumber[3]->delete();

// ユーザーとすべての関連したオブジェクトを削除する:

$user->delete();
</code>

典型的なウェブアプリケーションにおいて通常は削除される関連したオブジェクトの主キーはフォームから由来します。この場合関連レコードを削除するもっとも効率的な方法はDQLのDELETE命令文を使用することです。再びお互いの関係が一対多のユーザーと電話番号を考えます。与えられたユーザーidに対して与えられた電話番号の削除は次のように達成されます:

<code type="php">
$deleted = Doctrine_Query::create()
           ->delete()
           ->from('Phonenumber')
           ->addWhere('user_id = ?', array($userId))
           ->whereIn('id', $phonenumberIds);
           ->execute();
// 削除された電話番号の数を出力します
print $deleted;
</code>

ときに電話番号のレコードを削除したくないが、外部キーフィールドをnullに設定することでアンリンクしたいことがあります。これはもちろんDQLによって達成できますが、おそらくもっともエレガントな方法はDoctrine_Record::unlink()を使用することです。unlinkメソッドはとても賢いことに注目して下さい。関連した電話番号をnullに設定するだけでなくUserオブジェクトから参照するすべての与えられた電話番号も削除します。

UserがPhonenumberを3つ持つ場合を考えてみましょう(識別子は1、2と3)。1と3のPhonenumberをunlinkすることは以下のように簡単に実現されます:

<code type="php">
$user->unlink('Phonenumber', array(1, 3));

$user->Phonenumber->count(); // 1
</code> 


++ 多対多リレーション
+++ 新しいリンクを作成する
UserとGroupの2つのクラスを持つことを考えましょう。これらのクラスはGroupUser連想クラスを通してリンクされます
一時(新規)レコードに取り組むときUserとGroupの組み合わせを追加するためのもっとも速い方法は以下の通りです:
<code type="php">
$user = new User();
$user->name = 'Some User';
$user->Group[0]->name = 'Some Group';
$user->Group[1]->name = 'Some Other Group';
$user->save();
</code>

しかしながら実際の世界のシナリオにおいて既存のグループを持っていて、それらに与えられたユーザーを追加したいことはよくあります。これをもっとも効率的に行う方法は次の通りです:
<code type="php">
$gu = new GroupUser();
$gu->user_id = $userId;
$gu->group_id = $groupId;
$gu->save();
</code>

+++ リンクを削除する

多対多の関連レコード間のリンクを削除する正しい方法はDQLのDELETE命令文を使うことです。DQLのDELETEを使う際に便利で推奨される方法はQueryのAPIを通して行うことです。

<code type="php">
$deleted = Doctrine_Query::create()
           ->delete()
           ->from('GroupUser')
           ->addWhere('user_id = 5')
           ->whereIn('group_id', $groupIds);
           ->execute();
// 削除されたリンクを出力する
print $deleted;
</code>

関連オブジェクト間の関係を{{unlink}}する別の方法は{{Doctrine_Record::unlink}}メソッドです。このメソッドは最初にデータベースにクエリを行うので既に親モデルがない限りこのメソッドは回避すべきです。

<code type="php">
$user = $conn->getTable('User')->find(5);
$user->unlink('Group', array(0, 1));
$user->save();

// Groupへのすべての関係をunlinkすることもできる
$user->unlink('Group');
</code>

UserとGroup間のリンクを削除するもっとも明確で便利な方法は以下の通りですが使うべき*ではありません*:

<code type="php">
$user = $conn->getTable('User')->find(5);
$user->GroupUser
     ->remove(0)
     ->remove(1);
$user->save();
</code>

$user->GroupUserは与えられたグルー王に対してすべてのリンクをロードするからです。ユーザーが多くのグループに所属する場合これは時間を浪費するタスクになり得ます。ユーザーが少数のグループに所属しているとしてもまだ不必要なSELECT命令文を実行します。

++ オブジェクトを取得する

通常データベースからデータを取得するとき次のフレーズが実行されます:

1. クエリをデータベースに送る
2. データベースから返されたデータを取得する

オブジェクト取得の観点から私達はこれらのフレーズを'fetching'フレーズと呼びます。Doctrineはhydorationフレーズという別のフレーズも持っています。The hydrationフレーズは構造化された配列/オブジェクトを取得するときにいつでも行われます。明示的に指定されない限りDoctrineのすべてはハイドレイトされます。

ユーザーと電話番号が一対多の関係にある場合を考えてみます。次の平易なSQLクエリでを考えて下さい:

<code type="php">
$dbh->fetchAll('SELECT u.id, u.name, p.phonenumber FROM user u LEFT JOIN phonenumber p ON u.id = p.user_id');
</code>

これらの一対多のjoinに慣れているのであれば基本結果セットがコンストラクトされる方法をよく知っているかもしれません。ユーザーが複数の電話番号を持つ場合結果セットに重複したデータが存在します、結果セットは次のようなものになります:

<code>
 index  | u.id | u.name         | p.phonenumber |
 0      |   1  | Jack Daniels   | 123 123       |
 1      |   1  | Jack Daniels   | 456 456       |
 2      |   2  | John Beer      | 111 111       |
 3      |   3  | John Smith     | 222 222       |
 4      |   3  | John Smith     | 333 333       |
 5      |   3  | John Smith     | 444 444       |
</code>

ここではJack Danielsは2つの電話番号を持ちます。John Beerは一つの電話番号を持つのに対してJohn Smithは3つ持っています。この結果セットがいかに融通が効かないのか知っているかも知れません。あちこちで確認する重複データが必要なのでこれを超えてイテレートすることは困難です。

Doctrineのhydrationはすべての重複したデータを除去します。これは以下のような多くのことも行います:

# 結果セットの要素のインデックス化をカスタマイズする
# 値のカスケーディングと準備
# 値の割り当てリスティング
# 二次元の結果セット配列から多次元配列を作成する。次元はネストされたjoinの数と等しい

私達が使用したSQLクエリと同等のDQLを考えてみましょう:
<code type="php">
$array = $conn->query('SELECT u.id, u.name, p.phonenumber FROM User u LEFT JOIN u.Phonenumber p', 
                      array(), Doctrine::HYDRATE_ARRAY);
</code>

このハイドレイトされた配列の構造は以下のようになります:

<code>
array(0 => array('id' => 1,
                 'name' => 'Jack Daniels',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '123 123'),
                          1 => array('phonenumber' => '456 456'))),
      1 => array('id' => 2,
                 'name' => 'John Beer',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '111 111'))),
      2 => array('id' => 3,
                 'name' => 'John Smith',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '111 111')),
                          2 => array('phonenumber' => '222 222'),
                          3 => array('phonenumber' => '333 333'))));
</code>

この構造はDoctrineのデフォルトのhydrationモードであるオブジェクト(レコード)のハイドレーションにも当てはまります。唯一の違いは個々の要素はDoctrine_Recordオブジェクトとして表現されDoctrine_Collectionオブジェクトに変換されることです。配列もしくはオブジェクトを取り扱うは次のようにします:

# //foreach//を使用して結果セットをイテレートする
# 配列アクセス大括弧(ブラケット)を使用して個別の要素にアクセスする
# //count()//関数を使用して要素の数を取得する
# //isset()//を使用して与えられた要素が存在するか確認する
# //unset()//を使用して与えられた要素をunsetする

アクセスのみの目的に対してデータが必要な場合は配列ハイドレーションを常に使うべきです。一方で取得したデータを変更する必要がある場合はレコードハイドレーションを使用すべきです。

ハイドレーションアルゴリズムのコンスタンスなO(n)のパフォーマンスはソリューションをキャッシュする一つの洗練された(smart)識別子によって保証されます。

+++ フィールド遅延ローディング

データベースから読み込まれるオブジェクトのフィールドのすべてを持たないオブジェクトを取得するときはこのオブジェクトの状態はproxyと呼ばれます。Proxy objectsオブジェクトは読み込まれていないフィールドを遅延して(lazily)ロードすることができます。

次の定義を持つUserクラスを考えてみましょう:

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('description', 'string');
    }
}
</code>

次の例において直接読み込まれたフィールド名とパスワードを持つすべてのUserを取得します。一つのユーザーに対してdescriptionという名前の巨大なフィールドを遅延ロード(lazy-load)します。

<code type="php">
$users = Doctrine_Query::create()->select('u.name, u.password')->from('User u')->execute();

// 次のdescriptionを遅延ロードして一つの追加データベースクエリを実行する
$users[0]->description;
</code>

Doctrineはロードされたカウントを元にproxyの評価を行います。これはどのフィールドがフィールドごとのベース上にロードされるのかを評価しません。この理由は単純です: パフォーマンスのためです。フィールドの遅延ローディングはPHPの世界ではとてもまれなので、どのフィールドがロードされるのかを確認する何らかの変数の導入は基本的な取得に対して不必要なオーバーヘッドをもたらします。

++ 配列とオブジェクト

Doctrine_RecordsとDoctrine_Collectionsは配列に取り組む作業を円滑にする以下の3つのメソッドを提供します: {{toArray()}}、{{fromArray()}}と{{synchronizeFromArray()}}です。

+++ toArray

{{toArray()}}メソッドはレコードもしくは照合の配列表現を返します。これはオブジェクトが持つリレーションにもアクセスします。デバッグをする目的のためにレコードを表示する必要がある場合はオブジェクトの配列表現を取得してそれを表示できます。

<code type="php">
print_r ($user->toArray()); // リレーションを取得したくない場合はtoArray(false)
</code>

+++ fromArray

値の配列を持ちレコードもしくは照合を入力したい場合、{{fromArray()}}メソッドはこの共通タスクを簡略化します。

<code type="php">
// 配列が次のような場合
$data = array(
  'name' => 'John',
  'age' => '25',
  'Emails' => array('john@mail.com', 'john@work.com')
);

// Eメールのリレーションを持つユーザーレコードを投入できる
$user = new User();
$user->fromArray($data);
$user->Emails->count(); // --> 2
</code>

+++ synchronizeFromArray

{{synchronizeFromArray()}}によって、配列でレコードを同期できます。モデルの配列表現を持ちフォールドを修正する場合、リレーションフィールドを修正するか関係を削除もしくは作成します。この変更はレコードに適用されます。

<code type="php">
$user = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Groups')
    ->where('id = ?')
    ->fetchOne(array(1));

// このオブジェクトをあなたが許可したクールなJavaScriptのフォームで表示する:

$arrayUser['name'] = 'New name'; // フィールドを修正する
$arrayUser['Group'][0]['name'] = 'Renamed Group'; // リレーション上のフィールドを修正する
$arrayUser['Group'][] = array('name' => 'New Group'); // 新しいリレーションを作成する
unset($arrayUser['Group'][1]); // リレーションも削除する

// フォームを投稿して次のスクリプトでレコードを取得する同じクエリを使用する

$user = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Groups')
    ->where('id = ?')
    ->fetchOne(array(1));

// フォーム入力をサニタイズしてデータを取得する

$user->synchronizeFromArray($arrayUser);
$user->save(); // すべての変更はユーザーオブジェクトに適用される
</code>

++ コンストラクタをオーバーライドする

ときにオブジェクトの作成時に同じオペレーションを実行したいことがあります。DoctrineはDoctrine_Record::__construct()メソッドをオーバーライドすることは許可しませんが代替的なメソッドを提供します:

<code type="php">
class User extends Doctrine_Record
{
    public function construct()
    {
        $this->name = 'Test Name';
        $this->do_something();
    }
}
</code>

唯一の欠点はパラメータをコンストラクタに渡さないことです。
