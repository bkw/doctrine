++ 序文
Doctrine Query Language (DQL)は複雑なオブジェクト取得においてユーザーを手助けするために作成されたObject Query Languageです。関連データを効率的に取得する(例えばユーザーとユーザーの電話番号を取得する)ときに常にDQL(もしくは生のSQL)を使うことを考えるべきです。

生のSQLを使うのと比べて、DQLはいくつかの恩恵があります: 
    
* 最初から結果セットではなくレコード(オブジェクト)を取得するように設計されてきた
* DQLはリレーションを理解するのでSQLのJOINBとJOINの条件を手動に入力する必要がありません
* DQLは異なるデータベース上でポータルです
* DQLはオブジェクトを効率的に取得するために開発者を支援する(レコード制限アルゴリズムのような)とても複雑な組み込みアルゴリズムを持ちます
* 条件付きの取得で一対多、多対多のリレーショナルデータを取り扱うときに時間を保存する関数をサポートします。

DQLのパワーが十分ではないのなら、オブジェクト投入に対してrawSql APIを使うことを考えるべきです。

次の構文に慣れ親しんでいるかもしれません:
<code type="php">
// 次　の　コ　ー　ド　を　使　わ　な　い　で　下　さ　い
// (オブジェクト投入に対して多くのSQLクエリーを使う)

$users = $conn->getTable('User')->findAll();

foreach($users as $user) {
    print $user->name . ' has phonenumbers: ';

    foreach($user->Phonenumber as $phonenumber) {
        print $phonenumber . ' ';
    }
}
</code>

しかしながらこのコードを使うべきではありません。下記のコードはずっと効率的実装された振る舞いです:

<code type="php">
// ずっと効率的に実装された同じもの:
// (オブジェクト投入に対して一つのSQLクエリーのみを使用する)

$users = $conn->query('FROM User u LEFT JOIN u.Phonenumber p');

foreach($users as $user) {
    print $user->name . ' has phonenumbers: ';

    foreach($user->Phonenumber as $phonenumber) {
        print $phonenumber . ' ';
    }
}
</code>



++ SELECTクエリー
{{SELECT}}命令文の構文です:

<code type="sql">
SELECT
    [ALL | DISTINCT]
    <select_expr>, ...
    [FROM <components>
    [WHERE <where_condition>]
    [GROUP BY <groupby_expr>
      [ASC | DESC], ... ]
    [HAVING <where_condition>]
    [ORDER BY <orderby_expr>
      [ASC | DESC], ...]
    [LIMIT <row_count> OFFSET <offset>}]
</code>

{{SELECT}}命令文は一つもしくは複数のコンポーネントからデータの取得のために使われます。

* それぞれの{{select_expr}}は取得したいカラムもしくは集約関数の値を示します。すべての{{SELECT}}命令文において少なくとも一つの{{select_expr}}が存在しなければなりません。

<code type="sql">
SELECT a.name, a.amount FROM Account a
</code>

* アスタリスクは与えられたコンポーネントからすべてのカラムを選択するために使用できます。アスタリスクを使っているときでも実行されたSQLクエリは決してそれを使用しません(Doctrineはアスタリスクを適切なカラム名に変換するので、いくつかのデータベースではパフォーマンス向上につながります)。

<code type="sql">
SELECT a.* FROM Account a
</code>

* {{FROM}}句から{{components}}はレコードを取得する一つもしくは複数のコンポーネントを指示します。

<code type="sql">
SELECT a.* FROM Account a

SELECT u.*, p.*, g.* FROM User u LEFT JOIN u.Phonenumber p LEFT JOIN u.Group g
</code>

* {{WHERE}}句は、与えられた場合、選択されたレコードが一つもしくは複数の条件を満たさなければならないことを指示します。 {{where_condition}}はそれぞれの列を選択するかどうかを評価する式です。{{WHERE}}句が存在しない場合命令文はすべての列を選択します。

<code type="sql">
SELECT a.* FROM Account a WHERE a.amount > 2000
</code>

* {{WHERE}}句において、集約(要約)関数を除いてDQLがサポートするすべての関数と演算子を使用できます
* {{HAVING}}句は集約関数で結果を制限ために使われます

<code type="sql">
SELECT u.* FROM User u LEFT JOIN u.Phonenumber p HAVING COUNT(p.id) > 3
</code>

* {{ORDER BY}}句は結果をソートするために使われます

<code type="sql">
SELECT u.* FROM User u ORDER BY u.name
</code>

* {{LIMIT}}と{{OFFSET}}句はレコードの数を与えられた{{row_count}}に効率的に制限するために使われます

<code type="sql">
SELECT u.* FROM User u LIMIT 20
</code>


+++ DISTINCTキーワード


+++ 集約値

集約値の{{SELECT}}の構文です:

<code type="php">
// SELECT u.*, COUNT(p.id) num_posts FROM User u, u.Posts p WHERE u.id = 1 GROUP BY u.id

$query = new Doctrine_Query();

$query->select('u.*, COUNT(p.id) num_posts')
      ->from('User u, u.Posts p')
      ->where('u.id = ?', 1)
      ->groupby('u.id');

$users = $query->execute();

echo $users->Posts[0]->num_posts . ' posts found';
</code>



++ UPDATEクエリー
{{UPDATE}}命令文の構文です:

<code type="sql">
UPDATE //component_name//
    SET //col_name1//=//expr1// [, //col_name2//=//expr2// ...]
    [WHERE //where_condition//]
    [ORDER BY ...]
    [LIMIT //record_count//]
</code>

* The {{UPDATE}}命令文は既存のレコードのカラムを{{component_name}}の新しい値で更新して影響されたレコードの数を返します。
* {{SET}}句はどのカラムを修正するのかとそれらが与えられる値を示します。
* オプションの{{WHERE}}句は更新するレコードを特定する条件を指定します。{{WHERE}}無しでは、すべてのレコードが更新されます。
* オプションの{{ORDER BY}}句は更新されるコードの順番を指定します。
* {{LIMIT}}句は更新されるレコードの数に制限を置きます。{{UPDATE}}のスコープを制限するために{{LIMIT row_count}}を使うことができます。{{LIMIT}}は列変更の制限ではなく**列にマッチした**制限です。命令文は{{WHERE}}句を満たす{{record_count}}が見つかるとそれらが実際に変更されたかどうかは関係なく、すぐに停止します。

<code type="php">
$q    = 'UPDATE Account SET amount = amount + 200 WHERE id > 200';

$rows = $this->conn->query($q);

// クエリーインターフェイスを使用する同じクエリー

$q = new Doctrine_Query();

$rows = $q->update('Account')
          ->set('amount', 'amount + 200')
          ->where('id > 200')
          ->execute();
          
print $rows; // 影響された列の数
</code>


++ DELETEクエリー
<code type="sql">
DELETE FROM <component_name>
    [WHERE <where_condition>]
    [ORDER BY ...]
    [LIMIT <record_count>]
</code>

* {{DELETE}}命令文は {{component_name}}からレコードを削除して削除されたレコードの数を返します。
* オプションの{{WHERE}}句はどのレコードを削除するのか特定する条件を指定します。{{WHERE}}句無しでは、すべてのレコードは削除されます。
* {{ORDER BY}}句が指定される場合、レコードは指定された順番で削除されます。
* {{LIMIT}}句は削除できる列の数に制限を置きます。命令文は{{record_count}}のレコードが削除されると同時に停止します。

<code type="php">
$q    = 'DELETE FROM Account WHERE id > ?';

$rows = $this->conn->query($q, array(3));

// クエリーインターフェイスを使用して同じクエリーを実行する

$q = new Doctrine_Query();

$rows = $q->delete('Account')
          ->from('Account a')
          ->where('a.id > ?', 3)
          ->execute();

print $rows; // 影響を受けた列の数
</code>


++ FROM句
構文:

<code type="sql">
FROM <component_reference> [[LEFT | INNER] JOIN <component_reference>] ...
</code>

{{FROM}}句はレコードを取得する一つもしくは複数のコンポーネントもしくを指定します。複数のコンポーネントを名付ける場合、joinを実行します。それぞれの指定されたテーブルに対して、オプションとしてエイリアスを指定できます。

次のDQLクエリーを考えてみましょうう:
<code type="sql">
FROM User u
</code>

'User'はクラス(コンポーネント)の名前で'u'はエイリアスです。短いエイリアスを使うべきです。なぜならクエリーにかかる時間がずっと短くなり、例えばキャッシュを使うときにキャッシュされたクエリーの形式がよりスペースが少なくなるからです。 

下記の例では'User'クラスからすべてのレコードを取得する方法を示しています。

<code type="php">
$users = Doctrine_Query::create()
         ->from('User u')
         ->execute();
</code>


++ JOIN構文
DQLのJOINの構文です:

<code>
[[LEFT | INNER] JOIN <component_reference1>] [ON | WITH] <join_condition1> [INDEXBY] <map_condition1>,
[[LEFT | INNER] JOIN <component_reference2>] [ON | WITH] <join_condition2> [INDEXBY] <map_condition2>,
...
[[LEFT | INNER] JOIN <component_referenceN>] [ON | WITH] <join_conditionN> [INDEXBY] <map_conditionN>
</code>

DQLはINNER JOINとLEFT JOINの2種類のJOINをサポートします。

* デフォルトのjoinの型は{{LEFT JOIN}}です。このjoinは{{LEFT JOIN}}句もしくはシンプルな'{{,}}'の使用によって示されます。なので次のクエリーは同等です:

<code type="sql">
SELECT u.*, p.* FROM User u LEFT JOIN u.Phonenumber

SELECT u.*, p.* FROM User u, u.Phonenumber p
</code>

推奨の形式は最初の方です。

* {{INNER JOIN}}は2つの指定されたコンポーネント間の共通部分を生み出します(すなわち、最初のコンポーネントでそれぞれのすべてのレコードが2番目のコンポーネントのそれぞれとすべてのレコードにjoinされます)。ですので基本的に{{INNER JOIN}}は例えば一つもしくは複数の電話番号を持つすべてのユーザーを効率的に取得するときに利用できます。

<code type="sql">
SELECT u.*, p.* FROM User u INNER JOIN u.Phonenumber p
</code>

デフォルトでDQLは主キーのjoin条件を自動追加します。DQLクエリーの例です:

<code type="sql">
SELECT u.id, p.id FROM User u LEFT JOIN u.Phonenumber
</code>

次はSQLによる同等のものです:

<code type="sql">
SELECT u.id AS u__id, p.id AS p__id FROM User u LEFT JOIN Phonenumber p ON u.id = p.user_id
</code>

+++ ONキーワード
この振る舞いをオーバーライドして独自のカスタムのJOIN条件を追加したい場合{{ON}}キーワードでできます。次のDQLクエリーを考えてみましょう:

<code type="sql">
SELECT u.id, p.id FROM User u LEFT JOIN u.Phonenumber ON u.id = 2
</code>

このクエリーはSQLに変換されます:

<code type="sql">
SELECT u.id AS u__id, p.id AS p__id FROM User u LEFT JOIN Phonenumber p ON u.id = 2
</code>

+++ WITHキーワード
たいていの場合主キーをJOINする条件は必要はありませんが、むしろカスタムの条件を追加したいことがあります。これは{{WITH}}キーワードで達成できます。

DQL:
<code type="sql">
SELECT u.id, p.id FROM User u LEFT JOIN u.Phonenumber WITH u.id = 2
</code>

SQL:
<code type="sql">
SELECT u.id AS u__id, p.id AS p__id FROM User u LEFT JOIN Phonenumber p ON u.id = p.user_id AND u.id = 2
</code>


Doctrine_QueryのAPIはJOINの追加に関して2つの便利なメソッドを提供します。これらはinnerJoin()とleftJoin()で、下記で示されるようにとても直感的です:

<code type="php">
$q = new Doctrine_Query();
$q->from('User u')
  ->leftJoin('u.Group g')
  ->innerJoin('u.Phonenumber p WITH u.id > 3')
  ->leftJoin('u.Email e');

$users = $q->execute();
</code> 


++ INDEXBYキーワード
INDEXBYキーワードはあるカラムを参照/配列キーとしてマッピングする方法を提供します。デフォルトではDoctrineは数値でインデックス化された配列/コレクションへの複数の要素をインデックス化します。マッピングはゼロから始まります。この振る舞いをオーバーライドするために下記のようにINDEXBYキーワードを使う必要があります:

<code type="php">
$q = new Doctrine_Query();
$q->from('User u INDEXBY u.name');

$users = $q->execute();
</code>

これで$usersコレクションのユーザーは彼らの名前を通してアクセスできます。

<code type="php">
print $user['jack daniels']->id;
</code>

INDEXBYキーワードは 与えられたどのJOINにも適用できます。与えられたどのコンポーネントはそれぞれ独自のインデックス化の振る舞いを持っていることを意味します。次のコードにおいてUserとGroupの両方に対して、異なるインデックス化ができます。


<code type="php">
$q = new Doctrine_Query();
$q->from('User u INDEXBY u.name')->innerJoin('u.Group g INDEXBY g.name');

$users = $q->execute();
</code>

ではdrinkers club'の作成日を出力してみましょう。 

<code type="php">
print $users['jack daniels']->Group['drinkers club']->createdAt;
</code>


++ WHERE句
構文:

<code type="sql">
WHERE <where_condition>
</code>

* {{WHERE}}句は、与えられた場合、選択されたレコードが満たさなければならない一つもしくは複数の条件を示します。
* {{where_condition}}は選択されたそれぞれの列に対してtrueであるか評価する式です。
* {{WHERE}}句が存在しない場合、命令文はすべての列を選択します。
* 集約関数の値で結果を狭めるとき{{WHERE}}句の代わりに{{HAVING}}句を使うべきです。



++ 条件式
+++ リテラル

**文字列**

文字列リテラルはシングルクォートで閉じられています: 'literal'。シングルクォートを含む文字列リテラルは2つのシングルクォートで表されます; 例えば: 'literal''s'。

<code type="sql">
FROM User WHERE User.name = 'Vincent'
</code>

**整数**

整数リテラルはPHPの整数リテラルの構文をサポートします。

<code type="sql">
FROM User WHERE User.id = 4
</code>

**浮動小数点**

浮動小数点リテラルはPHPの浮動小数点構文の使用をサポートします。

<code type="sql">
FROM Account WHERE Account.amount = 432.123
</code>

**論理値**

論理型のリテラルはtrueもしくはfalseです。

<code type="sql">
FROM User WHERE User.admin = true

FROM Session WHERE Session.is_authed = false
</code>

**Enums**

enum(列挙)型の値は文字リテラルと同じ方法で動作します。

<code type="sql">
FROM User WHERE User.type = 'admin'
</code>

大文字で書きことがよい規範ですが、あらかじめ定義され保存されたリテラルは大文字と小文字を区別します。


+++ 入力パラメータ

<code type="php">

// POSITIONAL パラメータ:
$users = $conn->query("FROM User WHERE User.name = ?", array('Arnold'));

$users = $conn->query("FROM User WHERE User.id > ? AND User.name LIKE ?", array(50, 'A%'));


// 名前付きのパラメータ:

$users = $conn->query("FROM User WHERE User.name = :name", array(':name' => 'Arnold'));

$users = $conn->query("FROM User WHERE User.id > :id AND User.name LIKE :name", array(':id' => 50, ':name' => 'A%'));
</code>


+++ 演算子と演算子の優先順位

下記のリストで演算子は優先順位の低い順に並べられています。

||~ 演算子 ||~ 説明        ||
|| .         || ナビゲーション演算子 ||
||           || //算術演算子: // ||
|| +, -      || 単項の               ||
|| *, /      || 乗法と除法 || 
|| +, -      || 加減    || 
|| =, >, >=, <, <=, <> (not equal), || 比較演算子 ||
|| [NOT] LIKE, [NOT] IN, IS [NOT] NULL, IS [NOT] EMPTY || ||
||           || //論理演算子: // ||
|| NOT       || || 
|| AND       || || 
|| OR        || ||


+++ Between式


+++ In式

構文:

<code>
<operand> IN (<subquery>|<value list>)
</code>

//オペランド//が//サブクエリー//の結果から見つかるもしくは or if its in それが指定された//CSVのリスト//にある場合、IN条件式はtrueを返すので、IN式はサブクエリーの結果が空の場合は常にfalseです。

//値リスト//が使用されているときそのリストに少なくとも一つの要素が存在しなければなりません。

<code type="sql">
FROM C1 WHERE C1.col1 IN (FROM C2(col1));

FROM User WHERE User.id IN (1,3,4,5)
</code>

INキーワードは= ANY に対してエイリアスです。それゆえ、これらの2つの命令文は等しいです:

<code type="sql">
FROM C1 WHERE C1.col1 = ANY (FROM C2(col1));
FROM C1 WHERE C1.col1 IN    (FROM C2(col1));
</code>


+++ Like式

構文:

<code>
string_expression [NOT] LIKE pattern_value [ESCAPE escape_character]
</code>

string_expressionは文字の値をもたなければなりません。pattern_valueは文字リテラルもしくは文字の値の入力パラメータでアンダースコア(_)は単独の文字を表し、パーセント(%)は文字のシーケンスを表し(空のシーケンスも含む),、それ以外のすべての文字は自身を表します。オプションのescape_characterは単独文字のリテラルもしくは文字の値の入力パラメータ(すなわち、charもしくはCharacter)でpattern_valueで特別な意味を持つアンダースコアとパーセントをエスケープするために使用されます。

例:

* address.phone LIKE '12%3'は'123' '12993'に対してtrueで'1234'に対してはfalseです
* asentence.word LIKE 'l_se'は'lose'に対してtrueで'loose'に対してfalseです
* aword.underscored LIKE '\_%' ESCAPE '\'は'_foo'に対してtrueで'bar'に対してfalseです
* address.phone NOT LIKE '12%3'は'123'と'12993'に対してfalseで'1234'に対してtrueです

string_expressionもしくはpattern_valueの値がNULLもしくはunkownの場合、LIKE式の値はunkownです。escape_characterisが指定されNULLの場合、LIKE式の値はunkownです。

<code type="php">

// '@gmail.com'で終わるEメールを持つすべてのユーザーを見つける
$users = $conn->query("FROM User u, u.Email e WHERE e.address LIKE '%@gmail.com'");

// 'A'の文字で始まる名前を持つすべてのユーザーを見つける
$users = $conn->query("FROM User u WHERE u.name LIKE 'A%'");
</code>


+++ Null比較式
+++ 空のコレクション比較式
+++ コレクションメンバー式


+++ Exists式

構文:

<code>
<operand> [NOT ]EXISTS (<subquery>)
</code>
サブクエリーが一つもしくは複数の列さもなければFALSEを返す場合、EXISTS演算子はTRUEを返します。

サブクエリーが0の列とさもなければFALSEを返す場合NOT EXISTS演算子はTRUEを返します。

読者を持つすべての記事を見つけます:

<code type="sql">
FROM Article a
  WHERE EXISTS (SELECT r.id FROM ReaderLog r
                WHERE r.article_id = a.id)
</code>

読者を持たないすべての記事を見つけます:

<code type="sql">
FROM Article a
  WHERE NOT EXISTS (SELECT r.id FROM ReaderLog r
                WHERE r.article_id = a.id)
</code>     


+++ AllとAny式

構文:

<code>
operand comparison_operator ANY (subquery)
operand comparison_operator SOME (subquery)
operand comparison_operator ALL (subquery)
</code>

サブクエリーの結果のすべての値もしくは空のサブクエリーの結果に対して比較演算子がtrueの場合、ALLの条件式はtrueを返します。少なくとも一つの列に対して比較の結果がfalseの場合はALLの条件式はfalseでtrueでもfalse出もない場合はunkownです。

<code type="sql">
FROM C WHERE C.col1 < ALL (FROM C2(col1))
</code>

サブクエリーの何らかの結果に対して比較演算子がtrueの場合、ANY条件式はtrueを返します。サブクエリーの結果が空であるもしくはANY条件式はfalseを返します。 サブクエリーの結果が空の場合、もしくは比較演算子がサブクエリーの結果のすべての値に対してfalseであるなら、条件式はfalseです。どちらもtrueもしくはfalseではないのであればunknownになります。

<code type="sql">
FROM C WHERE C.col1 > ANY (FROM C2(col1))
</code>

SOMEキーワードはANYに対してエイリアスです。
 
<code type="sql">
FROM C WHERE C.col1 > SOME (FROM C2(col1))
</code>

ALLもしくはANY条件式で使用できる比較演算子は =、<、<=、>、>=、<>です。 サブクエリーの結果は条件式と同じ型でなければなりません。

NOT INは<> ALLのエイリアスです。ですので次の2つの命令文は等しいです:

<code type="sql">
FROM C WHERE C.col1 <> ALL (FROM C2(col1));
FROM C WHERE C.col1 NOT IN (FROM C2(col1));
</code>


+++ サブクエリー

サブクエリーはキーワードもしくは通常のSELECTクエリーが含むことのできる句を含むことができます。

サブクエリーの利点は以下の通りです:

* それらによって命令文のそれぞれの部分を隔離できるようにクエリーの構造化を行うことができます。
* 複雑なJOINとUNIONが要求されるオペレーションの実行に対して代替的な方法を提供します。
* 多くの人の意見によれば、それらは読みやすいです。実際、初期のSQLを"Structured Query Language"と呼ぶオリジナルのアイディアを人々に提供したサブクエリーのイノベイションでした

<code type="php">
// グループ1に属しないすべてのユーザーを見つける
$query = "FROM User WHERE User.id NOT IN 
                        (SELECT u.id FROM User u 
                         INNER JOIN u.Group g WHERE g.id = ?)";
                         
$users = $conn->query($query, array(1));

// どのグループにも属さないすべてのユーザーを見つける
// 注意: 
// INNER JOINの使い方
// Groupコンポーネントに先行する空の角括弧の使い方

$query = "FROM User WHERE User.id NOT IN 
                        (SELECT u.id FROM User u 
                         INNER JOIN u.Group g)";

$users = $conn->query($query);
</code>



++ 関数式
+++ 文字列関数

* //CONCAT//関数は引数の連結である文字列を返します。上記の例においてユーザーのファーストネームとラストネームの連結をnameと呼ばれる値にマップします

<code type="php">
$q = new Doctrine_Query();

$users = $q->select('CONCAT(u.firstname, u.lastname) name')->from('User u')->execute();

foreach($users as $user) {
    // ここでは'name'は$userのプロパティではありません、
    // これはマップされた関数の値です
    print $user->name;
}
</code>

* //SUBSTRING//関数の2番目と3番目の引数は返される始めの位置と部分文字列の長さを示します。これらの引数は整数です。文字列の最初の位置は1で表されます。//SUBSTRING//関数は文字列を返します。

<code type="php">
$q = new Doctrine_Query();

$users = $q->select('u.name')->from('User u')->where("SUBSTRING(u.name, 0, 1) = 'z'")->execute();

foreach($users as $user) {
    print $user->name;
}
</code>

* //TRIM//関数は文字列から指定された文字をトリムします(整えます)。トリムされる文字が指定されない場合、スペース(もしくは空白)と見なされます。オプションのtrim_characterは単独の文字リテラルもしくは文字の値の入力パラメータです(すなわち、charもしくはCharacter)[30]。トリムの説明が提供されない場合、BOTHが前提となります。//TRIM//関すはトリムされた文字列を返します。

<code type="php">
$q = new Doctrine_Query();

$users = $q->select('u.name')->from('User u')->where("TRIM(u.name) = 'Someone'")->execute();

foreach($users as $user) {
    print $user->name;
}
</code>    

* //LOWER//と//UPPER//関数は文字列をそれぞれ小文字と大文字に変換します。respectively. They return a string. 

<code type="php">
$q = new Doctrine_Query();

$users = $q->select('u.name')->from('User u')->where("LOWER(u.name) = 'someone'")->execute();

foreach($users as $user) {
    print $user->name;
}
</code>  

* //LOCATE//関数は、指定された位置で検索を始まる、文字列の範囲で与えられた文字の位置を返します。これは文字列が整数として見つかった最初の位置を返します。最初の引数は設置された文字列です; オプションの3番目の引数は検索が始まる文字列の位置です(デフォルトでは、検索される文字列の始めです)。文字列の最初の位置は1で表示されます。文字列が見つからない場合、0が返されます。
* //LENGTH//関数は文字の文字列の長さを整数として返します。


+++ 数学関数

利用できるDQLの数学関数は以下の通りです:

<code>
ABS(simple_arithmetic_expression)
SQRT(simple_arithmetic_expression)
MOD(simple_arithmetic_expression, simple_arithmetic_expression)
</code>

* //ABS//関数は与えられた数字に対して絶対値を返します。

* //SQRT//関数は与えられた数に対して平方根を返します。

* //MOD//関数は2番目の引数を使用して最初の引数の法(モジュロ)を返します。

+++ 日付関数

++ サブクエリー
+++ 導入
+++ サブクエリーを使った比較
+++ 条件式
++++ ANY、INとSOME
++++ ALL
++++ EXISTSとNOT EXISTS
+++ 関連クエリー
+++ FROM句でサブクエリー


++ GROUP BY、HAVING句
DQL GROUP BYの構文です:

<code>
GROUP BY groupby_item {, groupby_item}*
</code>

DQL HAVINGの構文です:

<code>
HAVING conditional_expression
</code> 

* GROUP BYとHAVINGの句は集約関数を取り扱うために使うことができます
* 次の終夜区間数がDQL上で利用できます: COUNT、MAX、MIN、AVG、SUM

名前で最初のユーザーをアルファベット順に選択します。

<code type="sql">
SELECT MIN(u.name) FROM User u
</code>

Account名のすべての合計を選択します。

<code type="sql">
SELECT SUM(a.amount) FROM Account a
</code>

* GROUP BY句を含まない命令文で集約関数を使うと、すべての列上でグルーピングを行うことになります。上記の例においてすべてのユーザーとユーザーが持つ電話番号を取得します。

<code type="sql">
SELECT u.*, COUNT(p.id) FROM User u, u.Phonenumber p GROUP BY u.id
</code>

* HAVING句は集約値を使用して結果を絞るために使うことができます。次の例において少なくとも2の電話番号を持つすべてのユーザーを取得します

<code type="sql">
SELECT u.* FROM User u, u.Phonenumber p HAVING COUNT(p.id) >= 2
</code>

<code type="php">
// それぞれのユーザーに対してすべてのユーザーと電話番号を取得する

$users = $conn->query("SELECT u.*, COUNT(p.id) count FROM User u, u.Phonenumber p GROUP BY u.id");

foreach($users as $user) {
    print $user->name . ' has ' . $user->Phonenumber[0]->count . ' phonenumbers';
}
</code>


++ ORDER BY句
+++ 導入

レコードコレクションはORDER BY句を利用してしてデータベースレベルで効率的にソートできます。

構文です:

<code>
        [ORDER BY {ComponentAlias.columnName}
        [ASC | DESC], ...]
</code>

例です:

<code type="sql">
FROM User u LEFT JOIN u.Phonenumber p
  ORDER BY u.name, p.phonenumber

FROM User u, u.Email e
  ORDER BY e.address, u.id
</code>

逆順でソートするために、DESC (descending)キーワードをソートしているORDER BY句のカラムの名前に追加できます。デフォルトは昇順です; これはASCキーワードを使用することで明示的に指定できます。

<code type="sql">
FROM User u LEFT JOIN u.Email e
  ORDER BY e.address DESC, u.id ASC;
</code>


+++ 集約値でソートする

次の例においてユーザーとユーザーが持つ電話番号の数によってソートされたそのユーザーを取得できます。

<code type="php">
$q = new Doctrine_Query();

$users = $q->select('u.*, COUNT(p.id) count')
           ->from('User u')
           ->innerJoin('u.Phonenumber p')
           ->orderby('count');
</code>

+++ ランダムな順番を使う

次の例においてランダムな投稿を取得するためにORDER BY句でrandが使えます。

<code type="php">
$q = new Doctrine_Query();

$posts = $q->select('p.*, RANDOM() rand')
           ->from('Post p')
           ->orderby('rand')
           ->limit(1)
           ->execute();

$randomPost = $posts[0];
</code>


++ LIMITとOFFSET句
おそらくDQLパーサーが提供しなければならないもっとも複雑な機能はLIMIT句パーサーです。DQLのLIMIT句がLIMITデータベースのポータビリティを考慮するだけでなく、複雑なクエリー分析とサブクエリーによる列の代わりに、レコードの数を制限できます。

<code type="php">
// 最初の20ユーザーとそれらすべての関連した電場番号を取得する

$users = $conn->query("SELECT u.*, p.* FROM User u, u.Phonenumber p LIMIT 20");

foreach($users as $user) {
    print ' --- '.$user->name.' --- \n';

    foreach($user->Phonenumber as $p) {
        print $p->phonenumber.'\n';
    }
}
</code>

+++ ドライバポータビリティ

DQLのLIMIT句はすべてのサポートされたデータベース上で移動できます。次の要素に対して特別な注意が払われてきました:

* Mysql、PgsqlとSqliteのみがLIMIT / OFFSET句をネイティブに実装しています
* Oracle / Mssql / Firebirdにおいて LIMIT / OFFSET句はドライバの特別な方法でエミュレートされる必要があります
* limit-subquery-algorithmはMySQLで個別に実行する必要があります。 MySQLはサブクエリーでまだLIMITをサポートしていないからです
* PgsqlはSELECT句に保存されるフィールドによる順番を必要とします。hence limit-subquery-algorithmはpagsqlドライバがしようされるときにこれを考慮する必要があるからです
* Oracleは30未満のオブジェクト識別子(= table/column names/aliases)のみを許可します。limitサブクエリーは可能な限り短くしてメインクエリーでエイリアスの衝突を避けなければなりません。

+++ limit-subquery-algorithm

limit-subquery-algorithmは一対多/多対多リレーションデータが同時に取得されているときにDQLパーサーが内部で使用するアルゴリズムです。この種の特別なアルゴリズムはSQLの結果セットの列の代わりにレコードの数を制限するためにLIMIT句に対して必要です。

この振る舞いは構成システムを使用してオーバーライドできます(global、connectionもしくはtableレベル):
<code type="php">
$table->setAttribute(Doctrine::ATTR_QUERY_LIMIT, Doctrine::LIMIT_ROWS);
$table->setAttribute(Doctrine::ATTR_QUERY_LIMIT, Doctrine::LIMIT_RECORDS); // revert
</code>

次の例において一対多のリレーションを持つユーザーと電話番号があるとします。最初の20人のユーザーと関連した電話番号を取得することを考えてみましょう。

クエリーの最後にシンプルなドライバ固有のLIMIT 20を追加すれば正しい結果が返されると考える人がいるかもしれません。しかしこれは間違いです。1-20のユーザー間の何かを取得し最初のユーザーは20の電話番号を持ちレコードセットは20列から構成されます。

DQLはサブクエリーと複雑だが効率的なサブクエリーの解析に関するこの問題を克服します。次の例において単独の効率的なクエリーで最初の20人のユーザーとそれらのすべての電話番号を取得しようとしています。DQLがサブクエリーでもカラム集約継承を使うほど十分に賢く、またエイリアスの衝突を避けるためにサブクエリーでテーブルに対して異なるエイリアスを使うほど賢いことに注目して下さい。

DQL QUERY:

<code type="sql">
SELECT u.id, u.name, p.* FROM User u LEFT JOIN u.Phonenumber p LIMIT 20
</code>

SQL QUERY:
 
<code type="sql">
SELECT
    e.id AS e__id,
    e.name AS e__name,
    p.id AS p__id,
    p.phonenumber AS p__phonenumber,
    p.entity_id AS p__entity_id
FROM entity e
LEFT JOIN phonenumber p ON e.id = p.entity_id
WHERE e.id IN (
SELECT DISTINCT e2.id
FROM entity e2
WHERE (e2.type = 0) LIMIT 20) AND (e.type = 0)
</code>

次の例において最初の20人のユーザーと彼らのすべての電話番号と実際に電話番号を持つ人のみを一つの効率的なクエリーで取得しようとしています。それゆえINNER JOINを使います。サブクエリーでINNER JOINを使うほどDQLパーサーが賢いことに注目して下さい。

DQL QUERY:

<code type="sql">
SELECT u.id, u.name, p.* FROM User u LEFT JOIN u.Phonenumber p LIMIT 20
</code>

SQL QUERY:
 
<code type="sql">
SELECT 
    e.id AS e__id,
    e.name AS e__name,
    p.id AS p__id,
    p.phonenumber AS p__phonenumber,
    p.entity_id AS p__entity_id
FROM entity e
LEFT JOIN phonenumber p ON e.id = p.entity_id
WHERE e.id IN (
SELECT DISTINCT e2.id
FROM entity e2
INNER JOIN phonenumber p2 ON e2.id = p2.entity_id
WHERE (e2.type = 0) LIMIT 20) AND (e.type = 0)
</code>


++ 例
++ クエリーレジストリ

Doctrine_Query_Registryはクエリーを登録して名付けるためのクラスです。これはアプリケーションクエリーの組織化を手助けすることに加えとても素晴らしいものを提供します。

クエリーはregistryオブジェクトのadd()メソッドを使用して追加されます。2つのパラメータであるクエリー名と実際のDQLのクエリーを取ります。

<code type="php">
$r = Doctrine_Manager::getInstance()->getQueryRegistry();

$r->add('all-users', 'FROM User u');
</code>

+++ 名前空間

TQuery registryは名前空間をサポートします。名前空間は/ -markで実際の名前から分離されます。名前空間の名前がレコード名である場合、与えられたレコードはローカルスコープで利用できるすべての名前付きのクエリーを持ちます。

<code type="php">
$r = Doctrine_Manager::getInstance()->getQueryRegistry();

$r->add('User/all', 'FROM User u');
$r->add('User/byName', 'FROM User u WHERE u.name = ?');

$user = new User();

// Jack Danielsという名前のユーザーを見つける
$user = $user->findOne('byName', array('Jack Daniels'));

// すべてのユーザーを見つける
$users = $user->find('all');
</code>

++ BNF
<code>
QL_statement ::= select_statement | update_statement | delete_statement
select_statement ::= select_clause from_clause [where_clause] [groupby_clause]
[having_clause] [orderby_clause]
update_statement ::= update_clause [where_clause]
delete_statement ::= delete_clause [where_clause]
from_clause ::=
FROM identification_variable_declaration
{, {identification_variable_declaration | collection_member_declaration}}*
identification_variable_declaration ::= range_variable_declaration { join | fetch_join }*
range_variable_declaration ::= abstract_schema_name [AS ] identification_variable
join ::= join_spec join_association_path_expression [AS ] identification_variable
fetch_join ::= join_specFETCH join_association_path_expression
association_path_expression ::=
collection_valued_path_expression | single_valued_association_path_expression
join_spec::= [LEFT [OUTER ] |INNER ]JOIN
join_association_path_expression ::= join_collection_valued_path_expression |
join_single_valued_association_path_expression
join_collection_valued_path_expression::=
identification_variable.collection_valued_association_field
join_single_valued_association_path_expression::=
identification_variable.single_valued_association_field
collection_member_declaration ::=
IN ( collection_valued_path_expression) [AS ] identification_variable
single_valued_path_expression ::=
state_field_path_expression | single_valued_association_path_expression
state_field_path_expression ::=
{identification_variable | single_valued_association_path_expression}.state_field
single_valued_association_path_expression ::=
identification_variable.{single_valued_association_field.}* single_valued_association_field
collection_valued_path_expression ::=
identification_variable.{single_valued_association_field.}*collection_valued_association_field
state_field ::= {embedded_class_state_field.}*simple_state_field
update_clause ::=UPDATE abstract_schema_name [[AS ] identification_variable]
SET update_item {, update_item}*
update_item ::= [identification_variable.]{state_field | single_valued_association_field} =
new_value
new_value ::=
simple_arithmetic_expression |
string_primary |
datetime_primary |

boolean_primary |
enum_primary
simple_entity_expression |
NULL
delete_clause ::=DELETE FROM abstract_schema_name [[AS ] identification_variable]
select_clause ::=SELECT [DISTINCT ] select_expression {, select_expression}*
select_expression ::=
single_valued_path_expression |
aggregate_expression |
identification_variable |
OBJECT( identification_variable) |
constructor_expression
constructor_expression ::=
NEW constructor_name( constructor_item {, constructor_item}*)
constructor_item ::= single_valued_path_expression | aggregate_expression
aggregate_expression ::=
{AVG |MAX |MIN |SUM }( [DISTINCT ] state_field_path_expression) |
COUNT ( [DISTINCT ] identification_variable | state_field_path_expression |
single_valued_association_path_expression)
where_clause ::=WHERE conditional_expression
groupby_clause ::=GROUP BY groupby_item {, groupby_item}*
groupby_item ::= single_valued_path_expression | identification_variable
having_clause ::=HAVING conditional_expression
orderby_clause ::=ORDER BY orderby_item {, orderby_item}*
orderby_item ::= state_field_path_expression [ASC |DESC ]
subquery ::= simple_select_clause subquery_from_clause [where_clause]
[groupby_clause] [having_clause]
subquery_from_clause ::=
FROM subselect_identification_variable_declaration
{, subselect_identification_variable_declaration}*
subselect_identification_variable_declaration ::=
identification_variable_declaration |
association_path_expression [AS ] identification_variable |
collection_member_declaration
simple_select_clause ::=SELECT [DISTINCT ] simple_select_expression
simple_select_expression::=
single_valued_path_expression |
aggregate_expression |
identification_variable
conditional_expression ::= conditional_term | conditional_expressionOR conditional_term
conditional_term ::= conditional_factor | conditional_termAND conditional_factor
conditional_factor ::= [NOT ] conditional_primary
conditional_primary ::= simple_cond_expression |( conditional_expression)
simple_cond_expression ::=
comparison_expression |
between_expression |
like_expression |
in_expression |
null_comparison_expression |
empty_collection_comparison_expression |

collection_member_expression |
exists_expression
between_expression ::=
arithmetic_expression [NOT ]BETWEEN
arithmetic_expressionAND arithmetic_expression |
string_expression [NOT ]BETWEEN string_expressionAND string_expression |
datetime_expression [NOT ]BETWEEN
datetime_expressionAND datetime_expression
in_expression ::=
state_field_path_expression [NOT ]IN ( in_item {, in_item}* | subquery)
in_item ::= literal | input_parameter
like_expression ::=
string_expression [NOT ]LIKE pattern_value [ESCAPE escape_character]
null_comparison_expression ::=
{single_valued_path_expression | input_parameter}IS [NOT ] NULL
empty_collection_comparison_expression ::=
collection_valued_path_expressionIS [NOT] EMPTY
collection_member_expression ::= entity_expression
[NOT ]MEMBER [OF ] collection_valued_path_expression
exists_expression::= [NOT ]EXISTS (subquery)
all_or_any_expression ::= {ALL |ANY |SOME } (subquery)
comparison_expression ::=
string_expression comparison_operator {string_expression | all_or_any_expression} |
boolean_expression {= |<> } {boolean_expression | all_or_any_expression} |
enum_expression {= |<> } {enum_expression | all_or_any_expression} |
datetime_expression comparison_operator
{datetime_expression | all_or_any_expression} |
entity_expression {= |<> } {entity_expression | all_or_any_expression} |
arithmetic_expression comparison_operator
{arithmetic_expression | all_or_any_expression}
comparison_operator ::== |> |>= |< |<= |<>
arithmetic_expression ::= simple_arithmetic_expression | (subquery)
simple_arithmetic_expression ::=
arithmetic_term | simple_arithmetic_expression {+ |- } arithmetic_term
arithmetic_term ::= arithmetic_factor | arithmetic_term {* |/ } arithmetic_factor
arithmetic_factor ::= [{+ |- }] arithmetic_primary
arithmetic_primary ::=
state_field_path_expression |
numeric_literal |
(simple_arithmetic_expression) |
input_parameter |
functions_returning_numerics |
aggregate_expression
string_expression ::= string_primary | (subquery)
string_primary ::=
state_field_path_expression |
string_literal |
input_parameter |
functions_returning_strings |
aggregate_expression

datetime_expression ::= datetime_primary | (subquery)
datetime_primary ::=
state_field_path_expression |
input_parameter |
functions_returning_datetime |
aggregate_expression
boolean_expression ::= boolean_primary | (subquery)
boolean_primary ::=
state_field_path_expression |
boolean_literal |
input_parameter |
enum_expression ::= enum_primary | (subquery)
enum_primary ::=
state_field_path_expression |
enum_literal |
input_parameter |
entity_expression ::=
single_valued_association_path_expression | simple_entity_expression
simple_entity_expression ::=
identification_variable |
input_parameter
functions_returning_numerics::=
LENGTH( string_primary) |
LOCATE( string_primary, string_primary[, simple_arithmetic_expression]) |
ABS( simple_arithmetic_expression) |
SQRT( simple_arithmetic_expression) |
MOD( simple_arithmetic_expression, simple_arithmetic_expression) |
SIZE( collection_valued_path_expression)
functions_returning_datetime ::=
  CURRENT_DATE |
  CURRENT_TIME |
  CURRENT_TIMESTAMP
functions_returning_strings ::=
CONCAT( string_primary, string_primary) |
SUBSTRING( string_primary,
simple_arithmetic_expression, simple_arithmetic_expression)|
TRIM( [[trim_specification] [trim_character]FROM ] string_primary) |
LOWER( string_primary) |
UPPER( string_primary)
trim_specification ::=LEADING | TRAILING | BOTH
</code>


++ マジックファインダー

DoctrineはDoctrineモデルに対してmagic findersを提供します。これによってモデルに存在するカラムによってレコードを見つけることができます。これはユーザー名でユーザーを簡単に見つけるためもしくはグループの名前でグループを見つけるために役立ちます。通常これは再利用のためにDoctrine_Queryインスタンスを書き込みこれをどこかに保存することが要求されます。このような場合もはや単純な状況に対して必要とされません。

finderメソッドに対するシンプルなパターンは以下の通りです: findBy%s($value)もしくはfindOneBy%s($value)です。%s はカラム名もしくはリレーションエイリアスになることができます。カラム名を与える場合探している値を与えなければなりません。関係エイリアスを指定する場合、見つけるためにリレーションクラスのインスタンスを渡すか実際の主キーの値を渡すことができます。

例:
<code type="php">
// 主キーのメソッドによる通常の見つけ方
$userTable = Doctrine::getTable('User');

$user = $userTable->find(1);

// ユーザー名でユーザーを見つける
$userTable = Doctrine::getTable('User');

$user = $userTable->findOneByUsername('jonwage');

// 上記のユーザーに対して電話番号を見つける
$phoneTable = Doctrine::getTable('Phonenumber');

$phonenumbers = $phoneTable->findByUser($user);
</code>