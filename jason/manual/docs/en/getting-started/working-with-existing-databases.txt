+++ Introduction

A common case when looking for ORM tools like Doctrine is that the database and the code that access it is growing 
large/complex. A more substantial tool is needed then manual SQL code. 

Doctrine has support for generating Doctrine_Record classes from your existing database. There is no need for you to 
manually write all the Doctrine_Record classes for your domain model. 

+++ Making the first import

Let's consider we have a mysql database called test with a single table called 'file'.

The file table has been created with the following sql statement:

<code type="sql">
CREATE TABLE file (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL,
    name VARCHAR(150),
    size BIGINT,
    modified BIGINT,
    type VARCHAR(10),
    content TEXT,
    path TEXT,
    PRIMARY KEY(id))
</code>

Now we would like to convert it into Doctrine record class. It can be achieved easily with the following code snippet:

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));
Doctrine_Manager::connection('mysql://root:dc34@localhost/test');

// import method takes one parameter: the import directory (the directory where
// the generated record files will be put in
Doctrine::generateModelsFromDb('myrecords');
</code>

That's it! Now there should be a file called BaseFile.php in your myrecords/generated directory. The file should look like:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class BaseFile extends Doctrine_Record
{

  public function setTableDefinition()
  {
    $this->setTableName('file');
    $this->hasColumn('id', 'integer', 4, array('unsigned' => 1, 'values' =>  array(), 'primary' => true, 'notnull' => true, 'autoincrement' => true));
    $this->hasColumn('name', 'string', 150, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('size', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('modified', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('type', 'string', 10, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('content', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('path', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
  }

  public function setUp()
  {
    parent::setUp();
  }

}
</code>

You should also have a file called File.php in your myrecords directory. The file should look like:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class File extends BaseFile
{



}
</code>

Doctrine will automatically generate a skeleton Doctrine_Table class for the model at myrecords/UserTable.php. The file 
should look like:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class FileTable extends Doctrine_Table
{



}
</code>

This is where you can put your custom finder methods which can be used by calling Doctrine::getTable('User').

+++ Singularizing Import

By default Doctrine will attempt to ensure your models are singularized when they are imported from an existing 
database. This feature may not be ideal for everyone so it can easily be turned off using an attribute.

<code type="php">
Doctrine_Manager::getInstance()->setAttribute('singularize_import', false);
</code>

Now, if you have a table named "files", the result will be a model named "Files" instead of "File".