++ Dealing with relations

++ Many-to-Many relations

Note: Doctrine requires that Many-to-Many relationships be bi-directional. For example: both User must have many Group and Group must have many User. This is required by Doctrine in order for Many-to-Many relationships to fully work.

+++ Creating a new link

Lets say we have two classes User and Group which are linked through a GroupUser association class. When working with transient (new) records the fastest way for adding a User and couple of Groups for it is:

<code type="php">
$user = new User();
$user->name = 'Some User';
$user->Group[0]->name = 'Some Group';
$user->Group[1]->name = 'Some Other Group';
$user->save();
</code>

However in real world scenarios you often already have existing groups, where you want to add a given user. The most efficient way of doing this is:

<code type="php">
$gu = new GroupUser();
$gu->user_id = $userId;
$gu->group_id = $groupId;
$gu->save();
</code>

+++ Deleting a link

The right way to delete links between many-to-many associated records is by using the DQL DELETE statement. Convenient 
and recommended way of using DQL DELETE is trhough the Query API.

<code type="php">
$deleted = Doctrine_Query::create()
           ->delete()
           ->from('GroupUser')
           ->addWhere('user_id = 5')
           ->whereIn('group_id', $groupIds);
           ->execute();
// print out the deleted links
print $deleted;
</code>

Another way to {{unlink}} the relationships between related objects is through the {{Doctrine_Record::unlink}} method. 
However, you should avoid using this method unless you already have the parent model, since it involves querying the 
database first.

<code type="php">
$user = Doctrine::getTable('User')->find(5);
$user->unlink('Group', array(0, 1));
$user->save();

// you can also unlink ALL relationships to Group
$user->unlink('Group');
</code>

While the obvious and convinient way of deleting a link between User and Group would be the following, you still should 
*NOT* do this:

<code type="php">
$user = Doctrine::getTable('User')->find(5);
$user->GroupUser
     ->remove(0)
     ->remove(1);
$user->save();
</code>

This is due to a fact that $user->GroupUser loads all group links for given user. This can time-consuming task if user 
belongs to many groups. Even if the user belongs to few groups this will still execute an unnecessary SELECT statement.

++ Fetching data

Doctrine provides several different "hydration modes". These are different ways in which data can be retrieved.
Understanding all these modes is important to always make the right choice.

There is one major distinction that divides all the hydration modes into 2 groups: The ones that are based
on identity and the ones that are not.

The hydration modes that are based on (object) identity are: HYDRATE_RECORD, HYDRATE_ARRAY.
The former generates an object graph while the latter generates a nested array structure that is in many cases
very similar to the object graph (Not though that HYDRATE_RECORD/HYDRATE_ARRAY can potentially produce differing results
in more "complex" query scenarios due to the natural difference of objects and arrays, their comparison, equality and identity
semantics!).

The fact that these two hydration modes are based on identity becomes evident through the behavior of Doctrine
to auto-add PK/ID fields of classes used in a DQL query if they are not already present.
This means: These two hydration modes *require* the primary keys/identifiers of all those classes that are participating
in a DQL query in such a way that they are "fetched" (eg at least one field appears in the SELECT clause).

**HYDRATE_RECORD/HYDRATE_ARRAY**

Lets consider we have users and phonenumbers with their relation being one-to-many. Now consider the following plain sql 
query:

<code type="php">
$dbh->fetchAll('SELECT u.id, u.name, p.phonenumber FROM user u LEFT JOIN phonenumber p ON u.id = p.user_id');
</code>

If you are familiar with these kind of one-to-many joins it may be familiar to you how the basic result set is 
constructed. Whenever the user has more than one phonenumbers there will be duplicated data in the result set. 
The result set might look something like:

<code>
 index  | u.id | u.name         | p.phonenumber |
 0      |   1  | Jack Daniels   | 123 123       |
 1      |   1  | Jack Daniels   | 456 456       |
 2      |   2  | John Beer      | 111 111       |
 3      |   3  | John Smith     | 222 222       |
 4      |   3  | John Smith     | 333 333       |
 5      |   3  | John Smith     | 444 444       |
</code>

Here Jack Daniels has 2 phonenumbers, John Beer has one whereas John Smith has 3 phonenumbers. You may notice how clumsy 
this result set is. Its hard to iterate over it as you would need some duplicate data checkings here and there. 

Doctrine identity hydration removes all duplicated data. It also performs many other things such as:

# Custom indexing of result set elements (only with HYDRATE_ARRAY/HYDRATE_RECORD)
# Value casting and preparation (with all hydration modes except HYDRATE_NONE)
# Value assignment listening (only with HYDRATE_ARRAY/HYDRATE_RECORD)
# Makes multi-dimensional array out of the two-dimensional result set array, the number of dimensions is equal to the
number of nested joins  (only with HYDRATE_ARRAY)

Now consider the DQL equivalent of the SQL query we used:
<code type="php">
$array = Doctrine_Query::create()
          ->select('u.id, u.name, p.phonenumber')
          ->from('User u')
          ->leftJoin('u.Phonenumber p')
          ->execute(array(), Doctrine::HYDRATE_ARRAY);
</code>

The structure of this hydrated array would look like:

<code>
array(0 => array('id' => 1,
                 'name' => 'Jack Daniels',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '123 123'),
                          1 => array('phonenumber' => '456 456'))),
      1 => array('id' => 2,
                 'name' => 'John Beer',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '111 111'))),
      2 => array('id' => 3,
                 'name' => 'John Smith',
                 'Phonenumber' =>
                    array(0 => array('phonenumber' => '111 111')),
                          2 => array('phonenumber' => '222 222'),
                          3 => array('phonenumber' => '333 333'))));
</code>

This structure also applies to the hydration of objects(records) which is the default hydration mode of Doctrine. The 
only differences are that the individual elements are represented as Doctrine_Record objects and the arrays converted 
into Doctrine_Collection objects. Whether dealing with arrays or objects you can:

# Iterate over the results using //foreach//
# Access individual elements using array access brackets 
# Get the number of elements using //count()// function
# Check if given element exists using //isset()//
# Unset given element using //unset()//

The other group of hydration modes are not based on identity. These are: HYDRATE_NONE, HYDRATE_SCALAR and HYDRATE_SINGLE_SCALAR.

**HYDRATE_NONE**
This is the fastest but least useful hydration mode. It is equal to a $pdoStmt->fetchAll(PDO::FETCH_NUM);
The reason Doctrine uses FETCH_NUM is that the column aliases in the SQL query are generated by Doctrine, therefore
FETCH_ASSOC would be of no use because you don't know what the names of the columns in the result set would be.
This hydration mode is mainly useful for debugging purposes or for some other simple scenarios.

**HYDRATE_SCALAR**
This hydration mode creates a flat/rectangular result set that can contain duplicate data. It's best to think of
this as a normal SQL result set with a few subtle but important differences:
1) column names are converted to field names (column aliases)
2) data type conversions are applied

Let's look at an example DQL query: SELECT u.*, p.* FROM User u LEFT JOIN u.phonenumbers p
The result with HYDRATE_SCALAR could look like this:

<code>
array(
    0 => array(
        'u_id' => '1',
        'u_name' => 'roman',
        'p_number' => '1234',
        'p_id' => '42'
        ),
    1 => array(
        'u_id' => '1',
        'u_name' => 'roman',
        'p_number' => '1111',
        'p_id' => '43'
        ),
        ...
    )
</code>

As you can see, it looks like a regular SQL result set of a JOINed SQL query. However, in order to
avoid ambiguities between field names all field names in the result set are prefixed with the
DQL alias that you specified in the query. This makes this hydration mode robust even for complex
queries, yet the result is very predictable because the DQL aliases as well as the field names stem
from your DQL query and your object model, respectively. In addition, as noted earlier, data type
conversions take place where necessary.

**HYDRATE_SINGLE_SCALAR**
This is basically a sub-type of HYDRATE_SCALAR. This hydration mode turns out to be very useful.
Without further explanation, let's look at some examples:

<code>
$q = Doctrine_Query::create();
$q->select("u.name")->from("User u");
$res = $q->execute(array(), Doctrine::HYDRATE_SINGLE_SCALAR);
echo $res; // prints 'romanb'

...

$q = Doctrine_Query::create();
$q->select("COUNT(u.id) num_ids")->from("User u");
$res = $q->execute(array(), Doctrine::HYDRATE_SINGLE_SCALAR);
echo $res; // echos '1' or whatever the count is..
</code>

As you can see this hydration mode is self-explanatory. Gone are the times of having to grab such a result
from $result[0][0] or similar.

You should use array or scalar hydration when you only need data for read-only purposes, whereas you should use the 
record(object) hydration when you need/want to operate on the data and/or use the business logic that is coded in your entities (records).

+++ Sample Queries

All of the below queries were executed with the following schema and data fixtures:

Schema

<code type="yaml">
---
User:
  actAs:
    Timestampable:
    Sluggable:
      fields: [username]
  columns:
    email_address: string(255)
    username: string(255)
    password: string(255)
  relations:
    Groups:
      class: Group
      refClass: UserGroup
      foreignAlias: Users

Phonenumber:
  actAs: [Timestampable]
  columns:
    user_id: integer
    phone: string(255)
    primary_num:
      type: boolean
      default: false
  relations:
    User:
      foreignAlias: Phonenumbers

Group:
  # required to renamed to groups because group is a reserved word in mysql
  tableName: groups
  columns:
    name: string(255)

UserGroup:
  columns:
    user_id: integer
    group_id: integer
</code>

Data fixtures

<code type="yaml">
---
User:
  User_1:
    username: jwage
    password: changeme
    Phonenumbers:
      Phonenumber_1:
        phone: 6155139185
        primary_num: true
      Phonenumber_2:
        phone: 6153137679
    Groups: [Group_1]

Group:
  Group_1:
    name: Group 1
  Group_2:
    name: Group 2
</code>

Count number of records for a relationship

<code type="php">
$q = Doctrine_Query::create()
        ->select('u.*, COUNT(DISTINCT p.id) AS num_phonenumbers')
        ->from('User u')
        ->leftJoin('u.Phonenumbers p')
        ->groupBy('u.id');

$users = $q->fetchArray();

echo $users[0]['Phonenumbers'][0]['num_phonenumbers'];
</code>

Retrieve Users and the Groups they belong to

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->leftJoin('u.Groups g');
$users = $q->fetchArray();

foreach ($users[0]['Groups'] as $group) {
    echo $group['name'];
}
</code>

Simple WHERE with one parameter value

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->where('u.username = ?', 'jwage');
$users = $q->fetchArray();
</code>

Multiple WHERE with multiple parameters values

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->where('u.is_active = ? AND u.is_online = ?', array(1, 1));
$users = $q->fetchArray();

// You can also optionally use the addWhere() to add to the existing where parts
$q = Doctrine_Query::create()
        ->from('User u')
        ->where('u.is_active = ?', 1)
        ->addWhere('u.is_online = ?', 1);
$users = $q->fetchArray();
</code>

Using whereIn() convenience method

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->whereIn('u.id', array(1, 2, 3))
$users = $q->fetchArray();

// This is the same as above
$q = Doctrine_Query::create()
        ->from('User u')
        ->where('u.id IN (1, 2, 3)');
$users = $q->fetchArray();
</code>

Using DBMS function in your WHERE

<code type="php">
$userEncryptedKey = 'a157a558ac00449c92294c7fab684ae0';
$q = Doctrine_Query::create()
      ->from('User u')
      ->where("MD5(CONCAT(u.username, 'secret_user_key')) = ?", $userEncryptedKey);
$user = $q->fetchOne();

$q = Doctrine_Query::create()
        ->from('User u')
        ->where('LOWER(u.username) = LOWER(?)', 'jwage');
$user = $q->fetchOne();

</code>

Limiting resultsets using aggregate functions

<code type="php">
// Users with more than 1 phonenumber
$q = Doctrine_Query::create()
        ->select('u.*, COUNT(DISTINCT p.id) AS num_phonenumbers')
        ->from('User u')
        ->leftJoin('u.Phonenumbers p')
        ->having('num_phonenumbers > 1')
        ->groupBy('u.id');
$users = $q->fetchArray();
</code>

Join only primary phonenumbers using WITH

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->leftJoin('u.Phonenumbers p WITH p.primary_num = ?', true);
$users = $q->fetchArray();
</code>

Selecting certain columns for optimization

<code type="php">
$q = Doctrine_Query::create()
        ->select('u.username, p.phone')
        ->from('User u')
        ->leftJoin('u.Phonenumbers p');
$users = $q->fetchArray();
</code>

Using wildcards to select all columns

<code type="php">
// Select all User columns but only the phone phonenumber column
$q = Doctrine_Query::create()
        ->select('u.*, p.phone')
        ->from('User u')
        ->leftJoin('u.Phonenumbers p');
$users = $q->fetchArray();
</code>

Perform DQL delete with simple WHERE

<code type="php">
// Delete phonenumbers for user id = 5
$deleted = Doctrine_Query::create()
           ->delete()
           ->from('Phonenumber')
           ->addWhere('user_id = 5')
           ->execute();
</code>

Perfom simple DQL update for a column

<code type="php">
// Set user id = 1 to active
Doctrine_Query::create()
    ->update('User u')
    ->set('u.is_active', '?', true)
    ->where('u.id = ?', 1)
    ->execute();
</code>

Perform DQL update with dbms functions

<code type="php">
// Make all usernames lowercase
Doctrine_Query::create()
  ->update('User u')
  ->set('u.username', 'LOWER(u.username)')
  ->execute();
</code>

Using mysql LIKE to search for records

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u')
        ->where('u.username LIKE ?', '%jwage%');
$users = $q->fetchArray();
</code>

Use the INDEXBY keyword to hydrate the data where the key of record entry is the name of the column you 
assign

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u INDEXBY u.username');

$users = $q->fetchArray();
print_r($users['jwage']); // Will print the user with the username of jwage
</code>

Using positional and named parameters

<code type="php">
// Positional parameters
$q = Doctrine_Query::create()
          ->from('User u')
          ->where('u.username = ?', array('Arnold'));
$users = $q->fetchArray();

// Named parameters
$q = Doctrine_Query::create()
          ->from('User u')
          ->where('u.username = :username', array(':username' => 'Arnold'));
$users = $q->fetchArray();
</code>

Using subqueries in your WHERE

<code type="php">
// Find uers not in group named Group 2
$q = Doctrine_Query::create()
          ->from('User u')
          ->where('u.id NOT IN (SELECT u.id FROM User u2 INNER JOIN u2.Groups g WHERE g.name = ?)', 'Group 2');
$users = $q->fetchArray();

// You can accomplish this without subqueries like the 2 below
// This is similar as above
$q = Doctrine_Query::create()
        ->from('User u')
        ->innerJoin('u.Groups g WITH g.name != ?', 'Group 2')
$users = $q->fetchArray();

// or this
$q = Doctrine_Query::create()
        ->from('User u')
        ->leftJoin('u.Groups g')
        ->where('g.name != ?', 'Group 2');
</code>

Doctrine has many different ways you can execute queries and retrieve the data. Below is a list of all 
the different ways you can execute queries.

<code type="php">
$q = Doctrine_Query::create()
        ->from('User u');

// Array hydration
$users = $q->fetchArray();                                         // Fetch the results as a hydrated array
$users = $q->execute(array(), Doctrine::HYDRATE_ARRAY);            // This is the same as above
$users = $q->setHydrationMode(Doctrine::HYDRATE_ARRAY)->execute(); // So is this

// No hydration
$users = $q->execute(array(), Doctrine::HYDRATE_NONE);             // Execute the query with plain PDO and no hydration
$users = $q->setHydrationMode(Doctrine::HYDRATE_NONE)->execute();  // This is the same as above

// Fetch one
$user = $q->fetchOne();

// Fetch all and get the first from collection
$user = $q->execute()->getFirst();
</code>

+++ Field lazy-loading

Whenever you fetch an object that has not all of its fields loaded from database then the state of this object is called 
proxy. Proxy objects can load the unloaded fields lazily.

Lets say we have a User class with the following definition:

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('description', 'string');
    }
}
</code>

In the following example we fetch all the Users with the fields name and password loaded directly. Then we lazy-load a 
huge field called description for one user.

<code type="php">
$users = Doctrine_Query::create()
          ->select('u.name, u.password')
          ->from('User u')
          ->execute();

// the following lazy-loads the description fields and executes one additional database query
$users[0]->description;
</code>

Doctrine does the proxy evaluation based on loaded field count. It does not evaluate which fields are loaded on 
field-by-field basis. The reason for this is simple: performance. Field lazy-loading is very rarely needed in PHP 
world, hence introducing some kind of variable to check which fields are loaded would introduce unnecessary overhead 
to basic fetching.

++ Arrays and objects

Doctrine_Records and Doctrine_Collections provide methods to facilitate working with arrays: {{toArray()}}, 
{{fromArray()}} and {{synchronizeWithArray()}}.

+++ toArray

The {{toArray()}} method returns an array representation of your records or collections. It also accesses the 
relationships the objects may have. If you need to print a record for debugging purposes you can get an array 
representation of the object and print that.

<code type="php">
print_r ($user->toArray()); // toArray(false) if you don't want to get the relations
</code>

+++ From Array

If you have an array of values you want to use to fill a record or even a collection, the {{fromArray()}} method 
simplifies this common task.

<code type="php">
// If you have an array like this
$data = array(
  'name' => 'John',
  'age' => '25',
  'Emails' => array('john@mail.com', 'john@work.com')
);

// you can populate a user record with an Emails relationship like this
$user = new User();
$user->fromArray($data);
$user->Emails->count(); // --> 2
</code>

+++ Synchronize With Array

{{synchronizeWithArray()}} allows you to... well, synchronize a record with an array. So if have an array representation 
of your model and modify a field, modify a relationship field or even delete or create a relationship, this changes will 
be applied to the record.

<code type="php">
$user = Doctrine_Query::create()
    ->select('u.*, g.*')
    ->from('User u')
    ->leftJoin('u.Groups g')
    ->where('id = ?', 1)
    ->fetchOne();

// Display this object on a cool javascript form that allows you to:

$arrayUser['name'] = 'New name'; // modify a field
$arrayUser['Group'][0]['name'] = 'Renamed Group'; // modify a field on a relation
$arrayUser['Group'][] = array('name' => 'New Group'); // create a new relation
unset($arrayUser['Group'][1]); // even remove a relation

// submit the form and on the next script use the same query to retrieve the record

$user = Doctrine_Query::create()
    ->select('u.*, g.*')
    ->from('User u')
    ->leftJoin('u.Groups g')
    ->where('id = ?', 1)
    ->fetchOne();

// sanitize the form input an get the data

$user->synchronizeWithArray($arrayUser);
$user->save(); // all changes get applied to the user object
</code>

++ Overriding the constructor

Sometimes you want to do some operations at the creation time of your objects. Doctrine doesn't allow you to override 
the Doctrine_Record::__construct() method but provides an alternative:

<code type="php">
class User extends Doctrine_Record
{
    public function construct()
    {
        $this->name = 'Test Name';
        $this->do_something();
    }
}
</code>

The only drawback is that it doesn't provide a way to pass parameters to the constructor.