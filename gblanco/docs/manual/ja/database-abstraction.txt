++ モジュール
++ エクスポート
+++ 導入
Exportモジュールはデータベース構造を管理するためのメソッドを提供します。メソッドはそれぞれの分担: 作成、編集(変更もしくは更新)、リストもしくは削除(ドロップ)の要素に基づいてグループ化されます。次のドキュメントでは利用可能なメソッドと使い方の例の一覧です。 

Exportモジュールのメソッドを変更するすべてのスキーマはオペレーションを変更するために使われるSQLを返すものと同等です。たとえばcreateTable()はcreateTableSql()によって返される単独のクエリー/複数のクエリーを実行します。

この章では次のテーブルが作成され、変更され、最後にはドロップされます。データベースの名前は"events_db"で次のようなテーブルがあります:
events(id, name, datetime);
people(id, name);
event_participants(event_id, person_id);

+++ データベースを作成する
<code type="php">
$conn->export->createDatabase('events_db');
</code>
+++ テーブルを作成する

データベースが作成されたので、追加のテーブルで処理できます。createTable()メソッドは3つのパラメータを取ります: テーブル名、フィールド定義と追加オプションの配列(任意でRDBMS固有)です。eventsテーブルを作ってみましょう:

<code type="php">
$definition = array (
    'id' => array (
        'type' => 'integer',
        'unsigned' => 1,
        'notnull' => 1,
        'default' => 0,
    ),
    'name' => array (
        'type' => 'string',
        'length' => 255
    ),
    'datetime' => array (
        'type' => 'timestamp'
    )
);

$conn->export->createTable('events', $definition);
</code>
 
定義配列のキーはテーブルのフィールド名です。値は要求されるキーである'type'を含む配列で他のキーも同様で、'type'の値によります。'type'キーの値はDoctrineデータ型とできる限り同じにしてあります。 データ型によりますが、他のオプションも変わることがあります。

||~ データ型 ||~ 長さ ||~ デフォルト ||~ not null ||~ unsigned ||~ autoincrement ||
|| string    || x     || x           || x         ||           ||                ||
|| boolean   ||       || x           || x         ||           ||                ||
|| integer   || x     || x           || x         || x         || x              ||
|| decimal   ||       || x           || x         ||           ||                ||
|| float     ||       || x           || x         ||           ||                ||
|| timestamp ||       || x           || x         ||           ||                ||
|| time      ||       || x           || x         ||           ||                ||
|| date      ||       || x           || x         ||           ||                ||
|| clob      || x     ||             || x         ||           ||                ||
|| blob      || x     ||             || x         ||           ||                ||

peopleテーブルを作成する:

<code type="php">
$options = array(
    'comment' => 'Repository of people',
    'character_set' => 'utf8',
    'collate' => 'utf8_unicode_ci',
    'type'    => 'innodb',
);
$definition = array (
    'id' => array (
        'type' => 'integer',
        'unsigned' => 1,
        'notnull' => 1,
        'default' => 0,
    ),
    'name' => array (
        'type' => 'string',
        'length' => 255
    )
);
$conn->export->createTable('people', $definition, $options);
</code>



+++ 外部キーを作成する

event_participantsテーブルを外部キーで作成します:

<code type="php">
$options = array(
    'foreignKeys' => array('local'   => 'event_id',
                           'foreign' => 'id'
                           'foreignTable' => 'events'
                           'onDelete' => 'CASCADE'),
    'primary' => array('event_id', 'person_id'),
);
$definition = array (
    'event_id' => array (
        'type' => 'integer',
        'unsigned' => 1,
        'notnull' => 1,
        'default' => 0,
    ),
    'person_id' => array (
        'type' => 'integer',
        'unsigned' => 1,
        'notnull' => 1,
        'default' => 0,
    ),
);

$conn->export->createTable('event_participants', $definition, $options);
</code>

外部キーをperson_idにも追加することを考えます。これは次のように実現できます:

<code type="php">
$definition = array('local'   => 'person_id',
                    'foreign' => 'id'
                    'foreignTable' => 'people'
                    'onDelete' => 'CASCADE'))

$conn->export->createForeignKey('event_participants', $definition);
</code>

+++ テーブルを変更する

Doctrine_Exportドライバは既存のデータベースを変更するために簡単にデータベースを移動させる方法を提供します。

注: 生成されたSQLが欲しい場合(そして実行しない)Doctrine_Export::alterTableSql()を使います

<code type="php">
$dbh  = new PDO('dsn','username','pw');
$conn = Doctrine_Manager::getInstance()
        ->openConnection($dbh);

$a    = array('add' => array('name' => array('type' => 'string', 'length' => 255)));


$conn->export->alterTableSql('mytable', $a);

// mysql上でこのメソッドは次のクエリーを返す: 
// ALTER TABLE mytable ADD COLUMN name VARCHAR(255)
</code>

Doctrine_Export::alterTable()は2つのパラメータを取ります:

: string //$name// : 変更されるテーブルの名前。 

: array //$changes// : 実行される変更のそれぞれの方の詳細を含む連想配列。
現在サポートあれる変更の方は次の通りです:

* //name//
テーブルに対する新しい名前。

* //add//

配列のインデックスとして追加されるフィールドの名前を持つ連想配列。配列のそれぞれのエントリの値はプロパティを持った別の連想配列に設定されます。フィールドのプロパティはDoctrineパーサで定義されたものと同じです。

* //remove//

配列のインデックスとして削除されるフィールドの名前を持った連想配列。現在それぞれのエントリに割り当てられら値は無視されます。空の値は将来の互換性のために使われます。

* //rename//

配列のインデックスとしてリネームされるフィールドの名前を持つ連想配列。配列のそれぞれのエントリの名前はnameとDeclarationという名前のエントリを持つ別の連想配列に設定されます。nameエントリは新しいフィールド名を持ち、CREATE TABLE命令文で使われるように、DeclarationはDBMS特有のSQLコードのフィールド宣言の部分を含みます。

* //change//

配列のインデックスとして変更されるフィールドの名前を持つ連想配列。フィールドの名前と他のプロパティを変更するために存在することと、変更配列エントリは配列インデックスとして新しいフィールドの名前を持つことを覚えておいてください。

配列のそれぞれのエントリの値は配列エントリとして変更されるフィールドのプロパティを持った別の連想配列に設定されます。これらのエントリはそれぞれのプロパティの新しい値に割り当てられます。フィールドのプロパティはDoctrineパーサーとして定義されるものと同じです。

<code type="php">
$a = array('name' => 'userlist',
           'add' => array(
                    'quota' => array(
                        'type' => 'integer',
                        'unsigned' => 1
                        )
                    ),
            'remove' => array(
                    'file_limit' => array(),
                    'time_limit' => array()
                    ),
            'change' => array(
                    'name' => array(
                        'length' => '20',
                        'definition' => array(
                            'type' => 'string',
                            'length' => 20
                            )
                        )
                    ),
            'rename' => array(
                    'sex' => array(
                        'name' => 'gender',
                        'definition' => array(
                            'type' => 'string',
                            'length' => 1,
                            'default' => 'M'
                            )
                        )
                    )
            
            );

$dbh  = new PDO('dsn','username','pw');
$conn = Doctrine_Manager::getInstance()->openConnection($dbh);

$conn->export->alterTable('mytable', $a);
</code>


+++ 複数のインデックスを作成する
インデックスを作るために、createIndex()メソッドが使われます。 このメソッドはcreateConstraint()と似た署名を持つので、てーっぶる名、インデックス名と定義配列を取ります。定義配列はインデックスの一部であるフィールドを含む別の連想配列である値を持った一つのキーフィールドを持ちます。フィールドは可能なキーを持った配列として定義されます: 


昇順、降順で値をソートする

長さ、整数値 

すべてのRDBMSがインデックスのソートもしくは長さをサポートしないので、その場合ドライバがそれらを無視します。テストイベントデータベースにおいて、アプリケーションが特定の時間内にイベントを表示することを前提にできるので、選択はWHERE条件でdatetimeフィールドを使います。このフィールド上でインデックスが存在するときに手助けになります。


<code type="php">
$definition = array(
    'fields' => array(
        'datetime' => array()
    )
);
$conn->export->createIndex('events', 'event_timestamp', $definition);
</code>
+++ データベース要素を削除する
上記で示されたすべてのcreate*()に対して、データベース、フィールド、インデックスもしくは制約を削除するために対応するdrop*()メソッドが存在します。drop*()メソッドは削除される項目が存在する場合確認をしませんので、例外を確認するのは開発者の責任です。

<code type="php">
// シーケンスをドロップする
try {
    $conn->export->dropSequence('nonexisting');
} catch(Doctrine_Exception $e) {

}
// 別のシーケンス
$result = $conn->export->dropSequence('people');

// 制約をドロップする
$conn->export->dropConstraint('events', 'PRIMARY', true);
// 注: 3番目のパラメータはこれが主キーの制約であることを
//       ほのめかす
$conn->export->dropConstraint('event_participants', 'unique_participant');

// インデックスをドロップする
$conn->export->dropIndex('events', 'event_timestamp');

// テーブルをドロップする
$conn->export->dropTable('events');

// 今すぐにデータベースをドロップする！
$conn->export->dropDatabase('events_db');
</code>

 
 


 
 

++ インポート
+++ 導入

データベースにあるものを見るために、Importモジュールのlist*()ファミリーの関数を使うことができます。

* listDatabases()

* listFunctions()

* listSequences(): オプションのデータベース名をパラメータとして取る。提供されない場合、現在選択されたデータベースが想定されます。

* listTableConstraints(): テーブル名を取ります

* listTableFields(): テーブル名を取ります

* listTableIndexes(): テーブル名を取ります

* listTables(): おぴうしょんのテーブル名を取ります

* listTableTriggers(): テーブル名を取ります

* listTableViews(): テーブル名を取ります

* listUsers()

* listViews(): オプションのテーブル名を取ります


+++ データベースをリスンする
<code type="php">
$dbs = $conn->import->listDatabases();
print_r($dbs);
</code>
+++ シーケンスをリスンする

<code type="php">
$seqs = $conn->import->listSequences('events_db');
print_r($seqs);
</code>

+++ 制約をリスンする

<code type="php">
$cons = $conn->import->listTableConstraints('event_participants');
</code>

+++ テーブルフィールドをリスンする

<code type="php">
$fields = $conn->import->listTableFields('events');
print_r($fields);
/*
prints:
Array
(
    [0] => id
    [1] => name
    [2] => datetime
)
*/
</code>

+++ テーブルのインデックスをリスンする
<code type="php">
$idx = $conn->import->listTableIndexes('events');
print_r($idx);
/*
prints:
Array
(
    [0] => event_timestamp
)
*/
</code>

+++ テーブルを一覧表示する

<code type="php">
$tables = $conn->import->listTables();
print_r($tables);
/*
prints:
Array
(
    [0] => event_participants
    [1] => events
    [2] => people
)
*/
</code>

+++ ビューをリスンする

<code type="php">
// 現在ビューを作成するメソッドは存在しないので、
// "手動で"行う
$sql = "CREATE VIEW names_only AS SELECT name FROM people";
$conn->exec($sql);
$sql = "CREATE VIEW last_ten_events AS SELECT * FROM events ORDER BY id DESC LIMIT 0,10";
$conn->exec($sql);
// リストビュー
$views = $conn->import->listViews();
print_r($views);
/*
prints:
Array
(
    [0] => last_ten_events
    [1] => names_only
)
*/
</code>

++ DataDict
+++ 導入
DoctrineはネイティブのRDMSの型をDoctrineの型に変換することとリバースするためにDataDictモジュールを内部で使用します。DataDictモジュールは変換に対して2つのメソッドを使います:
1. getPortableDeclaration()、はネイティブのRDBMSの型宣言をポータルなDoctrineの型に変換するために使われます
2. getNativeDeclaration()、はポータルなDoctrineの宣言をドライバ特有の型宣言を変換します


+++ ポータブルな宣言を取得する
<code type="php">
$dbh  = new PDO('mysql:host=localhost;dbname=test', 'username', 'pw');
$conn = Doctrine_Manager::getInstance()->openConnection($dbh);

$decl = $conn->dataDict->getPortableDeclaration('VARCHAR(255)');

print_r($decl);
/*
array('type' => 'string',
      'length' => 255,
      'fixed'  => false,
      'unsigned' => false
      );
*/
</code>
+++ ネイティブな宣言を取得する
<code type="php">
$dbh  = new PDO('mysql:host=localhost;dbname=test', 'username', 'pw');
$conn = Doctrine_Manager::getInstance()->openConnection($dbh);

$portableDecl = array('type' => 'string',
                             'length' => 20,
                             'fixed' => true);
$nativeDecl = $conn->dataDict->getNativeDeclaration($portableDecl);

print $nativeDecl; // CHAR(20)
</code>

++ ドライバ
+++ Mysql
++++ テーブル型を設定する

<code type="php">
$dbh  = new PDO('dsn','username','pw');
$conn = Doctrine_Manager::getInstance()->openConnection($dbh);

$fields = array('id' => array(
                    'type' => 'integer',
                    'autoincrement' => true),
                'name' => array(
                    'type' => 'string',
                    'fixed' => true,
                    'length' => 8)
                );
// 次のオプションはmysql固有のもので
// 他のドライバえはスキップされます
$options = array('type' => 'MYISAM');

$conn->export->createTable('mytable', $fields);

// mysqlにおいて次のクエリーが実行される:
// CREATE TABLE mytable (id INT AUTO_INCREMENT PRIMARY KEY,
//        name CHAR(8));
</code>

