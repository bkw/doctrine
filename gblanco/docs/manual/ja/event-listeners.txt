++ 序文

Doctrineは異なるイベントをリスンするだけでなくリスンされたメソッドの実行を変更することを可能にする柔軟なイベントリスナーアーキテクチャを提供します。

様々なDoctrineコンポーネントに対していくつかの異なるリスナーとフックが存在します。リスナーは個別のクラスであるのに対してフックはリスンされたクラスの範囲内の空のテンプレートメソッドです。

フックはイベントリスナーよりもシンプルですがそれらは異なるアスペクトの分離が欠如しています。Doctrine_Recordフックの利用例です:

<code type="php">
class Blog extends Doctrine_Record 
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        $this->hasColumn('created', 'date');
    }
    public function preInsert($event)
    {
        $this->created = date('Y-m-d', time());
    }
}

// 接続を初期化するなど:

$blog = new Blog();
$blog->title = 'New title';
$blog->content = 'Some content';
$blog->save();

$blog->created; // 2007-06-20 (format: YYYY-MM-DD)
</code>

それぞれのリスナーとフックメソッドは一つのパラメータであるDoctrine_Eventオブジェクトを取得します。Doctrine_Eventオブジェクトは質問のイベントに関する情報を保持しリスンされたメソッドの実行を変更できます。

このドキュメンテーションの目的のために多くのメソッドテーブルが'params'という名前のカラムで提供されています。このテーブルは与えられたイベント上でイベントオブジェクトが保持するパラメータの名前を示します。例えばpreCreateSavepointイベントは一つのパラメータを持ちます。これは、作成されたセーブポイントの名前で、とても直感的にセーブポイントとして保存されるものです。

++ 接続リスナー

接続リスナーはDoctrine_Connectionと(Doctrine_Transactionといった)そのモジュールをリスンするために使用されます。すべてのリスナーメソッドは一つの引数を取ります。この引数であるDoctrine_Eventはリスンされたイベントに関する情報を保持します。

+++ 新しいリスナーを作成する
リスナーを定義するために3つの異なる方法があります。最初はDoctrine_EventListenerを継承するクラスを作成することでリスナーを作成する方法です:

<code type="php">
class MyListener extends Doctrine_EventListener
{
    public function preExec(Doctrine_Event $event)
    {

    }
}
</code>

Doctrine_EventListenerを継承するクラスを宣言することでDoctrine_EventListener_Interfaceの範囲内のすべてのメソッドを定義する必要がないことに注意して下さい。これはDoctrine_EventListenerはこれらすべてのメソッドに対して空のスケルトンを既に持っているからです。

時々、Doctrine_EventListenerを継承したリスナーを定義できないことがあります(他の基底クラスを継承するリスナーがあることもあります)。この場合Doctrine_EventListener_Interfaceを実装できます。

<code type="php">
class MyListener implements Doctrine_EventListener_Interface 
{
    // 注意: すべてのリスナーメソッドはここで定義しなければならない
    // (さもなければPHPはfatal errorをスローする)
    
    public function preExec(Doctrine_Event $event)
    { }
    public function postExec(Doctrine_Event $event)
    { }
    
    // ...
}
</code>

リスナーを作成する三番目の方法はとてもエレガントなものです。Doctrine_Overloadableを実装するクラスを作成できます。このインターフェイスは一つのメソッドのみを持ちます: __call()、これはすべてのイベントをキャッチするために利用できます。

<code type="php">
class MyDebugger implements Doctrine_Overloadable
{
    public function __call($methodName, $args) 
    {
        print $methodName . ' called !';
    }
}
</code>

+++ リスナーを追加する

リスナーをsetListener()を持つ接続に加えることができます

<code type="php">
$conn->setListener(new MyDebugger());
</code>

複数のリスナーを使う必要がある場合addListener()が使えます

<code type="php">
$conn->addListener(new MyDebugger());
$conn->addListener(new MyLogger());
</code>

+++ preConnect、postConnect

+++ トランザクションリスナー
||~ メソッド     ||~ リスン ||~ パラメータ ||
|| preTransactionBegin(Doctrine_Event $event) || Doctrine_Transaction::beginTransaction() || ||
|| postTransactionBegin(Doctrine_Event $event) || Doctrine_Transaction::beginTransaction() || ||
|| preTransactionRollback(Doctrine_Event $event) || Doctrine_Transaction::rollback() || ||
|| postTransactionRollback(Doctrine_Event $event) || Doctrine_Transaction::rollback() || ||
|| preTransactionCommit(Doctrine_Event $event) || Doctrine_Transaction::commit() || ||
|| postTransactionCommit(Doctrine_Event $event) || Doctrine_Transaction::commit() || ||
|| preCreateSavepoint(Doctrine_Event $event) || Doctrine_Transaction::createSavepoint() || savepoint ||
|| postCreateSavepoint(Doctrine_Event $event) || Doctrine_Transaction::createSavepoint() || savepoint ||
|| preRollbackSavepoint(Doctrine_Event $event) || Doctrine_Transaction::rollbackSavepoint() || savepoint ||
|| postRollbackSavepoint(Doctrine_Event $event) || Doctrine_Transaction::rollbackSavepoint() || savepoint ||
|| preReleaseSavepoint(Doctrine_Event $event) || Doctrine_Transaction::releaseSavepoint() || savepoint ||
|| postReleaseSavepoint(Doctrine_Event $event) || Doctrine_Transaction::releaseSavepoint() || savepoint ||

<code type="php">
class MyTransactionListener extends Doctrine_EventListener
{
    public function preTransactionBegin(Doctrine_Event $event)
    {
        print 'beginning transaction... ';
    }

    public function preTransactionRollback(Doctrine_Event $event)
    {
        print 'rolling back transaction... ';
    }
}

</code>

+++ クエリー実行リスナー

||~ メソッド     ||~ リスン ||~ パラメータ ||
|| prePrepare(Doctrine_Event $event) || Doctrine_Connection::prepare() || query ||
|| postPrepare(Doctrine_Event $event) || Doctrine_Connection::prepare() || query ||
|| preExec(Doctrine_Event $event) || Doctrine_Connection::exec() || query ||
|| postExec(Doctrine_Event $event) || Doctrine_Connection::exec() || query, rows ||
|| preStmtExecute(Doctrine_Event $event) || Doctrine_Connection_Statement::execute() || query ||
|| postStmtExecute(Doctrine_Event $event) || Doctrine_Connection_Statement::execute() || query ||
|| preExecute(Doctrine_Event $event) || Doctrine_Connection::execute() * || query ||
|| postExecute(Doctrine_Event $event) || Doctrine_Connection::execute() * || query ||
|| preFetch(Doctrine_Event $event) || Doctrine_Connection::fetch() || query, data ||
|| postFetch(Doctrine_Event $event) || Doctrine_Connection::fetch() || query, data ||
|| preFetchAll(Doctrine_Event $event) || Doctrine_Connection::fetchAll() || query, data ||
|| postFetchAll(Doctrine_Event $event) || Doctrine_Connection::fetchAll() || query, data ||

* preExecute()とpostExecute()はDoctrine_Connection::execute()がプリペアドステートメントパラメータ無しで呼び出されたときのみ起動します。さもなければDoctrine_Connection::execute()はprePrepare、postPrepare、preStmtExecuteとpostStmtExecuteを起動させます



++ クエリーリスナー

クエリーリスナーはビルドするDQLクエリーをリスンすることと結果セットのハイドレーション処理のために使うことができます。2つのメソッド: : preHydrateとpostHydrateはハイドレーション処理をリスンするために存在します。

ハイドレーションリスナーを接続レベルで設定した場合preHydrateとpostHydrateブロックの範囲内のコードは複数のコンポーネントの結果セットの範囲内のすべてのコンポーネントによって起動します。しかしながらテーブルレベルで同様なリスナーを追加する場合テーブルがそのテーブルのデータがハイドレイトされたときのみ起動します。

次のフィールド: firstname、lastnameとageを持つUserという名前のクラスを考えてみましょう。次の例においてfirstnameとlastnameフィールドに基づいてfullnameという名前の生成されたフィールドを常にビルドするリスナーを作成します。

<code type="php">
class HydrationListener extends Doctrine_Record_Listener
{
    public function preHydrate(Doctrine_Event $event)
    {
        $data = $event->data;

        $data['fullname'] = $data['firstname'] . ' ' . $data['lastname'];
    }
}
</code>

これで必要なことはこのリスナーをUserレコードに追加して何人かのユーザーを取得することです。

<code type="php">
$user = new User();
$user->addListener(new HydrationListener());

$users = Doctrine_Query::create()->from('User');

foreach ($users as $user) {
    print $user->fullname;
}
</code>

++ レコードリスナー

Doctrine_RecordはDoctrine_Connectionとよく似ているリスナーを提供します。グローバル、接続とレコード(=テーブル)レベルでリスナーを設定できます。

利用可能なリスナーメソッドの全リストです:

||~ メソッド    ||~ リスン ||
|| preSave(Doctrine_Event $event) || Doctrine_Record::save() ||
|| postSave(Doctrine_Event $event) || Doctrine_Record::save() ||
|| preUpdate(Doctrine_Event $event) || Doctrine_Record::save() when the record state is DIRTY ||
|| postUpdate(Doctrine_Event $event) || Doctrine_Record::save() when the record state is DIRTY ||
|| preInsert(Doctrine_Event $event) || Doctrine_Record::save() when the record state is TDIRTY ||
|| postInsert(Doctrine_Event $event) || Doctrine_Record::save() when the record state is TDIRTY ||
|| preDelete(Doctrine_Event $event) || Doctrine_Record::delete() ||
|| postDelete(Doctrine_Event $event) || Doctrine_Record::delete() ||
|| preValidate(Doctrine_Event $event) || Doctrine_Validator::validate() ||
|| postValidate(Doctrine_Event $event) || Doctrine_Validator::validate() ||

接続リスナーのようにレコードリスナーを定義する方法は3つ存在します。Doctrine_Record_Listenerを拡張する方法、Doctrine_Record_Listener_Interfaceを実装する方法もしくはDoctrine_Overloadableを実装する方法です。次の例においてDoctrine_Overloadableを実装することでグローバルレベルのリスナーを作成します:
<code type="php">
class Logger extends Doctrine_Overloadable
{
    public function __call($m, $a) 
    {
        print 'catched event ' . $m;
        
        // ここでロギングなどをする...
    }
}
</code>

リスナーをマネージャーに追加することは簡単です:

<code type="php">
$manager->addRecordListener(new Logger());
</code>

マネージャーレベルのリスナーを追加することでこれらの接続の範囲内ですべての接続とすべてのテーブル/レコードに影響があることに注意して下さい。次の場合接続レベルリスナーを作成します:

<code type="php">
class Debugger extends Doctrine_Record_Listener
{
    public function preInsert(Doctrine_Event $event)
    {
        print 'inserting a record ...';
    }
    public function preUpdate(Doctrine_Event $event)
    {
        print 'updating a record...';
    }
}
</code>

リスナーを接続に追加することは次のように簡単です:

<code type="php">
$conn->addRecordListener(new Debugger());
</code>

その与えられたテーブル上のアクションのみにリスナーを適用できるように何度もテーブル固有のリスナーが欲しいことがあります。次は例です:

<code type="php">
class Debugger extends Doctrine_Record_Listener
{
    public function postDelete(Doctrine_Event $event)
    {
        print 'deleted ' . $event->getInvoker()->id;
    }
}
</code>

このリスナーを与えられたテーブルに追加する方法は以下の通りです:

<code type="php">
class MyRecord extends Doctrine_Record
{
    public function setTableDefinition()
    {
        // 何かの定義
    }
    
    public function setUp()
    {
        $this->addListener(new Debugger());
    }
}
</code>



++ レコードフック
||~ メソッド     ||~ リスン ||
|| preSave($event) || Doctrine_Record::save() ||
|| postSave($event) || Doctrine_Record::save() ||
|| preUpdate($event) || Doctrine_Record::save() when the record state is DIRTY ||
|| postUpdate($event) || Doctrine_Record::save() when the record state is DIRTY ||
|| preInsert($event) || Doctrine_Record::save() when the record state is TDIRTY ||
|| postInsert($event) || Doctrine_Record::save() when the record state is TDIRTY ||
|| preDelete($event) || Doctrine_Record::delete() ||
|| postDelete($event) || Doctrine_Record::delete() ||
|| preValidate($event) || Doctrine_Validator::validate() ||
|| postValidate($event) || Doctrine_Validator::validate() ||

例 1。insertとupdateフックの使用例
<code type="php">
class Blog extends Doctrine_Record 
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
        $this->hasColumn('created', 'date');
        $this->hasColumn('updated', 'date');
    }
    public function preInsert($event)
    {
        $this->created = date('Y-m-d', time());
    }
    public function preUpdate($event)
    {
        $this->updated = date('Y-m-d', time());
    }
}
</code>

++ リスナーをつなぐ

Doctrineは異なるイベントリスナーをつなぐことを可能にします。このことは同じイベントをリスンするために複数のリスナーを追加できることを意味します。次の例では与えられた接続に対して2つのリスナーを追加する例です:

<code type="php">
// DebuggerとLoggerの両方ともDoctrine_EventListenerを継承する

$conn->addListener(new Debugger());
$conn->addListener(new Logger());
</code>

++ イベントオブジェクト
+++ invokerを手に入れる
getInvoker()を呼び出すことでイベントを起動させるオブジェクトを手に入れることができます:
<code type="php">
class MyListener extends Doctrine_EventListener
{
    public function preExec(Doctrine_Event $event)
    {
        $event->getInvoker(); // Doctrine_Connection
    }
}
</code>
+++ イベントコード

Doctrine_Eventは定数をイベントコードとして使います。上記は利用可能なイベント定数のすべてのリストです:

* Doctrine_Event::CONN_QUERY 
* Doctrine_Event::CONN_EXEC
* Doctrine_Event::CONN_PREPARE 
* Doctrine_Event::CONN_CONNECT 
* Doctrine_Event::STMT_EXECUTE 
* Doctrine_Event::STMT_FETCH 
* Doctrine_Event::STMT_FETCHALL

<code type="php">
class MyListener extends Doctrine_EventListener
{
    public function preExec(Doctrine_Event $event)
    {
        $event->getCode(); // Doctrine_Event::CONN_EXEC
    }
}
</code>

* Doctrine_Event::TX_BEGIN 
* Doctrine_Event::TX_COMMIT
* Doctrine_Event::TX_ROLLBACK
* Doctrine_Event::SAVEPOINT_CREATE 
* Doctrine_Event::SAVEPOINT_ROLLBACK 
* Doctrine_Event::SAVEPOINT_COMMIT 
* Doctrine_Event::RECORD_DELETE
* Doctrine_Event::RECORD_SAVE
* Doctrine_Event::RECORD_UPDATE
* Doctrine_Event::RECORD_INSERT
* Doctrine_Event::RECORD_SERIALIZE
* Doctrine_Event::RECORD_UNSERIALIZE

<code type="php">
class MyRecord extends Doctrine_Record
{
    public function preUpdate(Doctrine_Event $event)
    {
        $event->getCode(); // Doctrine_Event::RECORD_UPDATE
    }
}
</code>
+++ getInvoker()

getInvoker()メソッドは与えられたイベントを呼び出すオブジェクトを返します。Doctrine_Event::CONN_QUERYイベントの例として、呼び出し元は Doctrine_Connectionオブジェクトです。例です:

<code type="php">
class MyRecord extends Doctrine_Record
{
    public function preUpdate(Doctrine_Event $event)
    {
        $event->getInvoker(); // Object(MyRecord)
    }
}
</code>

+++ skipOperation()
Doctrine_Eventはリスナーチェーンの振る舞いを変更するのと同様にリスンされたメソッドの実行を変更するために多くのメソッドを提供します。

いくつかの理由のためにリスンされたメソッドの実行をスキップしたいことがあります。それは次のように行うことができます (preExecはどのリスナーメソッドになることができることに注意してください):

<code type="php">
class MyListener extends Doctrine_EventListener
{
    public function preExec(Doctrine_Event $event)
    {
        // 何らかのビジネスロジック、それから:

        $event->skipOperation();
    }
}
</code>


+++ skipNextListener()

リスナーのチェーンを使用するとき次のリスナーの実行をスキップしたいことがあります。それは次のように達成できます:

<code type="php">
class MyListener extends Doctrine_EventListener
{
    public function preExec(Doctrine_Event $event)
    {
        // 何らかのビジネスロジック、それから:

        $event->skipNextListener();
    }
}
</code>

