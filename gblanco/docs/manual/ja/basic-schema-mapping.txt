++ はじめに

この章と節ではDoctrineで基本的なスキーママッピングを行う方法を説明します。この章の概念に慣れると次の方法がわかります:

1. レコードクラスに対するカラムを定義する
2. テーブルオプションを定義する
3. インデックスを定義する
4. カラムに対する基本的な制約とバリデータを定義する

Doctrineの範囲内ですべてのカラムマッピングはDoctrine_RecordのhasColumn()メソッドを通して行われます。 hasColumnは4つの引数を取ります:

# **カラム名**   カラム名とオプションのエイリアスを指定する文字列です。これはすべてのカラムに対して必要です。カラム名に対してエイリアスを指定したい場合、'[columnName] as [columnAlias]'のフォーマットを使います。

# **カラムタイプ**   カラムタイプを指定する文字列です。カラムタイプのセクションをご覧下さい。

# **カラムの長さ**  カラムの長さを指定する整数です。カラムタイプの中には与えられたポータルタイプだけでなく与えられた長さにも依存するものがあります。例えば、長さ1000を持つ文字列のタイプはmysql上ではネイティブのタイプのTEXTに変換されます。

# **カラムの制約とバリデータ** 与えられたカラムに適用される制約とバリデータを指定する配列です。

バリデータ/カラムの制約とカラム長さフィールドはオプションであることに注意して下さい。長さは長さの引数に対して **null** を使用して省略されることがあります、これによってdoctrineはデフォルトの長さを使用できるようになり、バリデーションもしくはカラム制約に対して4番目の引数が許可されます。

最初の例に取り組んでみましょう。次の定義は'emails'テーブルを参照するEmailクラスを定義します。Emailクラスは2つのカラムid(一つはオートインクリメントの主キーのカラム)と名前がaddressである文字列カラムを持ちます。

addressカラム(notblankとemail)に対して2つのバリデータ/制約を追加する方法に注目して下さい。notblankバリデータはaddressカラムが空白ではないことを前提とするのに対して(空白文字だけが含まれてはならないので)、emailバリデータはaddressが有効なemailアドレスであることを保証します。

<code type="php">
class Email extends Doctrine_Record {
    public function setTableDefinition() {
        // カスタムのテーブル名を設定する:
        $this->setTableName('emails');

        $this->hasColumn('address',         // カラムの名前
                         'string',          // カラムタイプ
                         '200',             // column length
                         array('notblank' => true,
                               'email'    => true  // validators / constraints
                               )
                         );
    }
}
</code>

YAMLスキーマファイルでモデルを定義した場合は以下の様になります。

<code type="yaml">
---
Email:
  tableName: emails
  columns:
    address:
      type: string(200)
      notblank: true
      email: true
</code>


ではこのクラスに対するエクスポートスクリプトを作成してみましょう:


<code type="php">
require_once('Email.php');
require_once('path-to-Doctrine/Doctrine.php');

require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

// エクスポートするためにデータベース接続が必要
$manager = Doctrine_Manager::getInstance();
$conn    = $manager->openConnection('mysql://user:pass@localhost/test');

$conn->export->exportClasses(array('Email'));
</code>


このスクリプトは次のSQLを実行します(ここではデータベースバックエンドとしてMySQLを使用しています):

<code>
CREATE TABLE emails (id BIGINT AUTO_INCREMENT, address VARCHAR(200), PRIMARY KEY(id)) ENGINE = INNODB;
</code>

++ テーブルとクラスの命名

Doctrineはレコードクラス名からテーブル名を自動的に作成します。このため、次のルールを使用してレコード名を名付けることが推奨されます:

* {{CamelCase}}ネーミングを使う
* アンダースコアは許可されます
* 最初の文字は大文字でなければなりません
* クラス名は次のものの一つにはできません(これらのキーワードはDQL APIで保存されます):
* {{ALL}}, {{AND}}, {{ANY}}, {{AS}}, {{ASC}}, {{AVG}}, {{BETWEEN}}, {{BIT_LENGTH}}, {{BY}}, {{CHARACTER_LENGTH}}, {{CHAR_LENGTH}}, {{COUNT}}, {{CURRENT_DATE}}, {{CURRENT_TIME}}, {{CURRENT_TIMESTAMP}}, {{DELETE}}, {{DESC}}, {{DISTINCT}}, {{EMPTY}}, {{EXISTS}}, {{FALSE}}, {{FETCH}}, {{FROM}}, {{GROUP}}, {{HAVING}}, {{IN}}, {{INDEXBY}}, {{INNER}}, {{IS}}, {{JOIN}}, {{LEFT}}, {{LIKE}}, {{LOWER}}, {{MAX}}, {{MEMBER}}, {{MIN}}, {{MOD}}, {{NEW}}, {{NOT}}, {{NULL}}, {{OBJECT}},  {{OF}}, {{OR}}, {{ORDER}}, {{OUTER}}, {{POSITION}}, {{SELECT}}, {{SOME}}, {{SUM}}, {{TRIM}}, {{TRUE}}, {{UNKNOWN}}, {{UPDATE}}, {{UPPER}} and {{WHERE}}.

**例:** {{My_PerfectClass}}

異なるネーミングスキーマを使用する場合、{{setTableDefinition()}}メソッドの{{setTableName()}}メソッドを使用してこれをオーバーライドできます。

++ テーブルオプション

Doctrineは様々なテーブルオプションを提供します。すべてのテーブルオプションは {{Doctrine_Record::option($optionName, $value)}} を通して設定できます。

例えば、MySQLを使用していてINNODBテーブルを使用したい場合次のように行われます:

<code type="php">
class MyInnoDbRecord extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');

        $this->option('type', 'INNODB');
    }
}
</code> 

<code type="yaml">
---
MyInnoDbRecord:
  columns:
    name: string
  options:
    type: INNODB
</code>

次の例ではコレート(照合順序)と文字セットのオプションを設定します：

<code type="php">
class MyCustomOptionRecord extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');

        $this->option('collate', 'utf8_unicode_ci');
        $this->option('charset', 'utf8');
    }
}
</code>

<code type="yaml">
---
MyCustomOptionRecord:
  columns:
    name: string
  options:
    collate: utf8_unicode_ci
    charset: utf8
</code>

一部のデータベース(Firebird, MySql, PostgreSQLなど)では文字セットオプションを設定するだけではDoctrine
が正しいデータを返さないことがあります。これらのデータベースではデータベース接続の際にsetCahtset関数を使うことをお勧めします。

<code type="php">
Doctrine_Manager::connection($name)->setCharset("utf8");
</code>

Doctrineは特定のモデルに対して外部キーを停止する能力を提供します。

<code type="php">
class MyCustomOptionRecord extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');

        $this->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL ^ Doctrine::EXPORT_CONSTRAINTS);
    }
}
</code>

++ カラム

+++ カラムの命名

データベースの互換性に関する一つの問題は多くのデータベースが返されたクエリの結果セットの振る舞いに関して多くのデータベースが異なることです。MySQLはフィールド名を変更しないままにします、このことは、"SELECT myField FROM ..."形式のクエリを発行する場合、結果セットは'myField'フィールドを含むことを意味します。

残念ながら、これはMySQLと他のいくつかのデータベースが行う単なる方法です。例えばPostgresはすべてのフィールド名を小文字で返し、Oracleはすべてのフィールド名を大文字で返します。"だから何？Doctrineを使っているときにこれが何に影響するの？"、とあなたは質問するかもしれません。幸いにも、この問題に悩む必要はまったくありません。

Doctrineはこの問題を透過的に考慮します。派生したRecordクラスを定義して、'myField'という名前のフィールドを定義する場合、MySQLもしくはPostgresもしくはOracleなど使ってものが何であれ$record->myField (もしくは$record['myField']、望むものなら何でも)を通して常にアクセスします。

要約: 望むものなら何でも、under_scores、camelCaseもしくは好きなものは何でもを使用してフィールドを命名できます。

+++ カラムのエイリアス
Doctrineはカラムエイリアスの設定方法を提供します。データベースロジックからアプリケーションロジックを分離したい場合、これはとても便利です。例えば、データベースフィールドの名前を変更した場合、アプリケーションレベルであなたが変更する必要のあるものはカラムの定義です。

<code type="php">
class Book extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('bookName as name', 'string');
    }
}
$book = new Book();
$book->name = 'Some book';
$book->save();
</code>

+++ デフォルトの値
Doctrineはすべてのデータタイプに対してデフォルトの値をサポートします 。デフォルトの値はレコードカラムに付属します。このことは2つのことを意味します。最初この値はすべての新しく作成されたRecordに付属します。

<code type="php">
class User extends Doctrine_record {
    public function setTableDefinition() {
        $this->hasColumn('name', 'string', 50, array('default' => 'default name'));
    } 
}
$user = new User();
print $user->name; // デフォルトの名前
</code>

レコードクラスをデータベースにエクスポートするｔきDEFAULT //の値//はカラム定義文に付属します。


+++ データタイプ
++++ 導入

すべてのDBMSはデータベーステーブルフィールドに保存される情報に対してデータタイプの複数の選択肢を提供します。しかしながら、利用できるデータタイプのセットはDBMSごとに異なります。

DoctrineによってサポートされるDBMSに対するインターフェイスをシンプル化するために、アプリケーションがアクセスする、内部DBMSのデータタイプの基本セットが定義されました。

Doctrineアプリケーションプログラミングインターフェイスはデータベースオプションを運用するときにマッピングデータタイプを考慮します。それぞれのドライバを使用して内部DBMSから送られ取得されたものを変換することも可能です。

次のデータ型の例はDoctrineのcreateTable()メソッドで使われます。
DBMS間のポータブルなテーブルを作るためにデータ型セクションの終わりにある配列の例はcreateTable()によって使われます(適切にサポートされたDBMSバックエンドを調べるためにはDoctrineのメインのドキュメンテーションを参照して下さるようお願いします)。次の例はインデックスの作成とメンテナンスはカバーしないことにも留意すべきで、この章はデータ型とその適切な使い方についてのみ説明をします。

アプリケーションレベルの検証された長さと同様にカラムの長さ(Doctrineバリデータで検証された長さです)はデータベースレベルタイプで影響を受けることに注意すべきです。

例 1. 名前が'content'でタイプは'string'で長さは3000であるカラムは4000の出たベースレベルの長さを持つ'TEXT'データベースタイプになります。しかしながら、レコードが検証されたとき'content'を持つことのみが許可されます - 最大長が3000のカラムです。

例 2. 'integer'タイプと長さ1のカラムは多くのデータベースで'TINYINT'になります。

一般的にDoctrineは指定された長さに依存して使用する整数/文字列タイプのどちらなのかを判断するのに十分に賢いです。

++++ 型の修飾子

Doctrine APIの範囲内で最適なテーブルデザインを助けるために設計されたいくつかの修飾子が存在します。以下の通りです:

* notnull修飾子
* length修飾子
* default修飾子
* いくつかのフィールド定義に対してunsigned修飾子。すべてのDBMSによって整数フィールドタイプに対してこの修飾子はサポートされていません。
* zerofill修飾子(すべてのドライバに対してサポートされていません)
* collation修飾子(すべてのドライバに対してサポートされていません)
* いくつかのフィールド定義に対して修正されたlength修飾子。

上記に基づいて、特定の使い方のシナリオに対してより特定のフィールドタイプを作成するために修飾子はフィールド定義を変えると言っても良いです。notnull修飾子はフフィールド上のデフォルトのDBMS NOT NULL Flagを、フィールド値のDBMSの定義によって、trueもしくはfalseに設定する次の方法で使用されます: PostgreSQLにおいて"NOT NULL"定義は"NOT NULL"に設定されますが、MySQL (例えば)において"NULL"オプションは"NO"に設定されます。"NOT NULL"フィールドタイプを定義するために、追加パラメータを定義配列に追加するだけです(次のセクションで例をご覧下さい)

<code type="php">
'sometime' = array(
    'type'    => 'time',
    'default' => '12:34:05',
    'notnull' => true,
),
</code>

上記の例を使用して、デフォルトのフィールド演算子を調査することもできます。フィールドに対してデフォルトの値を設定するためにnotnull演算子と同じ方法でデフォルトが設定されます。この値はtextフィールド、とフィールドのデータタイプに対する別の有効なデータに対してDBMSがサポートするどの文字セットに対して設定されます。上記の例において、"Time"日付タイプ、'12:34:05'に対して、有効な時間を持ちます。デフォルトのdateとtime、datetimesも同様に、設定するときに選択したDBMSのエポックを調べて範囲内になるようにすべきことを覚えておいて下さい。さもなければ、エラーを診断することが困難な状況に遭遇するでしょう! 

<code type="php">
'sometext' = array(
    'type'   => 'string',
    'length' => 12,
),
</code>

上記の例はデータベーステーブルで12文字の長さのフィールドを変える文字を作成します。長さの定義が省略される場合、Doctrineは指定されたデータタイプに対して最大の許容可能な長さを作成します。このことによってフィールドタイプとインデックス化になんらかの問題が生じることがあります。ベストプラクティスはすべてのもしくはほとんどのフィールドに対して長さを定義することです。

++++ Boolean

booleanデータタイプは1か0のどちら一方の2つの値のみを表します。これらのデータタイプは整数として保存されることを想定していません。DBMSの中には効率の問題のためにこのタイプを単独の文字テキストフィールドで実装しているものがあるからです。三値論理はこのタイプのフィールドに割り当てられることもある第三の可能な値をnullを使用することで可能です。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('booltest', 'boolean');
    }
}
</code>


++++ Integer

integerタイプはPHPのintegerタイプと同じです。これはそれぞれのDBMSが取り扱うことができる最大の整数値を保存します。

このタイプのフィールドは符号無しの整数としてオプションで作成されますがすべてのDBMSはサポートしません。それゆえ、このオプションは無視されることがあります。本当にポータルなアプリケーションはこのオプションの利用可能性に依存すべきではありません。

整数タイプはカラムの長さに依存する異なるデータベースタイプに位置します。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('integertest', 'integer', 4, array('unsigned' => true));
    }
}
</code>


++++ Float

浮動小数データタイプは浮動小数点を保存します。このデータタイプは高い精度が要求されない大きなスケールの範囲内で数字を表すのに最適です。スケールとデータベースに保存される値の精度の制限は使用されるDBMSに依存します。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('floattest', 'float');
    }
}
</code>


++++ String

textデータタイプは長さに対する2つのオプションで利用可能です: 一つは明示的に制限された長さでもう一つはデータベースが許可するのと同じぐらいの大きさの符号無しの長さです。

長さの制限されたオプションは効率の理由からもっとも推奨されます。The 符号無しの長さオプションによって非常に大規模なフィールドが可能になりますがインデックス、nullの可能性の使用を防止し、そのタイプのフィールド上でソートを許可しません。

このタイプのフィールドは8ビットの文字を取り扱うことができます。ドライバはこのタイプに変換さえる文字の値で特別な意味のDBMS特有の文字のエスケーピングを考慮します。

デフォルトではDoctrineは可変長の文字タイプを使用します。修正された長さのタイプは修正された修飾子を通して使用され制御されます。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('stringtest', 'string', 200, array('fixed' => true));
    }
}
</code>


++++ Array

これはPHPの'array'タイプと同じです。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('arraytest', 'array', 10000);
    }
}
</code>


++++ Object

Doctrineはカラムタイプとしてオブジェクトをサポートします。基本的にオブジェクトをフィールドに設定してDoctrineはオブジェクトのシリアライゼーション/アンシリアリゼーションを取り扱います。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('objecttest', 'object');
    }
}
</code>


++++ Blob

Blob (Binary Large OBject)データタイプは、通常はファイルに保存されるデータのような、textフィールドで保存するには大きすぎる未定義の長さのデータを保存することを意味します。

 内部DBMSが"全文検索"として知られる機能をサポートしていない限り、Blobフィールドは通常クエリ検索句(WHERE)のパラメータとして使用されることは意図されていません

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('blobtest', 'blob');
    }
}
</code>


++++ Clob

Clob (Character Large OBject)データタイプは、通常ファイルに保存されるデータのように、テキストフィールドで保存するには大きすぎる未定義な長さのデータを保存することを想定しています。

Clobフィールドは印刷可能なASCII文字のデータモデルのみを保存することが想定されているのに対してblobフィールドはすべてのタイプのデータを保存することが想定されています。

内部のDBMSが通常"全文検索"として知られる機能をサポートしない限りClobフィールドはクエリ検索句(WHERE)のパラメータとして使用されることは想定されていません。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('clobtest', 'clob');
    }
}
</code>


++++ Timestamp

タイムスタンプデータタイプは日にちのデータタイプの単なる日付と時間の組み合わせです。タイムスタンプの値の表現はスペースによって結合された単独文字で日付と時間の文字列の値をjoinすることで達成されます。それゆえ、形式のテンプレートはYYYY-MM-DD HH:MI:SSです。表現された値は日付と時間のデータタイプに対して記述された同じルールと範囲に従います。 

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('timestamptest', 'timestamp');
    }
}
</code>


++++ Time

timeデータタイプは日にちの与えられた瞬間の時間を表します。DBMSから独立した日付の時間の表現はISO-8601標準に従って整形されたテキスト文字列を使用することでも達成されます。 

日にちの時間に対するISO-8601標準によって定義された形式はHH:MI:SSでHHは00から23までの日にちの時間の数でMIとSSはそれぞれ00から59までの分数と秒数です。時間、10未満の分と秒数は左側に0が追加されます。

DBMSの中には日付形式の時間に対してネイティブのサポートをするものがあり、他のものに対してDBMSドライバはそれらを整数もしくはテキストの値として表現しなければなりません。どの場合でも、このタイプのフィールドによるソートクエリの結果と同様に時間の値の間で比較することは常に可能です。


<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('timetest', 'time');
    }
}
</code>


++++ Date

dateデータタイプは年、月と日にちに関する日付を表します。DBMSに独立した日付の表現はISO-8601標準に従って整形されたテキスト文字列を使用することで達成されます。

日付に関してISO-8601標準によって定義された形式はYYYY-MM-DDでYYYYは年数(グレゴリオ歴)、MMは01から12までの月数でDDは01から31までの日数です。10未満の月もしくは日数は左側に0が追加されます。

DBMSの中に日付形式に対してネイティブのサポートをするものがありますが、別の者に対してDBMSドライバはそれらを整数もしくはテキストの値として表すものがあります。どの場合においても、このタイプのフィールドによるソートクエリの結果と同様に日付の値の比較をすることは常に可能です。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('datetest', 'date');
    }
}
</code>


++++ Enum

Doctrineは統一されたenumタイプを持ちます。Enumタイプのカラムは自動的に文字列の値をインデックス番号に変換されます。逆も同様です。カラムに対して可能な値はDoctrine_Record::setEnumValues(columnName, array values)によって指定されます。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('enumtest', 'enum', 4, 
                         array(
                            'values' => array(
                                        'php',
                                        'java',
                                        'python'
                                        )
                               )
        );
    }
}
</code>


++++ Gzip

Gzipデータタイプは取得されたときに存在し圧縮されていないときに自動的に圧縮されること以外は文字列と同じです。このデータタイプはビットマップ画像といった、大きな圧縮率を持つデータを保存するときに便利です。

<code type="php">
class Test extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('gziptest', 'gzip');
    }
}
</code>

++++ 例

次の定義を考えて下さい:


<code type="php">
class Example extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumns(array(
                        'id' => array(
                            'type'     => 'text',
                            'length'   => 32,
                            'fixed' => true,
                        ),
                        'someint' => array(
                            'type'     => 'integer',
                            'length'   => 10,
                            'unsigned' => true,
                        ),
                        'sometext' => array(
                            'type'   => 'text',
                            'length' => 12,
                        ),
                        'somedate' => array(
                            'type' => 'date',
                        ),
                        'sometimestamp' => array(
                            'type' => 'timestamp',
                        ),
                        'someboolean' => array(
                            'type' => 'boolean',
                        ),
                        'somedecimal' => array(
                            'type' => 'decimal',
                        ),
                        'somefloat' => array(
                            'type' => 'float',
                        ),
                        'sometime' => array(
                            'type'    => 'time',
                            'default' => '12:34:05',
                            'notnull' => true,
                        ),
                        'somedate' => array(
                            'type' => 'date',
                        ),
                        'someclob' => array(
                            'type' => 'clob',
                        ),
                        'someblob' => array(
                            'type' => 'blob',
                        ));
}
</code>
 


上記の例はPgsqlといったデータベーステーブルを作成します:


|| カラム       || タイプ                         || Not Null ||デフォルト || コメント ||
|| id            || character(32)                ||          || || ||
|| somename      || character || varying(12)     ||          || || ||
|| somedate      || date                         ||          || || ||
|| sometimestamp || timestamp without time zone  ||          || || ||
|| someboolean   || boolean                      ||          || || ||
|| somedecimal   || numeric(18,2)                ||          || || ||
|| somefloat     || double precision             ||          || || ||
|| sometime      || time without time zone       || NOT NULL || '12:34:05' || ||
|| someclob      || text                         ||          || || ||
|| someblob      || bytea                        ||          || || ||

次はMysqlでのテーブルです:

|| フィールド            || タイプ                         || 照合順序         || 属性 || Null || デフォルト  || コメント ||
|| id               || char(32)                     ||                   ||            || YES  ||          ||         ||
|| somename         || varchar(12)                  || latin1_swedish_ci ||            || YES  ||          ||         ||
|| somedate         || date                         ||                   ||            || YES  ||          ||         ||
|| sometimestamp    || timestamp without time zone  ||                   ||            || YES  ||          ||         ||
|| someboolean      || tinyint(1)                   ||                   ||            || YES  ||          ||         ||
|| somedecimal      || decimal(18,2)                ||                   ||            || YES  ||          ||         ||
|| somefloat        || double                       ||                   ||            || YES  ||          ||         ||
|| sometime         || time                         ||                   ||            || NO   || 12:34:05 ||         ||
|| someclob         || longtext                     || latin1_swedish_ci ||            || YES  ||          ||         ||
|| someblob         || longblob                     ||                   || binary     || YES  ||          ||         ||


+++ 型の変換について


++ 制約とバリデータ
+++ 導入

//[http://www.postgresql.org/docs/8.2/static/ddl-constraints.html PostgreSQLのドキュメンテーション]より://

> データタイプはテーブルに保存されるデータの種類を制限する一つの方法です。多くのアプリケーションのために、しかしながら、それらが提供する制約は荒すぎます。例えば、製品価格を含むカラムは恐らく正の値をしか受け付けないでしょう。しかし、正の数字のみを受け付ける非標準的なデータは存在しません。別の問題は別のカラムもしくは列に関するカラムデータを制約したい場合です。例えば、製品情報を含むテーブルにおいて、それぞれの製品数に対して一つの列があるべきです。

Doctrineによってカラムとテーブル上で*ポータブルな*制約を定義できます。制約によってテーブルで望み通りの制御ができます。ユーザーが制約に違反するカラムにデータを保存しようとすると、エラーが起こります。デフォルトの値定義から値が来る場合でもこれは当てはまります。

Doctrineの制約はアプリケーションと同様にデータベースレベルの制約として振る舞います。このことは二重のセキュリティを意味します: データベースだけでなくアプリケーションも間違った種類の値を許可しません。

Doctrineの範囲内で利用できるバリデータの全リストは以下の通りです:

|| バリデータ(引数) || 制約           || 説明 ||
|| notnull              || NOT NULL              || アプリケーションとデータベースレベルの両方で'not null'制約を保証します ||
|| email                ||                       || 値が有効なemailであるか確認します。 ||
|| notblank             || NOT NULL              || 空白ではないことを確認します。 ||
|| notnull              ||                       || 値がnullではないことを確認します。 ||
|| nospace              ||                       || 値に空白文字が含まれていないか確認します。 ||
|| past                 || CHECK constraint      || 値が過去の日付でないか確認します。 ||
|| future               ||                       || 値が将来の日付か確認します。 ||
|| minlength(length)    ||                       || 値が最小の長さを満たすか確認します。 ||
|| country              ||                       || 値が有効な国コードであるか確認します。 ||
|| ip                   ||                       || 値が有効なIP (internet protocol)アドレスであるか確認します。 ||
|| htmlcolor            ||                       || 有効なhtmlカラーであるか確認します。 ||
|| range(min, max)      || CHECK constraint      || 値が引数で指定された範囲にあるか確認します。 ||
|| unique               || UNIQUE constraint     || 値がデータベーステーブルでユニークであるか確認します。 ||
|| regexp(expression)   ||                       || 値が与えられた正規表現であるか確認します。 ||
|| creditcard           ||                       || 文字列がよく整形されたクレジットカード番号であるか確認します。 ||
|| digits(int, frac)    || Precision and scale   || 与えられた値が整数の桁数の//int//の数と分数の桁数の//frac//の数であるか確認します。 ||

+++ Notnull

not-null制約はカラムがnullの値を想定しないことを指定するだけです。not-null制約は常にカラム制約として書かれます。

次の定義は{{name}}カラムに対してnotnull制約を定義します。このことは指定された空ｍはnullの値を受け入れないことを意味します。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 200, array('notnull' => true,
                                                      'primary' => true));
    }
}
</code>

このクラスはデータベースにエクスプーとされるとき、次のSQL文が実行されます(MySQLです):

<code type="sql">
CREATE TABLE user (name VARCHAR(200) NOT NULL, PRIMARY KEY(name))
</code>

notnull制約はアプリケーションレベルのバリデータとしても振る舞います。Doctrineバリデータはonである場合、Doctrineは指定されたカラムが保存されたときにnullの値を含まないことを自動的に確認することを意味します。

これらのカラムがnullの値を含む場合、{{Doctrine_Validator_Exception}}が起動します。


+++ Unique

Unique制約は一つのカラムもしくはカラムのグループに含まれるデータがテーブルの列に関してユニークであることを保証します。

一般的に、2つもしくはそれ以上の列が制約に含まれるカラムのすべての値が等しいテーブルにある場合unique制約は破られます。しかしながら、
この比較において、2つのnullの値は等しくないと考えられません。unique制約が存在する中でも制約されたカラムの少なくとも一つにnullの値を含む重複した列を保存ｓることは可能であることを意味します。この振る舞いはSQL標準に準拠しますが、データベースの中にはこのルールに従わないものがあります。ですのでポータブルなアプリケーションを開発する予定がある場合は気を付けて下さい。

次の定義は{{name}}カラムに対してunique制約を使います。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 200, array('unique' => true));
    }
}
</code>

>> 注: unique制約は主キーのカラム以外には使わないでしょう。主キーカラムは常にユニークです。

次の定義は{{name}}と{{age}}カラムに対してunique制約を追加します。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 200);
        $this->hasColumn('age', 'integer', 2);
        
        $this->unique(array('name', 'age'));
    }
}
</code>


+++ Check

Doctrineバリデータの中にはデータベースレベルのcheck制約として振る舞うものもあります。これらのバリデータを持つレコードがエクスポートされたとき、追加のCHECK制約がCREATE TABLE命令文に追加されます。

'min'バリデータを使用する次の例を考えて下さい:

<code type="php">
class Product extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', 4, 'primary');
        $this->hasColumn('price', 'decimal', 18, array('min' => 0));
    }
}
</code>

エクスポートされるとき与えられたクラス定義は次の命令文を実行します(pgsqlにおいて):

<code type="sql">
CREATE TABLE product (
    id INTEGER,
    price NUMERIC,
    PRIMARY KEY(id),
    CHECK (price >= 0))
</code>

なので、Doctrineはデータベースレベルでもオプションとして 製品の価格が0を下回らないことを保証します。

'max'バリデータを使用してカラムの最大の値も設定できます。これは同等のCHECK制約を作成します。

<code type="php">
class Product extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', 4, 'primary');
        $this->hasColumn('price', 'decimal', 18, array('min' => 0, 'max' => 1000000));
    }
}
</code>

Generates (in pgsql):

<code type="sql">
CREATE TABLE product (
    id INTEGER,
    price NUMERIC,
    PRIMARY KEY(id),
    CHECK (price >= 0),
    CHECK (price <= 1000000))
</code>

最後にDoctirne_Recordのcheck()メソッドを使用することでCHECK制約の種類を作成できます。最後の例において価格が割引価格よりも常に高いことを保証する制約を追加します。

<code type="php">
class Product extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', 4, 'primary');
        $this->hasColumn('price', 'decimal', 18, array('min' => 0, 'max' => 1000000));
        $this->hasColumn('discounted_price', 'decimal', 18, array('min' => 0, 'max' => 1000000));
        
        $this->check('price > discounted_price');
    }
}
</code>

次のコードが生成されます(pgsqlにて):

<code type="sql">
CREATE TABLE product (
    id INTEGER,
    price NUMERIC,
    PRIMARY KEY(id),
    CHECK (price >= 0),
    CHECK (price <= 1000000),
    CHECK (price > discounted_price))
</code>


> 注: データベースの中にはCHECK制約をサポートしないものがあります。これに当てはまる場合、Doctrineが単にcheck制約の作成をスキップします。

Doctrineバリデータが有効な場合与えられた定義はレコードが保存されているときに価格が常にゼロよりも大きいことを保証します。

トランザクションの範囲内で保存された製品の価格がゼロを下回るものがある場合、DoctrineはDoctrine_Validator_Exceptionをスローして自動的にトランザクションをロールバックします。


++ レコード識別子
+++ 導入

Doctrineは多くの種類の識別子をサポートします。多くの場合主キーを指定しないことが推奨されます(Doctrineは{{id}}フィールド名をオートインクリメントされる主キーとして使用します)。テーブル作成を使用するとき、Doctrineは連番のオートインクリメンテーションをエミュレートするほど賢くネイティブにそれをサポートしないデータベース上で動作します。


+++ Natural

Natural識別子はuniqueとnon-nullのプロパティもしくはプロパティの組み合わせです。natual識別子の使用は推奨されます。

<code type="php">
class User extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 200, array('primary' => true));
    }
}
</code>

+++ オートインクリメント
オートインクリメントの主キーはもっとも基本的な識別子で使用は強く推奨されます。オートインクリメントの主キーのための{{id}}以外でも使いたいことがあります。次のように指定できます:

<code type="php">
class User extends Doctrine_Record {
    public function setTableDefinition() {
        $this->hasColumn('uid', 'integer', 20, array('primary' => true, 'autoincrement' => true));

    }
}
</code>

レコードが自然に識別できないとき(言い換えるとnatual識別子を持たない)オートインクリメントもしくは連番の主キーの使用を考えるべきです。

次の例はnatual識別子がなぜ効率的であるのか示しています。

3つのクラス、Permission、RoleとRolePermissionを考えてみましょう。ロールは多くのパーミッションを持ち逆も同じです(リレーションは多対多です)。ではそれぞれのロールとパーミッションが自然にそれぞれの名前で識別されることを前提とします。

ではオートインクリメントの主キーをこれらのクラスに追加することは馬鹿げてします。より多くのデータが要求されクエリがより非効率的になります。例えば'Admin'ロールに対してすべてのパーミッションを取得することは次のように行われます(autoinc pksを使用するとき):

<code type="sql">
SELECT p.* 
    FROM Permission p
        LEFT JOIN RolePermission rp ON rp.permission_id = p.id
        LEFT JOIN Role r ON rp.role_id = r.id
    WHERE r.name = 'Admin'
</code>

SQLのJOINSは常にサーバーの負荷が大きくこれらの2つを使用していることを覚えて下さい。 natural識別子を使用するときクエリは次のようになります:

<code type="sql">
SELECT p.*
    FROM Permission p
        LEFT JOIN RolePermission rp ON rp.permission_name = p.name
    WHERE rp.role_name = 'Admin'
</code>

Thats -1 JOIN ! 

+++ 複合

複合主キーは関連テーブル(共に2つのコンポーネントを接続するテーブル)で効果的に使用されます。どこでも複合主キーを使用することは推奨されません。Doctrineは複数のカラム上でリレーションのマッピングをサポートしないからです。

このためdoctrineベースのシステムは関連テーブルに対してもオートインクリメントの主キーを持つ場合ベターにscaleします。

<code type="php">
class Groupuser extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('user_id', 'integer', 20, array('primary' => true));
        $this->hasColumn('group_id', 'integer', 20, array('primary' => true));
    }
}
</code>


+++ シーケンス

Doctrineはrecord識別子の生成に対して連番をサポートします。連番はデータの列に対してユニー名IDを提供する方法の一つです。例えばMySQLで多くの作業に取り組む場合、連番を{{AUTO_INCREMENT}}を行う別の方法として考えて下さい。

Doctrineはバックグラウンドで連番生成の方法を知っているのでデータベース特有のクエリを呼び出すことに悩む必要はありません - Doctrineが代わりに行いますので、あなたが行う必要のあることは連番カラムとしてカラムを定義しオプションとして連番テーブルの名前と連番テーブルのidカラム名を提供することです。

次のレコード定義を考えてみましょう:

<code type="php">
class Book extends Doctrine_Record 
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', null, array('primary' => true, 'sequence' => true));
        $this->hasColumn('name', 'string');
    }
}
</code>

デフォルトでDoctrineは{{[tablename]_seq}}連番テーブルに対して次の形式を使用します。これを変更したい場合、形式を変更する次のコードのピースを使うことができます:

<code type="php">
$manager = Doctrine_Manager::getInstance();
$manager->setAttribute(Doctrine::ATTR_SEQNAME_FORMAT, '%s_my_seq');
</code>

Doctrineはidの名前を持つカラムを連番テーブルの連番ジェネレータカラムとして使用します。(すべての接続とすべてのテーブルに対して)これをグローバルに変更したい場合次のコードを使うことができます:

<code type="php">
$manager = Doctrine_Manager::getInstance();
$manager->setAttribute(Doctrine::ATTR_SEQCOL_NAME, 'my_seq_column');
</code>

次の例においてグローバルコンフィギュレーションを変更したい場合。{{id}}カラムを{{bool_sequence}}とい名前の連番テーブルにします。これは次のようにできます:  

<code type="php">
class Book extends Doctrine_Record {
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', null, array('primary', 'sequence' => 'book_sequence'));
        $this->hasColumn('name', 'string');
    }
}
</code>

ここで以前の例を少し変更します: カスタムの連番カラムが欲しい場合、次のようになります:

<code type="php">
class Book extends Doctrine_Record {
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', null, array('primary', 'sequence' => array('book_sequence', 'sequence')));
        $this->hasColumn('name', 'string');
    }
}
</code>



++ インデックス
+++ 導入

インデックスは特定の値を持つ列を素早く見つけるために使われます。インデックス無しでは、データベースは関係のある列を見つけるために列の最初から始めてテーブル全体を通読しなければなりません。

テーブルが大きくなるほど、作業時間がより消費されます。テーブルが質問のカラムに対するインデックスを持つ場合、データベースはデータをすべて調べることをせずにデータファイルの真ん中で探そうとしている位置を素早く決定できます。テーブルが1000の列を持つ場合、これは一つ一つの例を読むよりも少なくとも100倍速いです。

インデックスにはinsertとupdateを遅くするコストが伴われます。しかしながら、一般的に、SQLをwhere条件が使用されるフィールドに対して**常に**インデックスを使用すべきです。


+++ インデックスを追加する

{{Doctrine_Record::index('indexName', $definition)}}を呼ぶだけでインデックスを追加できます。{{$definition}}は定義配列です。

単独のインデックスを{{name}}という名前のフィールドに追加する例です:

<code type="php">
class IndexTest extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string');

        $this->index('myindex', array('fields' => 'name');
    }
}
</code>

マルチカラムのインデックスを{{name}}という名前のフィールドに追加する例です
:

<code type="php">
class MultiColumnIndexTest extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string');
        $this->hasColumn('code', 'string');

        $this->index('myindex', array('fields' => array('name', 'code')));
    }
}
</code>

同じテーブルで複数のカラムを追加する例です:

<code type="php">
class MultipleIndexTest extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string');
        $this->hasColumn('code', 'string');
        $this->hasColumn('age', 'integer');

        $this->index('myindex', array('fields' => array('name', 'code')));
        $this->index('ageindex', array('fields' => array('age')));
    }
}
</code>


+++ インデックスオプション

DoctrineはDB特有のものも含む多くのインデックスオプションを提供します。次は利用可能なオプションの全リストです:

<code>
sorting     => string('ASC' / 'DESC')      
        what kind of sorting does the index use (ascending / descending)

length      => integer
        index length (only some drivers support this)

primary     => boolean(true / false)        
        whether or not the index is primary index

type        => string('unique',         -- supported by most drivers
                      'fulltext',       -- only availible on Mysql driver
                      'gist',           -- only availible on Pgsql driver
                      'gin')            -- only availible on Pgsql driver
</code>

<code type="php">
class MultipleIndexTest extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string');
        $this->hasColumn('code', 'string');
        $this->hasColumn('age', 'integer');

        $this->index('myindex', array(
                      'fields' => array(
                                  'name' =>
                                  array('sorting' => 'ASC',
                                        'length'  => 10),
                                  'code'),
                      'type' => 'unique',
                      ));
    }
}
</code>


+++ 特別なインデックス

Doctrineは多くの特別なインデックスをサポートします。これらはMysql FULLTEXTとPgsql GiSTインデックスを含みます。次の例において'content'フィールドに対してMysqlのFULLTEXTインデックスを定義します。

<code type="php">
class Article 
{
    public function setTableDefinition() 
    {
    	$this->hasColumn('name', 'string');
        $this->hasColumn('content', 'string');

        $this->index('content', array('fields' => 'content',
                                      'type'   => 'fulltext'));
    }
}
</code>
