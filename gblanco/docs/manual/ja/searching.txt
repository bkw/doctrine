++ 序文

検索は大きな題目なので、この章のすべてをDoctrine_Searchというプラグインの解説に当てます。Doctrine_Searchは全文索引作成と検索のためのツールです。データベースとファイルの両方の索引作成と検索のために使うことができます。

次の定義を持つNewsItemという名前のクラスを考えてみましょう:

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }
}
</code>

異なる新しい項目を検索することを許可するアプリケーションを考えてみましょう。これを実装する明らかな方法はフォームを構築して次のようなDQLクエリーフォームに基づくことです:
<code type="sql">
SELECT n.* FROM NewsItem n WHERE n.title LIKE ? OR n.content LIKE ?
</code>

アプリケーションが成長するにつれてこの種のクエリーはとても遅くなります。たとえば'%framework%'と'%framework%'パラメータで前のクエリーを使うとき('framework'という単語を含むタイトルもしくは内容を持つすべての新しい項目を見つけることと同等です)データベースは、自然にとてもとても遅い、テーブルでそれぞれの列を検討しなければなりません。

Doctrineは検索コンポーネントと逆インデックスでこれを解決します。最初に少し我々の定義を変えてみましょう:

<code type="php">
class NewsItem extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('content', 'string');
    }
    public function setUp()
    {
        $this->actAs('Searchable', array('fields' => array('title', 'content')));
    }
}
</code>

NewsItemクラスが検索可能なものとして振る舞うようにDoctrineに伝え(内部ではDoctrineがDoctrine_Template_Searchableをロードします)titleとcontentフィールドが全文インデックスが作成されたフィールドとしてマークされます。これが意味するのはNewsItemが追加もしくは更新されるたびにDoctrineは次のことを行います:

1. 逆検索インデックスを更新するもしくは
2. 新しい追加エントリーを逆検索インデックスに追加する(場合によってバッチで逆検索インデックスを更新するよりも効率的です)

searchオブジェクトオプションを後で変更したくなることがあります。searchオブジェクトは次のようにアクセスされます:

<code type="php">
$search = $conn->getTable('NewsItem')
               ->getTemplate('Searchable')
               ->getPlugin();
</code>

++ インデックス構造

Doctrineが使用する逆インデックスの構造は次の通りです:

[ (string) keyword] [ (string) field ] [ (integer) position ] [ (mixed) [foreign_keys] ] 

* **keyword**は検索されるテキストにあるキーワードです
* **field**はキーワードが見つかったフィールドです
* **position**はキーワードが見つかった位置です
* **[foreign_keys]**は独自のコンポーネント(ここではNewsItem)に依存する一つもしくは複数のフィールドです

NewsItemの例において[foreign_keys]は NewsItem(id)への外部キー参照とonDelete => CASCADE制約を持つシンプルなifフィールドを含みます。

このテーブルで例の列は次のようになります:

|| keyword     || field       || position    ||    id  ||
|| database    || title       || 3           ||    1   ||

この例においてdatabaseという言葉はNewsItem 1のtitleフィールドの3番目の言葉です。

++ インデックスの構築

検索可能なレコードがデータベースに追加されるときとはDoctrineは常にインデックス構築の処理を実行します。処理が検索リスナーによって呼び出されているときにこれはバックグラウンドで行われます。この処理フェーズは次の通りです:

1. テキストに基づいたDoctrine_Search_Analyzerを使用してテキストを解析する
2. すべての解析されたキーワードに対して新しい列をインデックステーブルに追加する

ときに新しい検索可能なエントリが追加されたときにインデックステーブルを更新したくないことがあります。むしろある感覚でインデックステーブルを更新するバッチが欲しいことがあります。直接の更新機能を無効にするためにbatchUpdatesオプションをtrueに設定する必要があります。

<code type="php">
$search->setOption('batchUpdates', true);
</code>

実際のバッチ更新処理はbatchUpdateIndex()メソッドで呼び出しできます。1つのオプション引数: limitとoffsetを取ります。limitはインデックスが作成されたエントリのバッチ数を制限するために使われるのに対して。offsetはインデックス作成を始める最初のエントリを設定するために使われます。

<code type="php">
$newsItem = new NewsItem();

$newsItem->batchUpdateIndex();
</code>


++ テキストアナライザー

デフォルトでDoctrineはテキストを解析するためにDoctrine_Search_Analyzer_Standardを使います。このクラスは次の内容を実行します:

1. ストップキーワードをストリッピングする('and'、'if'など)
    'and'、'if'などの多くで共通に使われる言葉は検索に対して関係ないので、それらはインデックスサイズを妥当なものにするためにストリッピングする。
2. すべてのキーワードを小文字にする
    標準アナライザはすべてのキーワードを小文字にするので小文字'database'と'DataBase'の単語が検索されると標準アナライザは同等なものと見なします。
3. すべてのアルファベットと数字ではない記号を空白に置き換えます
    通常のテキストにおいて多くのキーワードはそれらの後でアルファベットではない文字を含むことになります。たとえば'database.'です。標準的なアナライザは'database'が'database.'にマッチするようにこれらをストリッピングします。
4. すべての引用符は空の文字に置き換えられます。たとえば "O'Connor"は"oconnor"にマッチします

Doctrine_Search_Analyzer_Interfaceを実装するクラスを作成することで独自のアナライザを書くことができます。このアナライザは次のようにsearchオブジェクトに適用できます:

<code type="php">
$search->setOption('analyzer', new MyAnalyzer());
</code>

++ クエリー言語

Doctrine_SearchはApache Luceneと似たクエリー言語を提供します。The Doctrine_Search_Queryの背後で解析されたものは人間が読みやすく簡単に構築できる検索クエリーをそれらの複雑なSQLと同等なものに変換します。

++ ファイル検索

Doctrine_Searchの前に説明したようにファイルを検索するためにも使うこともできます。検索可能にしたいディレクトリｇあるとします。最初にファイル検索に対して必要な追加機能を提供するDoctrine_Searchの小クラスであるDoctrine_Search_Fileのインスタンスを作成する必要があります。

<code type="php">
$search = new Doctrine_Search_File();
</code>

2番目にすることはインデックステーブルを生成することです。デフォルトでDoctrineはデータベースインデックスクラスをFileIndexと名付けます。

<code type="php">
$search->buildDefinition(); // テーブルとレコードクラス定義へのビルド

$conn->export->exportClasses(array('FileIndex'));
</code>

これでファイルサーチャーを使って始めることができます。最初にいくつかのディレクトリのインデックスを作成してみましょう:

<code type="php">
$search->indexDirectory('myfiles');
</code>

indexDirectory()は再起的に与えられたディレクトリをイテレートし必要なインデックステーブルを更新するそれの範囲ですべてのふぁりうを解析します。

最後にインデックスが作成されたファイルの範囲内でテキストのピースの検索を始めることができます:

<code type="php">
$resultSet = $search->search('database orm');
</code>


