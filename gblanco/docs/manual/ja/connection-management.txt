++ DSN (データソース名)

Doctrineを通してデータベースに接続するために、正しいDSN - データソース名(data source name)を作成しなければなりません。

DoctrineはPDO形式のDSNと同様にPEARとDB/MDB2形式のDSNをサポートします。次のセクションではPEAR形式のDSNを取り扱います。PDO形式のDSNに関して詳細な情報な必要な場合、[[php PDO->__construct()]]をご覧下さい。

DSNは次の部分で構成されます:

||~ DSN part   ||~ 説明 ||
||  phptype    ||  PHPで使用されるデータベースバックエンド (mysql、pgsqlなど) ||
||  dbsyntax   ||  SQL構文などに関して使用されるデータベース ||
||  protocol   ||  使用する通信プロトコル(tcp、unixなど) ||
||  hostspec   ||  ホストを指定します(hostname[:port]) ||
||  database   ||  DBMSサーバー上で使用されるデータベース ||
||  username   ||  ログイン用のユーザー名 ||
||  password   ||  ログイン用のパスワード ||
||  proto_opts ||  プロトコルと一緒に使用されることがあります ||
||  option     ||  URIクエリ文字列形式の追加接続オプションです。オプションはアンパサンド(&)によって分割されます。次の表でオプションのリストの一部が記述されています: ||


**オプションのリスト**

||~ 名前     ||~ 説明 ||
||  charset  ||  バックエンドの中にはクライアントの文字エンコーディングの設定をサポートするものがあります。||
||  new_link ||  RDBMSの中には同じホストに複数回接続するときに新しい接続を作成しないものがあります。このオプションは新しい接続を強制することを試みます。 ||

DSNは連想配列もしくは文字列のどちらかで提供されます。サポートされたDSNの文字列形式は次の通りです:

<code>
phptype(dbsyntax)://username:password@protocol+hostspec/database?option=value
</code>

以下のような多くのバリエーションが可能です:

<code>
phptype://username:password@protocol+hostspec:110//usr/db_file.db
phptype://username:password@hostspec/database
phptype://username:password@hostspec
phptype://username@hostspec
phptype://hostspec/database
phptype://hostspec
phptype:///database
phptype:///database?option=value&anotheroption=anothervalue
phptype(dbsyntax)
phptype
</code>

現在サポートされているデータベースのバックエンドは次の通りです: 

||~ ドライバ名 ||~ サポートされるデータベース ||
||  fbsql       ||  FrontBase ||
||  ibase       ||  InterBase / Firebird (PHP5が要求されます) ||
||  mssql       ||  Microsoft SQL Server (Sybaseではありません。--with-mssqlでPHPをコンパイルして下さい) ||
||  mysql       ||  MySQL ||
||  mysqli      ||  MySQL (新しい認証プロトコルをサポート) (PHP 5が必要です) ||
||  oci8        ||  Oracle 7/8/9/10    ||
||  pgsql       ||  PostgreSQL  ||
||  querysim    ||  QuerySim   ||
||  sqlite      ||  SQLite 2 ||

2番目のサポートされたDSN形式は次の通りです

<code>
phptype(syntax)://user:pass@protocol(proto_opts)/database
</code>

データベース、オプションの値、ユーザー名もしくはパスワードがDSN部分を線引きするために使用される文字を含む場合、URIの16進法のエンコーディングを通してそれらをエスケープできます:  

||~ 文字 ||~ 16進法のコード ||
|| :          ||  %3a      ||
|| /          ||  %2f      || 
|| @          ||  %40      || 
|| +          ||  %2b      || 
|| (          ||  %28      || 
|| )          ||  %29      || 
|| ?          ||  %3f      || 
|| =          ||  %3d      || 
|| &          ||  %26      || 

注意
いくつかの機能はすべてのデータベースバックエンドでサポートされないことにご注意下さい。  

+++ 例

**例 1.** ソケットを通してデータベースに接続する

<code>
mysql://user@unix(/path/to/socket)/pear
</code>

**例 2.** 非標準的なポート上でデータベースに接続する

<code>
pgsql://user:pass@tcp(localhost:5555)/pear
</code>

**例 3.** オプションを使用してUnixマシン上でSQLiteに接続する

<code>
sqlite:////full/unix/path/to/file.db?mode=0666
</code>

**例 4.** オプションを使用してWindowsマシン上でSQLiteに接続する

<code>
sqlite:///c:/full/windows/path/to/file.db?mode=0666
</code>

**例 5.** SSLを使用してMySQLiに接続する

<code>
mysqli://user:pass@localhost/pear?key=client-key.pem&cert=client-cert.pem
</code>

++ 新しい接続を開く

Doctrineで新しいデータベース接続を開くことはとても簡単です。PDO (www.php.net/PDO)を使用することを望むのであれば、新しPDOオブジェクトを初期化するだけです:

<code type="php">
$dsn = 'mysql:dbname=testdb;host=127.0.0.1';
$user = 'dbuser';
$password = 'dbpass';

try {
    $dbh = new PDO($dsn, $user, $password);
    $conn = Doctrine_Manager::connection($dbh);
} catch (PDOException $e) {
    echo 'Connection failed: ' . $e->getMessage();
}
</code>

注意： Doctrine_Manager::connection()にPDOインスタンスを直接渡しても既に存在するPDOインスタンスには存在しないためDoctrineは接続のためのユーザーネームとパスワードを受け付けません。データベースを作成したり削除するためにDoctrineはユーザーネームとパスワードを必要とします。これを可能にするためにはユーザーネームとパスワードを$connオブジェクトに直接設定する必要があります。

<code type="php">
$conn->setOption('username', 'username');
$conn->setOption('password', 'password');
</code>

++ データベースへの遅延接続

データベースへのレイジー接続によって多くのリソースを節約できます。実際データベース接続が必要ではないページは多くあるかもしれないので、常にDoctrineが必要な時にだけデータベースに接続するレイジー接続を使用することをお勧めします。

この機能は例えばページキャッシングを使用するときなどにとても便利で、すべてのリクエストごとにデータベース接続が作られなくなります。データベースに接続することはとても負荷のかかるオペレーションであることを覚えておいて下さい。

<code type="php">
$dsn = 'mysql://username:password@localhost/test';

// 新しいDoctrine_Connectionを初期化する
$conn = Doctrine_Manager::connection($dsn);
// !! まだ実際のデータベース接続ではありません !!

// データベースに接続してクエリを実行する
$conn->query('FROM User u');
</code>

++ 接続を管理する

最初からDoctrineは複数の接続で動作するように設計されてきました。個別に指定されない限りDoctrineはクエリを実行するために常に現在の接続を使用します。次の例は {{openConnection()}} の２番目の引数を接続エイリアスのオプションとして使用します。

<code type="php">
// Doctrine_Managerはすべての接続を制御する

$manager = Doctrine_Manager::getInstance();

// 最初の接続を開く
 
$conn = $manager->openConnection(new PDO('dsn','username','password'), 'connection 1');
</code>

利便性のために {{Doctrine_Manager}} はスタティックメソッドである {{connection()}} を提供します。このメソッドは引数が与えられたときに新しい接続を開き、引数が指定されないときは現在の接続を返します。

<code type="php">
// 最初の接続を開く
 
$conn = Doctrine_Manager::connection(new PDO('dsn','username','password'), 'connection 1');

$conn2 = Doctrine_Manager::connection();

// $conn2 == $conn
</code>

現在の接続は最後に開かれた接続です。

<code type="php">
// 2番目の接続を開く

$conn2 = $manager->openConnection(new PDO('dsn2','username2','password2'), 'connection 2');

$manager->getCurrentConnection(); // $conn2
</code>

{{setCurrentConnection()}} を呼んで現在の接続を変更できます。

<code type="php">
$manager->setCurrentConnection('connection 1');

$manager->getCurrentConnection(); // $conn
</code>

managerオブジェクトをforeach句に渡すだけで開いた接続を反復できます。{{Doctrine_Manager}} が特別な{{IteratorAggregate}} インターフェースを implements することでこれが可能になっています。

<code type="php">
// 接続を通してイテレートする

foreach($manager as $conn) {

}
</code>

++ 接続コンポーネントバインディング

Doctrineによってコンポーネント(= ActiveRecordクラス)への接続をバインドできます。このことはコンポーネントがクエリを発行するかデータがコンポーネントが指定しているテーブルから取得されるたびにDoctrineはバインドされた接続を使用します。

<code type="php">
$conn = $manager->openConnection(new PDO('dsn','username','password'), 'connection 1');

$conn2 = $manager->openConnection(new PDO('dsn2','username2','password2'), 'connection 2');

$manager->bindComponent('User', 'connection 1');

$manager->bindComponent('Group', 'connection 2');

$q = new Doctrine_Query();

// ここで取得するためにDoctrineは'connection 1'を使用する
$users = $q->from('User u')->where('u.id IN (1,2,3)')->execute();

// Doctrineはここで取得するために'connection 2'を使用する
$groups = $q->from('Group g')->where('g.id IN (1,2,3)')->execute();
</code>

