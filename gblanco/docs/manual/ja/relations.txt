++ 序文

Doctrineにおいてすべてのレコードリレーションは{{hasMany}}、{{hasOne}}メソッドが設定されます。Doctrineは一対一の外部キーリレーションからテーブルの自己参照リレーションまでほとんどすべての種類のデータベースのリレーションをサポートします。

カラム定義とは異なり{{hasMany}}と{{hasOne}}メソッドはsetUp()と呼ばれるメソッドの範囲内で設置されます。両方のメソッドは2つの引数を取ります: 最初の引数はクラスの名前とオプションのエイリアスを含む文字列で、2番目の引数はリレーションのオプションで構成される配列です。オプションの配列は次のキーを含みます:

* **local**、リレーションのローカルフィールドです。ローカルフィールドはクラスの定義で一つもしくは複数のリンクされたフィールドです。
* **foreign**、リレーションの外部フィールドです。外部フィールドはリンクされたクラスで一つもしくは複数のリンクされたフィールドです。
* **refClass**、reference / joinクラスの名前。これは多対多の関連性に対して必要です。
* **onDelete**、onDelete統合アクション。
* **onUpdate**、onUpdate統合アクション。

最初の例を取り上げると、Forum_BoardクラスとForum_Threadクラスがあります。ここではForum_Boardは多くのForum_Threadsを持つので、それらのリレーションは一対多です。リレーションにアクセスをしてForum_を書き込みしたくないので、リレーションエイリアスとThreadsエイリアスを使用します。

最初にForum_Boardクラスを見てみましょう。3つのカラムがあります: name, description and since we didn't specify any primary key, Doctrineはそれに対してidカラムを自動作成します。

hasMany()メソッドを使用してForum_Threadクラスへのリレーションを定義します。ここではlocalフィールドはboardクラスの主キーに対してforeginフィールドがForum_Threadクラスのboard_idです。

<code type="php">
class Forum_Board extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 100);
        $this->hasColumn('description', 'string', 5000);
    }
    public function setUp()
    {
        // ここの'as'キーワードに注意
        $this->hasMany('Forum_Thread as Threads', array('local' => 'id',
                                                        'foreign' => 'board_id');
    }
}
</code>

Forum_Threadクラスをそっと覗いてみましょう。ここでのカラムは重要ではありませんがリレーションを定義する方法に注意を払って下さい。それぞれのThreadは一つのBoardだけを持つので、hasOne()メソッドを使っています。繰り返してエイリアスを使う方法と外部カラムがidカラムである一方でlocalカラムがboard_idであることに注目して下さい。

<code type="php">
class Forum_Thread extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('board_id', 'integer', 10);
        $this->hasColumn('title', 'string', 200);
        $this->hasColumn('updated', 'integer', 10);
        $this->hasColumn('closed', 'integer', 1);
    }
    public function setUp() 
    {
        // ここの'as'キーワードに注意する
        $this->hasOne('Forum_Board as Board', array('local' => 'board_id',
                                                    'foreign' => 'id');
    }
}
</code>

これらのクラスを始めます。プロパティに対して既に使用されている同じアクセサはリレーションに対してすべて利用可能です。

<code type="php">
// 最初boardを作成する
$board = new Forum_Board();
$board->name = 'Some board';

// 新しいthreadを作成する
$board->Thread[0]->title = 'new thread';

// 変更を保存する
$board->save();
</code>

++ 外部キーのアソシエーション
+++ 一対一

一対一のリレーションはおそらくもっとも基本的なリレーションです。次の例において、2つのクラス、UserとEmailがあり、それぞれのリレーションは一対一です。

最初にEmailクラスを見てみましょう。一対一のリレーションをバインディングしているのでhasOne()メソッドを使っています。Emailクラスの外部キーカラムの定義方法を注目して下さい。これはEmailクラスはUserクラスによって所有されていて逆はないからです。実際この慣習に従うべきです - 外部キーを所有されたクラスに常に設置します。

外部キーに対する推奨された命名規約は: [tableName]_[primaryKey]です。 ここでは外部テーブルが'user'で主キーは'id'なので外部キーカラムを'user_id'と命名しました。

<code type="php">
class Email extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('user_id', 'integer');
        $this->hasColumn('address', 'string', 150);
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id', 'foreign' => 'id'));
    }
}
</code>

UserクラスはEmailクラスとよく似ています。Emailクラスの定義と比較してローカルカラムと外部カラムがhasOne()定義で切り替えられる方法に注目して下さい。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string',50);
        $this->hasColumn('loginname', 'string',20);
        $this->hasColumn('password', 'string',16);
    }
    public function setUp()
    {
        $this->hasOne('Email', array('local' => 'id', 'foreign' => 'user_id'));
    }
}
</code>


+++ 一対多、多対一

一対多リレーションと多対一リレーションは一対一リレーションとよく似ています。以前の章で慣れた推奨慣習は一対多リレーションと多対一リレーションにも適用されます。

次の例において2つのクラス: UserとPhonenumberがあります。それらのリレーションを一対多として定義します(一人のユーザーは多くの電話番号を持ちます)。ここで再びPhonenumberは明確にUserによって所有されるので外部キーをPhonenumberクラスに設置します。

<code type="php">
class User extends Doctrine_Record 
{
    public function setUp()
    {
        $this->hasMany('Phonenumber', array('local' => 'id', 'foreign' => 'user_id'));
    }
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 50);
        $this->hasColumn('loginname', 'string', 20);
        $this->hasColumn('password', 'string', 16);
    }
}
class Phonenumber extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('phonenumber', 'string', 50);
        $this->hasColumn('user_id', 'integer');
    }
}
</code>


+++ ツリー構造

ツリー構造は自己参照外部キーのリレーションです。次の定義は階層データの概念(hierarchical data concepts)の観点から隣接リストの実装(Adjacency List 

しかしながらこれは主に単に自己参照が行われる方法の例として提供されています。上記の定義は階層データを表現するよい方法にはめったになりません。効率的な親子リレーションをセットアップする方法に関しては[doc hierarchical-data :index :name]の章をご覧下さい。

<code type="php">
class Task extends Doctrine_Record 
{
     public function setUp() 
     {
        $this->hasOne('Task as Parent', array('local' => 'parent_id', 'foreign' => 'id'));
        $this->hasMany('Task as Subtask', array('local' => 'id', 'foreign' => 'parent_id'));
    }
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 100);
        $this->hasColumn('parent_id', 'integer');
    }
}
</code>

++ テーブルのアソシエーションをJoinする

+++ 多対多

リレーショナルデータベースの背景知識があるのならどのように多対多の関連性を取り扱うのか慣れ親しんでいるかもしれません: 追加の関連テーブルが必要です。

多対多のリレーションにおいて2つのコンポーネント間のリレーションは常に集約リレーションで関連テーブルは両方のendsによって所有されます。例えば、ユーザーとグループの場合: ユーザーが削除されているとき、ユーザーが所属するグループは削除されません。しかしながら、このユーザーとユーザーが所属するグループのアソシエーションは代わりに削除されます。これはユーザーとユーザーが所属したグループ間のリレーションを削除しますが、ユーザーもグループも削除しません。

ユーザー/グループが削除されるときに関連テーブルの列が削除されたくないことがあります。リレーションを関連コンポーネント(この場合は{{Groupuser}})に設明示的に定することでこの振る舞いをオーバーライドできます。

次の例においてリレーションが多対多であるGroupsとUsersがあります。この場合{{Groupuser}}という追加のクラスを定義する必要もあります。

<code type="php">
class User extends Doctrine_Record 
{
    public function setUp() 
    {
        $this->hasMany('Group', array('local' => 'user_id',    // <- these are the column names
                                      'foreign' => 'group_id', // <- in the association table
            // 次の行は多対多のリレーションにおいて必要です!
                                      'refClass' => 'GroupUser'));

    }
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
    }
}

class Group extends Doctrine_Record
{
    public function setUp() {
        $this->hasMany('User', array('local' => 'group_id',  // <- these are the column names
                                     'foreign' => 'user_id', // <- in the association table
            // 次の行は多対多のリレーションで必要です!
                                     'refClass' => 'GroupUser'));
    }
    public function setTableDefinition() {
        $this->hasColumn('name', 'string', 30);
    }
}

class GroupUser extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('user_id', 'integer', null, array('primary' => true));
        $this->hasColumn('group_id', 'integer', null, array('primary' => true));
    }
}


$user = new User();

// 2つのグループを追加する
$user->Group[0]->name = 'First Group';

$user->Group[1]->name = 'Second Group';

// 変更をデータベースに保存する
$user->save();

// ユーザーとユーザーが所属するグループのアソシエーションを削除する

$user->Groupuser->delete();

$groups = new Doctrine_Collection($conn->getTable('Group'));

$groups[0]->name = 'Third Group';

$groups[1]->name = 'Fourth Group';

$user->Group[2] = $groups[0];
// $user will now have 3 groups

$user->Group = $groups;
// $userはこれで'Third Group'と'Fourth Group'を持つ

</code>


+++ 自己参照(入れ子リレーション)
++++ 等しくない入れ子リレーション
<code type="php">
class User extends Doctrine_Record 
{
    public function setUp() 
    {
        $this->hasMany('User as Parents', array('local'    => 'parent_id',
                                                'foreign'  => 'child_id',
                                                'refClass' => 'UserReference'
                                                );

        $this->hasMany('User as Children', array('local'    => 'child_id',
                                                 'foreign'  => 'parent_id',
                                                 'refClass' => 'UserReference'
                                                 );

    }
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
    }
}
class UserReference extends Doctrine_Record 
{
    public function setTableDefinition() {
        $this->hasColumn('parent_id', 'integer', null, array('primary' => true));
        $this->hasColumn('child_id', 'integer', null, array('primary' => true));
    }
}
</code>
++++ 等しい入れ子リレーション

等しい入れ子リレーションは参照クラスが等しい範囲内でクラスが自身とカラムに参照するリレーションを表現するために最適です。

関連レコードを取得するとき参照クラスにおいて参照クラスにおけるカラムがメインクラスの主キーの値を持つことは問題にならないことを意味します。

以前の句は理解するのが難しいかもしれませんので例を考えてみましょう。多くの友人を持つuserというクラスを定義します。'equal'オプションをどのように使っているのかに注目して下さい。

<code type="php">
class User extends Doctrine_Record 
{
    public function setUp() 
    {
        $this->hasMany('User as Friend', array('local'    => 'user1',
                                               'foreign'  => 'user2',
                                               'refClass' => 'UserReference',
                                               'equal'    => true,
                                                );
    }
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
    }
}
class UserReference extends Doctrine_Record 
{
    public function setTableDefinition() {
        $this->hasColumn('user1', 'integer', null, array('primary' => true));
        $this->hasColumn('user2', 'integer', null, array('primary' => true));
    }
}
</code>

では4人のユーザー: Jack Daniels、John Brandy、Mikko KoskenkorvaとStefan Beer を定義しましょう。Jack DanielsとJohn Brandyは友達で、 Mikko Koskenkorvaはみんなの友達です。

<code type="php">
$daniels = new User();
$daniels->name = 'Jack Daniels';

$brandy = new User();
$brandy->name = 'John Brandy';

$koskenkorva = new User();
$koskenkorva->name = 'Mikko Koskenkorva';

$beer = new Stefan();
$beer->name = 'Stefan Beer';

$daniels->Friend[0] = $brandy;

$koskenkorva->Friend[0] = $daniels;
$koskenkorva->Friend[1] = $brandy;
$koskenkorva->Friend[2] = $beer;

$conn->flush();
</code>

例えばJohn Beerの友達にアクセスをすると一人のユーザーである'Mikko Koskenkorva'が返されます。


++ 継承

Doctrineは4つのタイプの継承戦略(Simple、Class、Concrete、Column aggregation)をサポートします。それぞれの戦略は共に混在できます。

+++ Simple継承

Simple継承はもっともシンプルな継承です。Simple継承においてすべての子クラスは同じカラムを親として共有します。

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);
    }
}

class User extends Entity 
{ }

class Group extends Entity 
{ }
</code>

+++ クラステーブル継承

クラステーブル継承は基本的な継承タイプですが、内部ではもっとも複雑なものです。クラステーブル継承によって子クラスは親クラスと比較される追加クラスを持つことができます。

内部では親クラスと子クラスは個別のテーブルに保存され、親と子はそれぞれ区別のつくカラムと共有された主キーカラムのみを持ちます。

次のクラス定義を考えて下さい。

<code type="php">
class Entity extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 100);
    }
}

class User extends Entity
{
    public function setTableDefinition()
    {
        $this->hasColumn('age', 'integer', 2);
        $this->hasColumn('password', 'string', 16);
    }
}
</code>

'User'クラスがmysqlデータベースにエクスポートされているときDoctrineは次のクエリを発行します:

<code>
CREATE TABLE entity (id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100), PRIMARY KEY(id))
CREATE TABLE user (id INT NOT NULL, age INT, password VARCHAR(16), PRIMARY KEY(id))
</code>

親クラスはオートインクリメントのidカラムのみを持つことに注意して下さい。手記キーが全体の継承ツリーに対して設定されていない場合これはDoctrineが使用するデフォルトの戦略です。主キーを手動で設定するとき継承ツリーのすべてのクラスは、オートインクリメント/連番の主キーを除いて、同じ主キー定義を共有します。クラステーブルの継承においてツリーのrootだけがオートインクリメント/連番の主キーを含むことができます。

クラステーブルの継承を使用するクラスからDQLデータを取得するときは、Doctrineは必要なjoinを生成するぐらい賢いです。Aの文字で始まるユーザー名をすべて取得したい場合を考えてみます。 

<code type="php">
$q = new Doctrine_Query();

$users = $q->from('User u')->where("u.name LIKE 'A%'")->execute();
</code>

これでDoctrineは次のクエリを実行します:

<code>
SELECT ... FROM user u LEFT JOIN entity e ON u.id = e.id WHERE u.name LIKE 'A%'
</code>

Doctrineは他のオペレーションを複数のテーブルオペレーションとして実行する方法も知っています。上で見たように新しいユーザーを作成して伝えることで2つのINSERT命令文を実際に実行します。Doctrineがユーザーレコードに対して新しく作成されたエントリーidを添付する方法に注目して下さい。

<code type="php">
$user = new User();
$user->age = 13;
$user->password = 'secret';
$user->name = 'someone';

$user->save();
</code>

次のコードを実行します:
<code>
INSERT INTO entity (name) VALUES ('someone')
INSERT INTO user (id, age, password) VALUES (1, 13, 'secret')
</code>

複数のテーブルにまたがる更新と削除も実行されます。次の例を考えて下さい:

<code type="php">
$user->age = 14;
$user->password = 'newpassword';
$user->name = 'newname';

$user->save();

$user->delete();
</code>

この例は次の命令文を実行します:
<code>
UPDATE entity SET name = 'newname' WHERE id = 1
UPDATE user SET age = 14, password = 'newpassword' WHERE id = 1

DELETE FROM entity WHERE id = 1
DELETE FROM user WHERE id = 1
</code>




+++ Concrete継承

Concrete継承は子クラスに対して個別のテーブルを作るという面ではclass table継承と似ています。しかしながらconcrete継承においてそれぞれのクラスは(継承されたカラムも含めて)すべてのカラムを含むテーブルを生成します。デフォルトのclass table継承の代わりにconcrete継承を使用するために明確な 子クラスへのparent::setTableDefinition()コールが必要です。

<code type="php">
class TextItem extends Doctrine_Record
{
    public function setTableDefinition() 
    {
        $this->hasColumn('topic', 'string', 100);
    }
}

class Comment extends TextItem
{
    public function setTableDefinition() 
    {
        parent::setTableDefinition();    

        $this->hasColumn('content', 'string', 300);
    }
}
</code>


concrete継承において追加カラムを定義する必要はありませんが、Doctrineにそれぞれのクラスに対して個別のテーブルを作成させるために反復のsetTableDefinition()コールを作成しなければなりません。

次の例において{{entity}}、{{user}}と{{group}}という名前の3つのデータベーステーブルを持ちます。私達がすべき唯一のことは3つのクラス({{Entity}}、{{Group}}と{{User}})を書き反復的な{{setTableDefinition}}メソッドコールを作成することです。

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);
    }
}

class User extends Entity 
{
    public function setTableDefinition() 
    {
        // 一テーブル一クラス継承で
        // 次のメソッドコールが必要です
        parent::setTableDefinition();
    }
}

class Group extends Entity 
{
    public function setTableDefinition() 
    {
        // 一テーブル一クラス継承で
        // 次のメソッドコールが必要です
        parent::setTableDefinition();
    }
}
</code>

concrete継承でスキーマ定義を重複して作成するとしても多くの場合でclass table継承よりも遙かに優れた継承戦略です。concreate継承においてすべてのオペレーションが単独の命令文によって起動するのに対して、classテーブル継承において深さNの継承ツリーはSELECTに対してN回のjoinを使用しそれぞれの操作オペレーションに対してN回の命令文を実行します。


+++ カラム集約継承

次の例において{{entity}}という名前の一つのデータベーステーブルを所有します。ユーザーとグループは両方ともエンティティで同じデータベーステーブルを共有します。

エンティティテーブルは{{type}}という名前の一つのカラムを所有します。このカラムはエンティティがグループかユーザーかを伝えます。それで私達はユーザーは1タイプでグループは2タイプと決定します。

私達がしなければならないことは(以前と同じ)3つのレコードを作成し親クラスから{{Doctrine_Table::setSubclasses()}}メソッドのコールを追加することです。

<code type="php">
class Entity extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        $this->hasColumn('name', 'string', 30);
        $this->hasColumn('username', 'string', 20);
        $this->hasColumn('password', 'string', 16);
        $this->hasColumn('created', 'integer', 11);

        // column aggregation継承に対して
        // このカラムは使用されます
        $this->hasColumn('type', 'integer', 11);
        $this->setSubclasses(array(
            'User'  => array('type' => 1),
            'Group' => array('type' => 2)
        ));
    }
}

class User extends Entity {}
class Group extends Entity {}

</code>

この機能によって{{Entity}}テーブルにクエリを行い、返されたオブジェクトが親クラスで設定された制約にマッチする場合{{User}}もしくは{{Group}}オブジェクトを得ることができるようにもなります。この例に対する下記のコード例をご覧下さい。

<code type="php">
$user = new User();
$user->name = 'Bjarte S. Karlsen';
$user->username = 'meus';
$user->password = 'rat';
$user->save();

$group = new Group();
$group->name = 'Users';
$group->username = 'users';
$group->password = 'password';
$group->save();

$q = new Doctrine_Query();
$user = $q->from('Entity')->where('id = ?')->fetchOne(array($user->id));
assert($user instanceOf User);

$q = new Doctrine_Query();
$group = $q->from('Entity')->where('id = ?')->fetchOne(array($group->id));
assert($group instanceOf Group);
</code>

++ 外部キー制約
+++ 導入

外部キー制約はカラム(もしくはカラムのグループ)の値が他のテーブルのいくつかの列で現れなければならない値にマッチしなければならないことを指定します。言い換えると外部キー制約は2つの関連したテーブル間の参照整合性を維持します。

次の定義を持ったproductテーブルを持つことを考えてみましょう:

<code type="php">
class Product extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', null, 'primary');
        $this->hasColumn('name', 'string');
        $this->hasColumn('price', 'decimal', 18);
    }
}
</code>

これらの製品の発注を保存するテーブルを所有することも前提としましょう。順番テーブルが実際に存在する製品の発注のみを含まれることを望むとします。そのために製品テーブルを参照する発注テーブルで外部キー制約を定義します:

<code type="php">
class Order extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('order_id', 'integer', null, 'primary');
        $this->hasColumn('product_id', 'integer');
        $this->hasColumn('quantity', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('Product', array('local' => 'product_id', 'foreign' => 'id'));

        // 外部キーカラムは*常に*インデックスを所有すべきです

        $this->index('product_id', array('fields' => 'product_id'));
    }
}
</code>

{{Order}}クラスがエクスポートされるとき would execute the following SQL:

<code type="sql">
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_id integer REFERENCES products (id),
    quantity integer,
    INDEX product_id_idx (product_id)
)
</code>

現在製品テーブルに表示されないproduct_noエントリを持った発注を作成することは不可能です。

発注テーブルは参照しているテーブルで製品テーブルは参照されたテーブルであるというこの状況においてこのことが言えます。同じように参照しているもしくは参照されたカラムが存在します。


+++ 統合アクション

//CASCADE//:
親テーブルから列を削除もしくは更新して子テーブルでマッチする列を自動的に削除もしくは更新します。ON DELETE CASCADEとON UPDATE CASCADEの両方がサポートされています。2つのテーブル間で、親テーブルもしくは子テーブルで同じカラム上で振る舞ういくつかのON UPDATE CASCADE句を定義すべてきではありません。

//SET NULL// :
親テーブルから列を削除もしくは更新し子テーブルの外部キーカラムもしくはカラムをNULLに設定します。外部キーカラムがNOT NULLqualifierが指定されている場合のみ有効です。ON DELETE SET NULLとON UPDATE SET NULL句の両方がサポートされています。

//NO ACTION// :
標準的なSQLにおいて、NO ACTIONは参照されたテーブルで関連外部キーの値が存在する場合主キーの値を削除もしくは更新しようとすることは許可されないという点においてアクションが行われないことを意味します。 

//RESTRICT// :
親テーブルに対して削除もしくは更新オペレーションを拒絶します。ON DELETEもしくはON UPDATE句を省略するということに関してNO ACTIONとRESTRICTは同じです。

//SET DEFAULT// :

次の例において2つのクラス、UserとPhonenumberを定義します。それらのクラスは一対多の関係になります。onDeleteカスケードアクションを持った一つの外部キー制約も追加します。ユーザーが削除されるたびに関連した電話番号も削除されます。

<code type="php">
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 50);
        $this->hasColumn('loginname', 'string', 20);
        $this->hasColumn('password', 'string', 16);
    }
    public function setUp()
    {
        $this->index('id', array('fields' => 'id'));

        $this->hasMany('Phonenumber', array('local' => 'id', 
                                            'foreign' => 'user_id'));
    }
}
class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('phonenumber', 'string', 50);
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->index('product_id', array('fields' => 'user_id'));

        $this->hasOne('User', array('local' => 'user_id',
                                    'foreign' => 'id',
                                    'onDelete' => 'CASCADE'));
    }
}
</code>
