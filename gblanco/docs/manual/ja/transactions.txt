++ 序文
データベーストランザクションはデータベース管理システムもしくは理路整然として信頼のある方法で取り扱われ、完全に完了するか、中断(アボート)のどちらかにならなければならない他のトランザクションから独立している同様のシステムとのインタラクションの構成単位です。理想的には、データベースシステムはそれぞれのトランザクションに対してすべてのACID (Atomicity, Consistency, Isolation, and Durability アトミック性、一貫性、独立性、永続性)プロパティを保証します。

* [http://en.wikipedia.org/wiki/Atomic_operation Atomicity](アトミック性)はトランザクションのすべてが実行されたかもしくはまったく実行されなかったこを保証するDBMSの能力を言及します。資金の転送は完了したか、複数の理由から失敗することがありますが、アトミック性は一つのアカウントがお金を貸していない場合もう一つのアカウントが借金をしていないことを保証します。
* [http://en.wikipedia.org/wiki/Database_consistency Consistency](一貫性)はトランザクションの始まりと終わりにデータベースが正しい状態にあることを言及します。トランザクションはルールもしくはデータベースの//整合性制約//を壊すことができないことを意味します。整合性制約がすべてのアカウントがプラス残高でなければならないことを述べる場合、このルールを違反するいかなるトランザクションは中断になります。
* [http://en.wikipedia.org/wiki/Isolation_%28computer_science%29 Isolation](独立性)はトランザクションにおけるオペレーションをすべての他のオペレーションから独立させるアプリケーションの能力を言及しています。トランザクション外部のオペレーションは中間状態のデータを決して見ることができないことを意味します; 銀行のマネージャーは一つのアカウントもしくは別のアカウントに転送された資金を見ることができますが、両方ではできません - 転送がまだ処理されている間彼女がクエリーを実行できたとしてもです。さらに正しく説明するなら、独立性はトランザクションの履歴(もしくは [http://en.wikipedia.org/wiki/Schedule_%28computer_science%29 スケジュール])が[http://en.wikipedia.org/wiki/Serializability serializable]であることを意味します。 パフォーマンスの理由のため、この能力は多くの場合緩やかな制約です。詳細に関しては [http://en.wikipedia.org/wiki/Isolation_%28computer_science%29 isolation]の記事をご覧下さい。
* [http://en.wikipedia.org/wiki/Durability_%28computer_science%29 Durability](永続性)は一旦ユーザーが成功したことが通知されると、トランザクションは持続し、行われないことがないことが保証されることを言及しています。これはシステム障害を切り抜け、 and that the [http://en.wikipedia.org/wiki/Database_system database system]が整合性制約を確認してトランザクションをアボートする必要がないことを意味します。通常は、すべてのトランザクションは失敗する直前の状態のシステムを再現できる [http://en.wikipedia.org/wiki/Database_log ログ]に書き込まれます。トランザクションはログで安全になった後だけコミットできます。

- //from [http://www.wikipedia.org wikipedia]//

Doctrineにおいてすべてのオペレーションはデフォルトでトランザクションに包まれます。Doctrineを内部で動作させる方法に関して注意すべきことがいくつかがあります:

* Doctrineはアプリケーションレベルのトランザクションネスティングを使用します。
* Doctrineはトランザクションの終了時(最外部のコミットが呼び出されたとき)に常に{{INSERT}} / {{UPDATE}} / {{DELETE}}クエリーを実行します。オペレーションは次の順番で実行されます: すべてのinsert、すべてのupdateと最後のdeleteで。Doctrineは同じコンポーネントのdeleteオペレーションが一つのクエリーに集約できるように削除を最適化する方法を知っています。

<code type="php">
$conn->beginTransaction();

$user = new User();
$user->name = 'New user';
$user->save();

$user = $conn->getTable('User')->find(5);
$user->name = 'Modified user';
$user->save();

$conn->commit(); // ここですべてのクエリーが実行される
</code>


++ 作業の単位
<code type="php">
$conn->beginTransaction();

$user = new User();
$user->name = 'New user';
$user->save();

$user = $conn->getTable('User')->find(5);
$user->name = 'Modified user';
$user->save();


$pending = $conn->getInserts(); // 一つの要素を含む配列

$pending = $conn->getUpdates(); // 一つの要素を含む配列

$conn->commit(); // ここですべてのクエリーが実行される
</code>


++ 入れ子にする
<code type="php">
function saveUserAndGroup(Doctrine_Connection $conn, User $user, Group $group) {
    $conn->beginTransaction();
    
    $user->save();

    $group->save();

    $conn->commit();
}

try {
    $conn->beginTransaction();

    saveUserAndGroup($conn,$user,$group);
    saveUserAndGroup($conn,$user2,$group2);
    saveUserAndGroup($conn,$user3,$group3);

    $conn->commit();
} catch(Doctrine_Exception $e) {
    $conn->rollback();
}
</code>


++ セーブポイント
Doctrineはトランザクションのセーブポイントをサポートします。名前付きのトランザクションを設定してそれらを入れ子にできることを意味します。

{{Doctrine_Transaction::beginTransaction($savepoint)}}は名前付きのトランザクションセーブポイントを{{$savepoint}}で設定します。現在のトランザクションが同じ名前のセーブポイントを一つ持つ場合、古いセーブポイントは削除され新しいものが設定されます。

<code type="php">
try {
    $conn->beginTransaction();
    // ここでいくつかのオペレーションを行う

    // mysavepointという名前の新しいセーブポイントを作成する
    $conn->beginTransaction('mysavepoint');
    try {
        // ここでいくつかのオペレーションを行う

        $conn->commit('mysavepoint');
    } catch(Exception $e) {
        $conn->rollback('mysavepoint');
    }
    $conn->commit();
} catch(Exception $e) {
    $conn->rollback();
}
</code>

{{Doctrine_Transaction::rollback($savepoint)}}は名前付きのセーブポイントにロールバックします。セーブポイントが設定された後に列に対して現在のトランザクションが行った修正はロールバックでは行われません。

注: 例えば、Mysqlはセーブポイントの後でメモリーに保存された列ロックを開放しません。

名前付きのセーブポイントよりもしばらく後に設定されたセーブポイントは削除されます。

{{Doctrine_Transaction::commit($savepoint)}}は現在のトランザクションのセーブポイントのセットから名前付きのセーブポイントを除去します。

コミットを実行する、もしくはセーブポイントパラメータ無しでロールバックが呼び出される場合、現在のトランザクションのすべてのセーブポイントは削除されます。

<code type="php">
try {
    $conn->beginTransaction();
    // ここでいくつかのオペレーションを行う

    // mysavepointという名前の新しいセーブポイントを作成する
    $conn->beginTransaction('mysavepoint');
    
    // ここで同じオペレーションを行う

    $conn->commit();   // すべてのセーブポイントを削除する
} catch(Exception $e) {
    $conn->rollback(); // すべてのセーブポイントを削除する
}
</code>



++ ロッキング戦略
+++ 悲観的ロッキング
+++ 楽観的ロッキング

++ ロックモード
++ 独立性のレベル
トランザクションの独立性のレベル(isolation level)はデフォルトのトランザクションの振る舞いを設定します。'isolation level'が示す名前に関しては、設定はそれぞれのトランザクションがどのように独立しているのか、もしくはトランザクション内部でクエリーと関連付けされたロックの種類は何であるのかを決定します。4つのレベルは以下の通りです(厳密性の低い順):

: {{READ UNCOMMITTED}} :  かろうじてトランザクションで、これはいわゆる'dirty reads'を許可します。一つのトランザクション内部のクエリーは他のトランザクションのコミットされていない変更によって影響を受けます。

: {{READ COMMITTED}} : コミットされた更新は他のトランザクションの範囲内で見えます。トランザクションの範囲内のまったく同じのクエリーは異なる結果を返すことになります。いくつかのDBMSでこれがデフォルトのものがあります。

: {{REPEATABLE READ}} : トランザクションの範囲内で、すべての読み込みに一般性があります。これはMySQLのInnoDBエンジンのデフォルトです。

: {{SERIALIZABLE}} : トランザクションが通常の{{SELECT}}クエリーを実行する場合、更新は他のトランザクションで許可されません。

<code type="php">
$tx = $conn->transaction; // transactionモジュールを取得する

// 独立性のレベルをREAD COMMITTEDに設定する
$tx->setIsolation('READ COMMITTED');

// 独立性のレベルをSERIALIZABLEに設定する
$tx->setIsolation('SERIALIZABLE');

// (Mysqlのような)ドライバの中には現在のトランザクションの独立性レベルの取得をサポートするものがある
// 次のように行われる:
$level = $tx->getIsolation();
</code>


++ デッドロック
