++ 動作条件
Doctrineを動作させるにはPHPの5.2.3以降が必要です。外部のライブラリは必要ありません。データベースの関数コールの抽象化のためにDoctrineはデフォルトでwww.php.netにある正式版にPHPにバンドルされているPDOを使用します。Windows用のUniform Serverなど正式版でないパッケージからPHPをインストールした場合、追加の設定を行う必要があるかもしれません。

++ インストール

Doctrineをインストールするのは４つの方法があります。

* SVN (subversion)
* 外部 SVN (SVN externals)
* Pear
* Zipパッケージ

DoctrineをSVN (subversion) 経由でダウンロードすることをおすすめします。この方法が一番更新のやりやすい方法です。あなたのプロジェクトが既にSVNで管理されている場合はSVN externalsを使うべきでしょう。

Doctrineを5分で使いたい方はsandboxパッケージからインストールするのがいいでしょう。

+++ Sandboxパッケージ

Doctrineを使うために全く設定を必要としないパッケージを用意しました。これには全機能を備えたコマンドラインのインターフェースが含まれ、それを使ってスキーマのファイル、migrationのファイル、データベースへの接続、データフィクスチャやその他の機能を操作することができます。sandboxパッケージの詳細は [doc utilities :name] 章のSandboxの節を参照してください。

以下にあるURLにsandboxパッケージを使ってDoctrineを使い始めるチュートリアルがあります。sandboxとこのチュートリアルを使ってDoctrineを５分以内で使えるようになるでしょう。このチュートリアルにはスキーマファイル、データフィクスチャ、UserモデルをDoctrineを使って操作する例があります。シンプルな生成、更新、削除の機能など。

このチュートリアルは http://trac.phpdoctrine.org/wiki/MyFirstProject にあり、sandboxパッケージは http://www.phpdoctrine.org/download からダウンロード可能です。

+++ SVN

Doctrineの導入はとても簡単です。http://svn.phpdoctrine.org/branches/0.10 から最新のDoctrineのリビジョンを入手するだけです。

コマンドラインからDoctrineをチェックアウトするには以下のコマンドを入力してください。

<code type="bash">
svn co http://svn.phpdoctrine.org/branches/0.10 .
</code>

SVNクライアントがない場合、下記のリストから一つ選んで下さい。**チェックアウト**　オプションを見つけて、その中の **パス** や **リポジトリURL** パラメータ内に svn.phpdoctrine.org/branches/0.10 を入力して下さい。Doctrineをチェックアウトするためにユーザー名もしくはパスワードは必要ありません。

* [http://tortoisesvn.tigris.org/ TortoiseSVN]はWindows Explorerに統合されるWindowsアプリケーションです
* [http://www.apple.com/downloads/macosx/development_tools/svnx.html svnx]はMac OS X GUI svnアプリケーションです 
* Eclipseは[http://subclipse.tigris.org/ subeclipse]プラグインを通してSVNと統合します

最新版にするにはDoctrineの入っているディレクトリ内で以下のコマンドを使ってください

<code type="bash">
svn update
</code>

+++ SVN externals

既にSVNでバージョン管理をしているディレクトリの中にDoctrineをインストールする場合、svn externalsを使うべきです。以下の **svn** のコマンドでそれを行います

<code type="bash"> 
svn pe svn:externals /path/to/project
</code>

以下の行をエディタを使って追加して保存します。

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

その後にDoctrineをダウンロードします

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

+++ PEAR

PEARを使ってDoctrineをインストールするには以下のコマンドを使います

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

+++ Zipパッケージ

Doctrineを.zip や.tgz (Linux用)パッケージで http://www.phpdoctrine.org/download からダウンロード可能です。
ただ単にパッケージをプロジェクトディレクトリ内に展開して使います。

Linuxの場合 .tgz パッケージをダウンロードして以下のコマンドで展開してください。

<code type="bash"> 
tar xzf Doctrine-0.10.1.tgz
</code>

++ 新しいプロジェクトを始める

Doctrine_RecordはすべてのDoctrineを使ったプロジェクトの基本コンポーネントになります。少なくともそれぞれのデータベーステーブルに対してDoctrine_Recordが一つあります。Doctrine_Record は [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record pattern] のパターンを継承しています。

Doctrineは常に主キーを持たないテーブルに対して'id'という名前の主キーを追加します。Doctrine_Record を継承してsetTableDefinitionメソッドをhasColumn()で定義してそれらのクラスをエクスポートするだけでデータベースのテーブルが作成されます。

'user'というデータベーステーブルを作成することを考えてみます。カラムはid(primary key)、name、username、passwordとcreatedです。Doctrineが既にインストールされているとして、必要なものは下記の数行です:

User.php :
<code type="php">
class User extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        // set 'user' table columns, note that
        // id column is auto-created as no primary key is specified
        
        $this->hasColumn('name', 'string',30);
        $this->hasColumn('username', 'string',20);
        $this->hasColumn('password', 'string',16);
    }
    
    public function setUp()
    {
        $this->actAs('Timestampable');
    }
}
</code>

この代わりにYAMLスキーマを使ってDoctrineのスキーマ情報を指定することも可能です。以下がDoctrine_Recordから生成するためのuser.ymlの例です

<code type="yml">
---
User:
  actAs: [Timestampable]
  columns:
    name: string(30)
    username: string(20)
    password: string(16)
</code>

以下のコマンドを走らせてyamlからphpこーどを生成することができます

<code type="php">
Doctrine::generateModelsFromYaml('/path/to/user.yml', '/path/to/generate/models);
</code>

パス /path/to/generate/models/ か /path/to/generate/models/generated を見てください。ここにUser.phpとBaseUser.phpがあるはずです。User.phpにこーどを追加することで任意の機能を追加することができます。まだBaseUser.phpにはYAMLスキーマファイルから毎回生成されます。

これでDoctrine_Recordクラスが使えるようになりました、ここからデータベースにエクスポートしたり、テーブルを作成したりできます。上のUserクラスをデータベースにエクスポートするために次のシンプルなビルドスクリプトを使います：

<code type="php">
//Doctrineのベースクラスを読み込む
require_once('path-to-doctrine/lib/Doctrine.php');

//autoloaderの登録
spl_autoload_register(array('Doctrine', 'autoload'));

require_once('User.php');

//接続のセットアップ
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

//クラスのエクスポート
Doctrine::createTablesFromArray(array('User'));
</code>

これで基本的なCRUDオペレーションをサポートするUserモデルが使えるようになりました！

++ 既存のデータベースと連携する

+++ はじめに

DoctrineのようなORMツールを使ってよく起こることはデータベースとコードが肥大/複雑になることです。SQLを直書きするより、よいツールが必要です。

Doctrineは既存のデータベースからDoctrine_Recordクラスの生成をサポートします。ドメインモデルに対してすべてのDoctrine_Recordクラスを一から書く必要はありません。 

+++ 最初のインポートを作成する

'file'という名前の一つのテーブルを持つtestというMySQLのデータベースを考えてみましょう。

fileテーブルは次のSQL命令文で作成されました:

<code type="sql">
CREATE TABLE file (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL,
    name VARCHAR(150),
    size BIGINT,
    modified BIGINT,
    type VARCHAR(10),
    content TEXT,
    path TEXT,
    PRIMARY KEY(id))
</code>

これをDoctrine_Recordクラスに変換することを考えます。これは次のコードを使って簡単にできます：

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));
Doctrine_Manager::connection('mysql://root:dc34@localhost/test');

// インポートメソッドはインポートディレクトの入ったパラメータを１つとります。
//インポートディレクトリには生成されたファイルが保存されます。
Doctrine::generateModelsFromDb('myrecords');
</code>


これでおしまいです！myrecords/generatedディレクトリ以下にでFile.phpという名前のファイルが保存されました。ファイルの内容は以下の通りです:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class BaseFile extends Doctrine_Record
{

  public function setTableDefinition()
  {
    $this->setTableName('file');
    $this->hasColumn('id', 'integer', 4, array('unsigned' => 1, 'values' =>  array(), 'primary' => true, 'notnull' => true, 'autoincrement' => true));
    $this->hasColumn('name', 'string', 150, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('size', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('modified', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('type', 'string', 10, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('content', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('path', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
  }

  public function setUp()
  {
    parent::setUp();
  }

}
</code>

またFile.phpというファイルがmyrecordsディレクトリ内に保存されています。ファイルの内容は以下の通り：


<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class FileTable extends Doctrine_Table
{



}
</code>

ここにカスタムメソッドを追加してDoctrine::getTable('User')を使って呼ぶことができます。

++ テーブルの作成

+++ はじめに

Doctrineはレコードクラスをデータベースにエクスポートすることをサポートします。レコードクラスにある定義からDoctrineがデータベース内にテーブルを作ります。

次の定義を持つUserとPhonenumberという名前のクラスを考えます:

<code type="php">
// file User.php
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
    }
    public function setUp()
    {
        $this->hasMany('Phonenumber', array('local' => 'id',
                                            'foreign' => 'user_id'));
    }
}
// file Phonenumber.php
class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('phonenumber', 'string', 20);
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id',
                                    'foreign' => 'id',
                                    'onDelete' => 'CASCADE'));
    }
}
</code>

これらのクラスは'models/'ディレクトリにあるとします。このディレクトリの中をDoctrineに回遊させて、以下のスクリプトを使って各クラスをデータベース構造に追加します:

<code type="php">

require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

//エクスポートするためにデータベース接続が必要
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

Doctrine::createTablesFromModels('models');
</code>

これはMySQL上で次のクエリーを実行します。

<code type="sql">
CREATE TABLE user (id BIGINT AUTO_INCREMENT, name VARCHAR(20), PRIMARY KEY(id), INDEX(id));
CREATE TABLE phonenumber (id INT AUTO_INCREMENT, phonenumber VARCHAR(20), user_id BIGINT, PRIMARY KEY(id), INDEX(user_id));
ALTER TABLE phonenumber ADD CONSTRAINT FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE;
</code>

以下の点に注意してください:

# 主キーカラムを指定していないのでオートインクリメントの主キーが自動追加されます
# Doctrineはインデックスを参照された関連カラムに自動追加します(これはMySQLが必要とします)

+++ エクスポートクエリーを手に入れる

エクスポートクエリーをすぐに実行するのではなく、クエリーの文字列を入手してそれらをbuild.sqlファイルに保存したい状況があるとします。これは次のように達成できます:

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine_Manager::connection('mgsql://user:pass@localhost/test');

$queries = Doctrine::generateSqlFromModels('models');

echo $queries;
</code>

同じ様にエクスポートを実行するために必要なSQLクエリーの文字を取得したい場合は Doctrine::generateSqlFromModels() を使います。

+++ エクスポートオプション

<code type="php">
// テーブル定義と制約などのすべてをエクスポートする
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

// 制約無しでクラスをエクスポートする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_TABLES ^ 
                                              Doctrine::EXPORT_CONSTRAINTS);

//エクスポートをoffにする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_NONE);

$sql = Doctrine::generateSqlFromModels();
</code>

++ モデルの生成

Doctrineは既存のデータベースやYAMLスキーマファイルからからモデルを生成することができます。既存のデータベースからモデルを生成する方法は [doc getting-started:既存のデータベースと連携する :index :name] の節で紹介しました。

以下がYAMLスキーマファイルからモデルを生成している例です：

schema_files/user.yml ファイルを作り、以下のyamlを記述します
<code type="yaml">
---
User:
  columns:
    username: string(255)
    password: string(255)
</code>

そしてDoctrine_Recordの定義を生成する小さなスクリプトを使います
<code type="php">
require_once('/path/to/Doctrine.php');
spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine::generateModelsFromYaml('/path/to/schema_files/', '/path/to/generate/models');
</code>

そして models/User.php と models/generated/BaseUser.php ファイルが保存されます。User.phpにカスタムコードを入れるためのもので、一度だけ生成されます。そしてBaseUser.phpはgenerateModelsFromYaml() が呼ばれる度に生成されます。

++ 自動的にモデルをロードする

Doctrineには２種類のモデルをロードする方法があります。コンサバティブな(怠けた)ローディングとアグレッシブなローディングです。コンサバティブローディングはPHPファイルを最初は必要としませんが、その代わりクラスの名前にパスの名前をキャッシュしてパスの名前がspl_autoload_register(array('Doctrine', 'autoload'))で登録したDoctrine::autoload() によって使われます。以下が両方のタイプのモデルローディングの例です

+++ コンサバティブ

コンサバティブモデルローディングは公開環境に最適なモデルローディング法です。このやり方ではモデルローディングが実行されたときでは無く、すべてのモデルが何もしなくてもロードされます。

コンサバティブモデルローディングでは一つのファイルに必ず一つだけクラスが入っている必要があり、ファイル名をクラス名と同じにする必要があります。例えば、Userクラスがある場合ファイル名もUser.phpにする必要があります。

以下がコンサバティブローディングを使った基本的なDoctrineの実装です

<code type="php">
//Doctrineベースクラスをロード
require_once('path-to-doctrine/lib/Doctrine.php');

//autoloaderを登録
spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine_Manager::getInstance()->setAttribute('model_loading', 'conservative');
Doctrine::loadModels('/path/to/models'); // これで.phpを指定する必要なし

$user = new User(); // これでDoctrine::autoload()が起動され、ファイルがインクルードされ、Userクラスが扱えるようになります
</code>

+++ アグレッシブ

アグレッシブモデルローディングはデフォルトのローディング法でとてもシンプルです。この方法では.php 拡張子のついたすべてのファイルを探し、見つかった全てのファイルをインクルードします。Doctrineはクラス継承を扱わないため、モデルが別のモデルを継承している場合はうまくモデルをインクルードできないので全ての依存関係を正常に保つのには注意が必要です。

アグレッシブモデルローディングを使うことで、一つのファイル内に複数のクラスを持たせることができ、ファイル名とクラス名を一致させる必要はありません。

アグレッシブモデルローディングの欠点リクエスト毎に全てのphpファイルがインクルードされてしまうことなので、モデルの数が増えてきた場合コンサバティブモデルローディングを使うことをお勧めします。

以下がアグレッシブモデルローディングを使ったDoctrineの実装です

<code type="php">
//ベースDoctrineクラスをインクルード
require_once('path-to-doctrine/lib/Doctrine.php');

//autoloaderの登録
spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine_Manager::getInstance()->setAttribute('model_loading', 'aggressive');
Doctrine::loadModels('/path/to/models'); // This call will not require the found .php files

$user = new User(); // これでDoctrine::autoload()が起動され、ファイルがインクルードされ、Userクラスが扱えるようになります
</code>

++ コマンドラインインターフェース

コマンドラインインターフェースはDoctrineで最もよく使われるタスクをコマンドラインから実行できるようにしたものです。コマンドラインインターフェースについての詳細は [doc utilities:command-line-interface :index :name] の節にあります。

++ 一番最初のプロジェクトのチュートリアル

+++ はじめに

このチュートリアルでは機能満載のPHP Doctrine ORMを使ってあなたの一番最初のプロジェクトを作ってみます。このチュートリアルではすぐに使えるDoctrine sandboxパッケージを使います。またwebブラウザー、PHPとPDO + Sqliteが必要です。

+++ ダウンロード

まず始めるにあたり最新のDoctrine sandboxパッケージをダウンロードします：http://www.phpdoctrine.org/download 次にダウンロードしたファイルを展開すると Doctrine-x.x.x-Sandbox というディレクトリが作られるはずです。このディレクトリにはDoctrineを使ったwebアプリケーションの簡単な例が入っています。

+++ パッケージの中身

ファイルやディレクトリの構造は以下の様になっているはずです
<code>
$ cd Doctrine-0.10.1-Sandbox
$ ls
config.php	doctrine	index.php	migrations	schema
data		doctrine.php	lib		models
</code>

このsandboxは設定をする必要はなく、sqlデータベースで使うことができるようになっています。以下が各ファイルの説明と目的です

* doctrine - コマンドラインインターフェース実行のためのシェルスクリプト。./doctrine で実行してコマンド一覧を見るか、./doctrine help として各コマンドの詳細をみてください
* doctrine.php - Doctrineのコマンドラインインターフェースを実装しているphpスクリプト。上のDoctrineシェルスクリプトでインクルードされる
* index.php - webアプリケーションの為のフロントwebコントローラー
* migrations - migrationクラスの為のフォルダ
* schema - スキーマファイルのフォルダ
* models - モデルファイルのフォルダ
* lib - Doctrineコアライブラリファイルのフォルダ


+++ CLI(クライアントプログラム)の実行

Doctrineのシェルスクリプトをコマンドラインから実行すると以下の様なアウトプットがでるはずです：

<code>
$ ./doctrine 
Doctrine Command Line Interface

./doctrine build-all
./doctrine build-all-load
./doctrine build-all-reload
./doctrine compile
./doctrine create-db
./doctrine create-tables
./doctrine dql
./doctrine drop-db
./doctrine dump-data
./doctrine generate-migration
./doctrine generate-migrations-db
./doctrine generate-migrations-models
./doctrine generate-models-db
./doctrine generate-models-yaml
./doctrine generate-sql
./doctrine generate-yaml-db
./doctrine generate-yaml-models
./doctrine load-data
./doctrine migrate
./doctrine rebuild-db
</code>

+++ スキーマの定義

以下がサンプルyamlスキーマファイルです。yamlファイルは schemas/schema.yml に保存します。このコマンドラインインターフェースはschemasフォルダ内にある全ての *.yml ファイルを探します。


<code type="yaml">
---
User:
  columns:
    id:
      primary: true
      autoincrement: true
      type: integer(4)
    username: string(255)
    password: string(255)
  relations:
    Groups:
      class: Group
      refClass: UserGroup
      foreignAlias: Users

Group:
  tableName: groups
  columns:
    id:
      primary: true
      autoincrement: true
      type: integer(4)
    name: string(255)

UserGroup:
  columns:
    user_id: integer(4)
    group_id: integer(4)
  relations:
    User:
      onDelete: CASCADE
    Group:
      onDelete: CASCADE
</code>

+++ データフィクスチャのテスト

以下がサンプルのデータフィクスチャのファイルになります。このファイルを data/fixtures/data.yml 以下に保存します。コマンドラインインターフェースは data/fixtures にある全ての *.yml ファイルを探します。

<code type="yaml">
---
User:
  zyne:
    username: zYne-
    password: changeme
    Groups: [founder, lead, documentation]
  jwage:
    username: jwage
    password: changeme
    Groups: [lead, documentation]

Group:
  founder:
    name: Founder
  lead:
    name: Lead
  documentation:
    name: Documentation
</code>

+++ 全てのビルド

これでスキーマファイルとデータフィクスチャが用意できたので、全てのビルドを行いモデルを使うことができるようになります。以下のコマンドを実行すると models フォルダにモデルが生成されます。

<code>
$ ./doctrine build-all-reload
build-all-reload - Are you sure you wish to drop your databases? (y/n)
y
build-all-reload - Successfully dropped database for connection "sandbox" at path "/Users/jwage/Sites/doctrine/branches/0.10/tools/sandbox/sandbox.db"
build-all-reload - Generated models successfully from YAML schema
build-all-reload - Successfully created database for connection "sandbox" at path "/Users/jwage/Sites/doctrine/branches/0.10/tools/sandbox/sandbox.db"
build-all-reload - Created tables successfully
build-all-reload - Data was successfully loaded
</code>

models フォルダを見ると modelクラスが生成されているのが確認できるはずです。これで index.php にコードを書いてDoctrineを使ってみることができるようになりました。index.php の中に以下の様なシンプルなテストを書いてみてください。

+++ テストの実行

<code type="php">
$query = new Doctrine_Query();
$query->from('User u, u.Groups g');

$users = $query->execute();

echo '<pre>';
print_r($users->toArray(true));
</code>

print_r() が以下のデータの出力を行うはずです。このデータは data/fixtures の中に置いたyamlファイルから保存されたデータだということが分かるはずです。フィクスチャの中にデータを追加して、build-all-reloadをもう一度走らせデータベースを再初期化することも可能です。


<code>
Array
(
    [0] => Array
        (
            [id] => 1
            [username] => zYne-
            [password] => changeme
            [Groups] => Array
                (
                    [0] => Array
                        (
                            [id] => 1
                            [name] => Founder
                        )

                    [1] => Array
                        (
                            [id] => 2
                            [name] => Lead
                        )

                    [2] => Array
                        (
                            [id] => 3
                            [name] => Documentation
                        )

                )

        )

    [1] => Array
        (
            [id] => 2
            [username] => jwage
            [password] => changeme
            [Groups] => Array
                (
                    [0] => Array
                        (
                            [id] => 2
                            [name] => Lead
                        )

                    [1] => Array
                        (
                            [id] => 3
                            [name] => Documentation
                        )

                )

        )

)
</code>

またdqlコマンドライン機能を使ってDQLクエリをデータベースに対して実行することも可能です。以下の様に使われます。

<code>
jwage:sandbox jwage$ ./doctrine dql "FROM User u, u.Groups g"
dql - executing: "FROM User u, u.Groups g" ()
dql - - 
dql -   id: 1
dql -   username: zYne-
dql -   password: changeme
dql -   Groups: 
dql -     - 
dql -       id: 1
dql -       name: Founder
dql -     - 
dql -       id: 2
dql -       name: Lead
dql -     - 
dql -       id: 3
dql -       name: Documentation
dql - - 
dql -   id: 2
dql -   username: jwage
dql -   password: changeme
dql -   Groups: 
dql -     - 
dql -       id: 2
dql -       name: Lead
dql -     - 
dql -       id: 3
dql -       name: Documentation
</code>

+++ ユーザーCRUD

これでDoctrineを使ってとっても単純なユーザーとパスワードを扱う実装をやってみることができるようになりました。以下のコードをindex.php内に置いてブラウザーから読み込んでください。簡単なアプリケーションが実行できます。

<code type="php">
require_once('config.php');

Doctrine::loadModels('models');

$module = isset($_REQUEST['module']) ? $_REQUEST['module']:'users';
$action = isset($_REQUEST['action']) ? $_REQUEST['action']:'list';

if ($module == 'users') {
    $userId = isset($_REQUEST['id']) && $_REQUEST['id'] > 0 ? $_REQUEST['id']:null;
    $userTable = Doctrine::getTable('User');

    if ($userId === null) {
        $user = new User();
    } else {
        $user = $userTable->find($userId);
    }
    
    switch ($action) {
        case 'edit':
        case 'add':
            echo '<form action="index.php?module=users&action=save" method="POST">
                  <fieldset>
                    <legend>User</legend>
                    <input type="hidden" name="id" value="' . $user->id . '" />
                    <label for="username">Username</label> <input type="text" name="user[username]" value="' . $user->username . '" />
                    <label for="password">Password</label> <input type="text" name="user[password]" value="' . $user->password . '" />
                    <input type="submit" name="save" value="Save" />
                  </fieldset
                  </form>';
            break;
        case 'save':
            $user->merge($_REQUEST['user']);
            $user->save();
        
            header('location: index.php?module=users&action=edit&id=' . $user->id);
            break;
        case 'delete':
            $user->delete();
            
            header('location: index.php?module=users&action=list');
            break;
        default:
            $query = new Doctrine_Query();
            $query->from('User u')
                  ->orderby('u.username');
            
            $users = $query->execute();
            
            echo '<ul>';
            foreach ($users as $user) {
                echo '<li><a href="index.php?module=users&action=edit&id=' . $user->id . '">' . $user->username . '</a> &nbsp; <a href="index.php?module=users&action=delete&id=' . $user->id . '">[X]</a></li>';
            }
            echo '</ul>';
    }

    echo '<ul>
            <li><a href="index.php?module=users&action=add">Add</a></li>
            <li><a href="index.php?module=users&action=list">List</a></li>
          </ul>';
} else {
    throw new Exception('Invalid module');
}
</code>