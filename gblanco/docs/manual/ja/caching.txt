++ 序文
{{Doctrine_Cache}}は直感的で簡単に使えるクエリーキャッシュの解決方法を提供します。これは次の内容を提供します:

* (Memcached、APCとSqliteを含む)複数のキャッシュバックエンドを選択できます
* 微細なチューニングのための高度なオプション。{{Doctrine_Cache}}は微細なチューニングパフォーマンスのために多くのオプションを持ちます。

新しいキャッシュドライバインスタンスを初期化します:

<code type="php">
$cacheDriver = new Doctrine_Cache_Memcache($options);
</code>

++ ドライバ
+++ Memcache
Memcacheドライバはキャッシュレコードをmemcachedサーバーに保存します。Memcachedはハイパフォーマンスで、分散型のメモリーオブジェクトキャッシングシステムです。このバックエンドを利用するために、memcachedデーモンとmemcache PECL拡張機能が必要です。

<code type="php">
// memcacheは複数のサーバーを利用可能
$servers = array('host' => 'localhost',
                 'port' => 11211,
                 'persistent' => true);

$cacheDriver = new Doctrine_Cache_Memcache(array('servers' => $servers,
                                           'compression' => false));
</code>

Memcacheドライバで利用できるオプションは以下の通りです:

||~ オプション ||~ データ型 ||~ デフォルト値 ||~ 説明  ||
|| servers || array  || array(array('host' => 'localhost','port' => 11211, 'persistent' => true)) || memcachedサーバーの配列 ; それぞれのmemcachedサーバーは連想配列で記述されます : 'host' => (string) : memcachedサーバーの名前, 'port' => (int) : memcached サーバーのポート, 'persistent' => (bool) : このmemcachedサーバーに対する持続的な接続を使うかつかないか  ||
|| compression || boolean || false || 直接的な圧縮を使いたい場合はtrue  ||

+++ APC
The Alternative PHP Cache (APC)はPHP用のフリーでオープンなopcodeキャッシュです。キャッシングとPHPの中間コードを最適化するためにフリーでオープンで頑強なフレームワークを提供するために考え出されました。

DoctrineのAPCキャッシュドライバは共有メモリーでキャッシュレコードを保存します。

<code type="php">
$cacheDriver = new Doctrine_Cache_Apc();
</code>


+++ Db

Dbキャッシングバックエンドはキャッシュレコードを与えられたデータベースに保存します。通常は(SQLiteといった)速くてフラットなファイルベースのデータベースが使用されます。

sqliteキャッシュドライバの初期化は以下のように行うことができます:

<code type="php">
$conn  = Doctrine_Manager::connection(new PDO('sqlite::memory:'));

$cacheDriver = new Doctrine_Cache_Sqlite(array('connection' => $conn));
</code>

++ クエリーキャッシュと結果キャッシュ

+++ 導入

DoctrineはDQLのクエリーの最後の結果(データ)と同様に、DQL解析プロセスの結果をキャッシュする方法を提供します。これらの2つのキャッシングメカニズムは多いにパフォーマンスを向上させます。DQLクエリー実行の標準的なワークフローを考えてみましょう:

# 新しいDQLクエリーを初期化する
# DQLクエリーを解析する
# データベース特有のSQLクエリーをビルドする
# SQLクエリーを実行する
# 結果セットをビルドする
# 結果セットを返す

これでこれらのフェーズ、とりわけクエリーをデータベースに送るフェーズ4はとても時間がかかる可能性があります。Doctrineクエリーキャッシュが使用されているとき次のフェーズのみが起こります
:
# 新しいDQLクエリーを初期化する
# SQLクエリーを実行する (キャッシュから取り込まれる)
# 結果セットをビルドする
# 結果セットを返す
DQLクエリーが有効なキャッシュエントリを持つのであればキャッシュされたSQLクエリーは使用され、さもなければフェーズ2-3が普通に実行され、これらのステップはキャッシュに保存されます。
常に新たなクエリーの結果を入手するので、クエリーキャッシュは不利な点がありません。ですので製品環境で常にこの機能を使うべきです。とはいうものの、開発期間でも簡単に使用できます。DQLクエリーを変更して始めて実行するたびにキャッシュは修正され新しいキャッシュエントリーが作成されることをDoctrineが理解するので、キャッシュを無効にする必要もありません。クエリーキャッシュの有効性はプリペアドステートメント(ともかくデフォルトでDoctrineに使用されます)の使い方に多いに依存することは注目に値すべきです。動的なクエリー部分を直接埋め込むべきではなく代わりにプレースホルダーを常に使うべきです。

結果キャッシュを使用するとき事態は好転します。クエリー処理が次のようになります(有効なキャッシュエントリが見つかったことを前提とします):
# 新しいDQLクエリーを初期化する
# 結果セットを返す
ご覧の通り、結果キャッシュはあらかじめ示したクエリーキャッシュを暗示します。
クエリーによって返されたデータがいつでも最新である必要がない場合は結果キャッシュを考えるべきです。

+++ クエリーキャッシュ

++++ クエリキャッシュを使う

Doctrine::ATTR_QUERY_CACHEを使用して接続もしくはマネージャーレベルクエリーキャッシュドライバを設定できます。接続レベルキャッシュドライバはこの接続で実行されるすべてのクエリーは指定されたキャッシュドライバを使用することを意味する一方で、マネージャレベルキャッシュドライバは(接続レベルでオーバーライドされない限り)すべての接続は与えられたキャッシュドライバを使用することを意味します。

マネージャレベルクエリキャッシュドライバを設定する:
<code type="php">
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_QUERY_CACHE, $cacheDriver);
</code>

接続レベルキャッシュドライバを設定する:
<code type="php">
$manager = Doctrine_Manager::getInstance();
$conn    = $manager->openConnection('pgsql://user:pass@localhost/test');

$conn->setAttribute(Doctrine::ATTR_QUERY_CACHE, $cacheDriver);
</code>

++++ きめ細かい調整

前の章でグローバルキャッシング属性を使いました。これらの属性はクエリーレベルでオーバーライドできます。有効なcacheDriverを持つuseQueryCacheを呼び出すことでキャッシュドライバをオーバーライドできます。これはクエリーキャッシュに対して意味をなすことをほとんどありませんが可能です:

<code type="php">
$query = new Doctrine_Query();

$query->useQueryCache(new Doctrine_Cache_Apc());
</code>

+++ 結果キャッシュ

++++ 結果キャッシュを使う

Doctrine::ATTR_RESULT_CACHEを利用して接続もしくはマネージャーレベルの結果キャッシュドライバを設定できます。接続レベルキャッシュドライバはすべてのこの接続で使用されるすべてのクエリーが指定されたキャッシュドライバを使うことを意味し、一方でマネージャレベルキャッシュドライバを設定することは(接続レベルでオーバーライドされない限り)すべての接続が与えられたキャッシュドライバを使うことを意味します。

マネージャレベルキャッシュドライバを設定する:
<code type="php">
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_RESULT_CACHE, $cacheDriver);
</code>

接続レベルキャッシュドライバを設定する:
<code type="php">
$manager = Doctrine_Manager::getInstance();
$conn    = $manager->openConnection('pgsql://user:pass@localhost/test');

$conn->setAttribute(Doctrine::ATTR_RESULT_CACHE, $cacheDriver);
</code>

通常は一定の時間に対してのみキャッシュエントリは有効です。Doctrine::ATTR_RESULT_CACHE_LIFESPANを使用することでキャッシュエントリーが有効な期間がどのくらいなのかグローバル値を設定できます。
<code type="php">
$manager = Doctrine_Manager::getInstance();

// ライフスパンを一時間に設定する(60 秒 * 60 分 = 1 時間 = 3600 秒)
$manager->setAttribute(Doctrine::ATTR_RESULT_CACHE_LIFESPAN, 3600);
</code>
使えるようにキャッシュドライバを設定したのでこれDQLクエリーを作ることができます:
<code type="php">
$query = new Doctrine_Query();

// blogのタイトルとコメントの番号を取得する
$query->select('b.title, COUNT(c.id) count')
      ->from('Blog b')
      ->leftJoin('b.Comments c')
      ->limit(10)
      ->useResultCache(true);
      
$entries = $query->execute();
</code>

++++ きめ細かい調整

前の章でグローバルキャッシング属性を使いました。これらの属性はクエリーレベルでオーバーライドできます。有効なcacheDriverを持ったuseCacheを呼び出すことでキャッシュドライバをオーバーライドできます:

<code type="php">
$query = new Doctrine_Query();

$query->useResultCache(new Doctrine_Cache_Apc());
</code>

setResultCacheLifeSpan()を呼び出すことでライフスパン属性をオーバーライドすることもできます:

<code type="php">
$query = new Doctrine_Query();

// ライフスパンを30分に設定する
$query->setResultCacheLifeSpan(60 * 30);
</code>



