++ 概要
+++ スコープ
+++ ゴール


++ PHPファイルの形式
+++ 一般

PHPコードのみを含むファイルに対して、閉じタグ("{{?>}}")は決して許可されません。PHPで必要ないからです。閉じタグを含まないことで間違って後の空白文字が出力に混入されることを防止します。

重要なこと: {{__HALT_COMPILER()}}によって許可される任意のバイナリコードのインクルージョンはDoctrineフレームワークのPHPファイルもしくはそれらから由来するファイルでは禁止されています。この機能の仕様は特別なインストレーションスクリプトによってのみ許可されます。 


+++ インデンテーション

4つのスペースのインデントを使います。タブは使いません。


+++ 最大行の長さ

ターゲットの行の長さは80文字とします。つまり、実際のところ開発者はコードを前後80カラムに保つべきです。しかしながら、より長い行も受け入れられます。PHPコードの行の最大長は120文字です。 


+++ 行の終わり方

* 行の終わり方はUnixのテキストファイルで標準的な方法です。行はラインフィード(LF)だけで終わらなければなりません。ラインフィードは通常の10、もしくは16進法の0x0Aです。
* Macintoshコンピュータ(0x0D)のようにキャリッジリターン(CR)は使わないでください
* Windowsコンピュータ(0x0D, 0x0A)のようにキャリッジリターン/ラインフィードの組み合わせ(CRLF)を使わないでください


++ 命名規約
++ クラス

* Doctrine ORMフレームワークはPEARとZend frameworkと同じクラスの命名規約を使います。クラスの名前は保存されるディレクトリに直接位置づけられます。Doctrineフレームワークのrootレベルのディレクトリは"Doctrine/"ディレクトリで、その下にすべてのクラスが階層的に保存されます。
* クラス名はアルファベットと数字の文字のみ含むことができます。数字はクラス名に許可されますが非推奨です。アンダースコアはパスのセパレータの位置でのみ許可されます。たとえば"Doctrine/Table/Exception.php"というファイル名は"Doctrine_Table_Exception"のクラス名を指し示さなければなりません。
* クラス名が複数の単語で構成される場合、それぞれの新しい言葉の最初の文字は大文字でなければなりません。連続した大文字は許可されません。たとえば"XML_Reader"クラスは許可されない一方で"Xml_Reader"は受諾できます。


+++ インターフェイス

* インターフェイスクラスは他のクラスと同様に同じ規約に従わなければなりませんが(上記を参照)、"{{Interface}}"の言葉で終わらなければなりません({{Doctrine_Overloadable}}といったものに含むことが認められない限り)。いくつかの例です:
 * {{Doctrine_Db_EventListener_Interface}}   
 * {{Doctrine_EventListener_Interface}}


+++ ファイル名

* すべての他のファイルに対して、アルファベットと数字、アンダースコアとダッシュ("-")の文字のみが許可されます。
スペースは禁止です。
* PHPコードを含むどのファイルも".php"の拡張で終わらなければなりません。次の例は上記のセクションの例からクラス名を含むことに関して受け入れできるファイル名を示しています:
 * {{Doctrine/Db.php}}
 * {{Doctrine/Connection/Transaction.php}} 
* ファイル名は上記で説明されたクラス名へのマッピングに従わなければなりません。


+++ 関数とメソッド

* 関数名はアルファベットと数字のみ含むことができます。アンダースコアは許可されません。数字は関数名で許可されますが非推奨です。
* 関数名は常に小文字で始めなければなりません。関数名が複数の単語で構成されている場合、それぞれの新しい単語の最初の文字は大文字でなければなりません。This is commonly called the "studlyCaps"もしくは"camelCaps"メソッドと呼ばれます。
* 冗長性は推奨されます。関数名は冗長であるほどコードの可読性を高めます。
* オブジェクト指向のプログラミングに関して、オブジェクトに対するアクセサの接頭辞は常に"get"もしくは"set"を持つべきです。接頭辞が'obtain'と'assign'であるメソッドをいくつか持つDoctrine_Record以外のすべてのクラスに対して適用されます。 理由は定義されたActiveRecordsが{{Doctrine_Record}}を継承するので、可能な限り最小限のget/set名前空間を投入するからです。
* グローバルスコープの関数("floating functions")は　許　可　されません。すべてのスタティックな関数はスタティックなクラスにラップされます。


+++ 変数

すべての変数は次の条件を満たさなければなりません:

* 変数名はアルファベットと数字のみが含まれます。アンダースコアは許可されません。数字は変数で許可されていますが非推奨です。
* 変数は常に小文字で始まり"camelCaps"の大文字化の規約に従わなければなりません。
* 冗長性は推奨されます。変数は常に実用的に関して冗長であるべきです。 "$i"と"$n"のような簡潔な変数は最小のループの内容以外は非推奨です。ループが20行以上のコードを含む場合、インデックスに対する変数はより説明的な名前である必要があります。
* フレームワークの範囲内である一般的なオブジェクト変数は常に次のような名前を使います:

||~ オブジェクトの型             ||~ 変数名 ||
||  {{Doctrine_Connection}} ||  {{$conn}}     ||
||  {{Doctrine_Collection}} ||  {{$coll}}     ||
||  {{Doctrine_Manager}}    ||  {{$manager}}  ||
||  {{Doctrine_Query}}      ||  {{$query}}    ||
||  {{Doctrine_Db}}         ||  {{$db}}       ||

* 説明的な名前がより適切である場合(たとえば複数のオブジェクトが同じ内容で使われる場合)、言及されたものとは異なる名前を使うことができます。


+++ 定数

Doctrineフレームワークの範囲内で次のルールはすべての定数に適用すべきです:

* 定数はアルファベットと数字とアンダースコアを含みます。
* 定数は常にすべての文字が大文字でなければなりません。
* 可読性のため、定数名の単語はアンダースコアの文字で分離されなければなりません。たとえば{{ATTR_EXC_LOGGING}}は許可されますが{{ATTR_EXCLOGGING}}は許可されません。
* 定数は"const"コンストラクトを使用してクラスメンバーとして定義されなければなりません。"define"を持つグローバルスコープは　許　可　されません。

<code type="php">
class Doctrine_SomeClass 
{
    const MY_CONSTANT = 'something';
}
print Doctrine_SomeClass::MY_CONSTANT;
</code>

+++ レコードカラム

* すべてのレコードカラムは小文字でなければなりません
* 複数の単語で構成される空無名に対してアンダースコアの使用は推奨されます
<code type="php">
class User
{
    public function setTableDefinition()
    {
        $this->hasColumn('home_address', 'string');
    }
}
</code>
* 外部キーのフィールドは[tablename]_[column]の形式でなければなりません
<code type="php">
class Phonenumber 
{
    public function setTableDefinition()
    {
        // このフィールドはuser(id)を指し示す外部キー
        $this->hasColumn('user_id', 'integer');
    }
}
</code>



++ コーディングスタイル
+++ PHPコードの区分

* PHPコードは常にフルフォーム、PHPタグで区切られなければなりません
* ショートタグは決して許可されません。PHPコードのみのファイルに対して、閉じタグは常に省略されなければなりません


+++ 文字列

* 文字列がリテラルの場合(変数の代入を含まない場合)、文字列であることを示すためにアポストロフィもしくは"シングルクォート"が使われなければなりません:

<code type="php">
// リテラルの文字列
$string = 'something';
</code>

* リテラルの文字列自身がアポストロフィを持つ場合、クォテーションマークもしくは"ダブルクォート"で文字列を区別することが許可されます。これはとりわけSQL命令文に対して推奨されます:

<code type="php">
// 文字列がアポストロフィを含む
$sql = "SELECT id, name FROM people WHERE name = 'Fred' OR name = 'Susan'";
</code>

* 変数の代入は次のような形式で許可されます:

<code type="php">
// 変数の代入
$greeting = "Hello $name, welcome back!";
</code>

* 文字列は"."演算子で連結されます。可読性を向上させるために"."の前後でスペースが常に追加されなければなりません:

<code type="php">
// 連結
$framework = 'Doctrine' . ' ORM ' . 'Framework';
</code>

* "." 演算子で文字列を連結する場合、可読性を向上させるために命令文を複数の行に分割することが許可されます。これらの場合、"."演算子が"="演算子の下に割り当てられるようにそれぞれの連続した行は空白で埋め合わせすべきです:

<code type="php">
// 改行を連結
$sql = "SELECT id, name FROM user "
     . "WHERE name = ? "
     . "ORDER BY name ASC";
</code>


+++ 配列

* インデックスとして負の数は許可されません。
* インデックスのある配列は負ではない数で始まることができますが、これは非推奨ですべての配列は0のインデックスを始まりにすることが推奨されます。
* インデックスを持つ配列をarrayコンストラクトで宣言するとき、可読性を向上させるためにトレーリングスペースはそれぞれのコンマのデリミッタの後に追加されなければなりません。
* "array"コンストラクトを利用して複数行のインデックスを持つ配列を宣言することも許可されます。その場合、それぞれの連続した行はスペースで埋め合わせしなければなりません。
* arrayコンストラクトで連想配列を宣言するとき、命令文を複数行に分割することが推奨されます。その場合、両方のキーと値が並べられるように、それぞれの連続した行を空白で埋め合わせしなければなりません:

<code type="php">
$sampleArray = array('Doctrine', 'ORM', 1, 2, 3);


$sampleArray = array(1, 2, 3, 
                     $a, $b, $c,                     
                     56.44, $d, 500);


$sampleArray = array('first'  => 'firstValue',
                     'second' => 'secondValue');
</code>


+++ クラス

* クラスは次の命名規約で名付けられなければなりません。
* 大括弧は常にクラス名(もしくはinterface宣言)の後の隣の行に書かれます。
* すべてのクラスはPHPDocumentorの基準に従うドキュメンテーションブロックを持たなければなりません。
* クラスの範囲内のコードは4つのスペースで字下げをされなければなりません。
* 一つのPHPファイルごとに一つのクラスのみ許可されます。
* クラスファイルに追加コードを設置することは　許　可　されません。

受け入れられるクラス宣言の例です:

<code type="php">
/**
 * ここにドキュメンテーションブロック
 */
class Doctrine_SampleClass 
{
    // クラスのすべての内容は
    // 4つのスペースで字下げされなければならない
}
</code>


+++ 関数とメソッド

* メソッドは次の命名規約によって命名されなければなりません。
* メソッドは常にprivate、protectedもしくはpublicコンストラクトを使用してそれらの範囲を宣言しなければなりません。
* クラスのように、大括弧はメソッド名の後の次の行に書かれなければなりません。引数に対して関数名と開き丸括弧の間にスペースは存在しません。
* globalスコープの関数は強く非推奨です。
* 受け入れできるクラスの関数宣言の例です:

<code type="php">
/**
 * ここにドキュメンテーションブロック
 */
class Foo 
{
    /**
     * ここにドキュメンテーションブロック
     */
    public function bar() 
    {
        // 関数の内容全体は
        // 4つのスペースで字下げされなければならない
    }
}
</code>

* 参照渡しは関数の宣言でのみ許可されます:

<code type="php">
/** 
 * ここにドキュメンテーションブロック
 */
class Foo 
{
    /**
     * ここにドキュメンテーションブロック
     */
    public function bar(&$baz) 
    {
    }
}
</code>

* 呼び出し時の参照渡し(call-time pass by-reference)は禁止です。
* 返り値は丸括弧で閉じられてはなりません。これによって可読性を阻害しメソッドが後で参照で返すよう変更された場合コードが壊れます。

<code type="php">
/** 
 * ここでドキュメンテーションブロック
 */
class Foo 
{
    /**     
     * 間違い     
     */    
    public function bar() {
        return($this->bar);
    }    
    /**     
     * 正解     
     */    
    public function bar() 
    {
        return $this->bar;
    }
}
</code>

* 関数の引数はコンマの区切りの後で単独のトレーリングスペースによって分割されます。3つの引数を取る関数に対して受け入れできる関数コールの例です:

<code type="php">
threeArguments(1, 2, 3);
</code>

* 呼び出し時の参照渡しは禁止です。上記の参照による関数の引数を渡す方法をご覧ください。
* 配列が許された引数を持つ関数に関して、関数コールは{{array}}コンストラクトを含み可読性を向上させるために複数の行に分割できます。この場合は標準的な配列の書き方が適用されます:

<code type="php">
threeArguments(array(1, 2, 3), 2, 3);

threeArguments(array(1, 2, 3, 'Framework',
                     'Doctrine', 56.44, 500), 2, 3);
</code>


+++ 制御文

* {{if}}と{{elseif}}コンストラクトに基づいた制御命令文は条件の開き丸括弧の前に一つのスペースを、閉じ丸括弧の後に一つのスペースがなければなりません。
* 丸括弧の間の条件命令文の範囲で、演算子は可読性のためにスペースで分割されなければなりません。より大きな条件の論理的なグルーピングを改善するために内部の丸括弧は推奨されます。
* 開き大括弧は条件の命令文に関して同じ行に書かれます。閉じ大括弧は自身の行に常に書かれます。大括弧内の内容は4つのスペースで字下げされなければなりません。

<code type="php">
if ($foo != 2) {
    $foo = 2;
}
</code>

* {{elseif}}もしくは{{else}}を含む{{if}}命令文に関して、形式は次の例のようになります:

<code type="php">
if ($foo != 1) {
    $foo = 1;
} else {   
    $foo = 3;
}
if ($foo != 2) {
    $foo = 2;
} elseif ($foo == 1) {
    $foo = 3;
} else {   
    $foo = 11;
}
</code>

!オペランドが使われるとき、 次の形式を使わなければなりません:

<code type="php">
if ( ! $foo) {

}
</code>

* {{switch}}コンストラクトで書かれた制御命令文は条件文の開き丸括弧の前に一つのスペースと。閉じ丸括弧の後に一つのスペースを持たなければなりません。
* {{switch}}文の範囲内のすべての内容は4つのスペースで字下げされなければなりません。それぞれの{{case}}文の元にある内容は追加の4つのスペースで字下げされなければなりませんが、break文は{{case}}文と同じ字下げレベルでなければなりません。

<code type="php">
switch ($case) {
    case 1:
    case 2:
    break;
    case 3:
    break;
    default:
    break;
}
</code>

* defaultコンストラクトはswitch文から省略されてはなりません。


+++ インラインドキュメンテーション

ドキュメンテーションの形式:

* すべてのドキュメンテーションブロック("docblocks")はphpDocumentor形式と互換性がなければなりません。phpDocumentor形式の説明はこのドキュメントの対象外です。詳細な情報に関しては、次のサイトをご覧ください: http://phpdoc.org/

メソッド:

* すべてのメソッド、は最小の内容を持つdocblockを持たなければなりません: 
 * 関数の説明
 * 引数のすべて
 * 可能な返り値のすべて
* {{@access}}タグを使う必要はありません。accessレベルは関数を制限するために使われる{{public}}、{{private}}もしくは{{protected}}コンストラクトから既にわかっているからです。
* 関数/メソッドが例外をスローを投げるとき、{{@throws}}を使ってください:
 * {{@throws exceptionclass [description]}}



++ テスティング
+++ テストを書く

++++ クラス

* すべてのテストクラスの名前はクラスもしくはあるクラスの特定のテストの状況を参照すべきです。
 * 例えば{{Doctrine_Record_TestCase}}は{{Doctrine_Record}}クラスを参照しているので有効な名前です。
 * {{Doctrine_Record_State_TestCase}}は{{Doctrine_Record}}クラスの状態(state)の状況をテストすることに言及しているので有効な名前です。
 * しかしながら{{Doctrine_PrimaryKey_TestCase}}のような名前は一般的すぎる名前なので有効な名前ではありません。
* すべてのクラスは少なくとも{{TestCase}}と同等のものを持たなければなりません。
* すべてのテストケースクラスは{{Doctrine_UnitTestCase}}を継承すべきです


++++ メソッド

* すべてのメソッドはアジャイルなドキュメントをサポートします; あるメソッドが失敗した場合何が間違っているのか手ｓとメソッドの名前から明白であるべきです。またテストメソッド名はテストするシステムの情報を知らせるものであるべきです。
 * 例えば{{Doctrine_Export_Pgsql_TestCase::testCreateTableSupportsAutoincPks()}}は有効なテストメソッド名です。名前を見るだけで何をテストしているのかわかります。最新のシステム情報を入手するためにアジャイルなドキュメントツールを実行できます。

注:一般的に使われるテスティングメソッドの命名規約である{{TestCase::test[methodName]}}はDoctrineでは許可**されません。**ですのでこの場合{{Doctrine_Export_Pgsql_TestCase::testCreateTable()}}は許可されません！

* テストメソッド名はしばし長いことがあります。しかしながらメソッドの範囲内の内容はかなりたくさんの行の長さんいなることはまれです。いくつかのアサートコール(assert-call)が必要な場合メソッドをいくつかの小さなメソッドに分割してください。

++++ アサーション

* ループの範囲内とまれに関数の範囲内でアサーション(assertion)が存在してはなりません。

