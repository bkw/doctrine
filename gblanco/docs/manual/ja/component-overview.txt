++ レコード
{{Doctrine_Record}}はDoctrineのORMの最も必用不可欠なコンポーネントです。クラスはデータベースの列に対するラッパーですがそれに加えてそれが他のコンポーネント上で持っているリレーションとカラムを指定します。ActiveRecordとして参照されるので関連コンポーネントにアクセスできます。

{{Doctrine_Record}}を継承するクラスはコンポーネントと呼ばれます。それぞれのデータベーステーブルに対して少なくとも一つのコンポーネントが存在すべきです。

新しいレコードを作成する方法は複数あります。おそらくもっとも簡単なのはネイティブのPHPのnew演算子を使用することです。別の方法は {{Doctrine_Table::create()}}もしくは{{Doctrine_Connection::create()}}を呼び出す方法です。最後の2つは後方互換性のために存在します。新しいオブジェクトを作成する方法の中で推奨するものはnew演算子です。

<code type="php">
$user = $conn->create("User");

// 代替の方法:

$table = $conn->getTable("User");

$user = $table->create();

// もっともシンプルな方法:

$user = new User();

// レコードは配列アクセスをサポートする
$user['name'] = 'John Locke';

// ユーザーをデータベースに保存する
$user->save();
</code>

すべてのレコードは内部でユニークな識別子であるオブジェクト識別子を持ちます。which is an internal unique identifier. oid()メソッドでオブジェクト識別子を取得できます。基本的に2つのオブジェクトは同じオブジェクト識別子を共有する場合は同じものとして見なされます。


+++ プロパティ

{{Doctrine_Record}}の割り当てられたそれぞれのカラムプロパティはデータベーステーブルカラムを表します。以前の章で学んだようにカラム定義はhasColumn()メソッドで達成されます。これでカラムにアクセスすることは簡単であることがわかりました。上記で説明したどの方法を使用できます。推奨方法はArrayAccessです。レコードと配列の取得を必要に応じて切り替えることが簡単になるからです。

<code type="php">
$user = $table->find(3);

// オーバーローディングを通してプロパティにアクセスする

$name = $user->name;

// get()でプロパティにアクセスする

$name = $user->get("name");

// ArrayAccessインターフェイスでプロパティにアクセスする

$name = $user['name'];
</code>

レコードのプロパティを通してイテレートすることは - foreachコンストラクトを使用することで- 配列を通してイテレートする方法と似た方法でできます。{{Doctrine_Record}}はマジックのIteratorAggregateインターフェイスを実装するのでこれは可能です。

<code type="php">
foreach ($user as $field => $value) {

}
</code>

配列に関しては与えられたプロパティが存在するか確認するためにisset()関数を、与えられたプロパティをnullに設定するためにunset()関数を使うことができます。

<code type="php">
// 'name'という名前のプロパティが存在するか確認する
if (isset($user['name'])) {

}

// nameプロパティをunsetする
unset($user['name']);
</code>

レコードプロパティに対して設定値がある場合modifiedFields()メソッドで修正されたプロパティの名前を取得できます。この目ｍそっどは修正されたフィールド名の配列を返します。

<code type="php">
$user['name'] = 'Jack Daniels';

$user['age'] = 100;

print_r($user->getModified()); // array('name', 'age');

$user->isModified(); // true
</code>

与えられたレコードのカラムのカウントを取得したい場合を考えます。これを行うためにcount()関数に対してレコードを渡すだけです。これは{{Doctrine_Record}}はマジックのCountableインターフェイスを実装するので可能です。他の方法はcount()メソッドを呼び出すことです。

<code type="php">
// カラムの数を取得する

$colCount = $record->count();

$colCount = count($record);
</code>


{{Doctrine_Record}}は与えられたレコードの識別子にアクセスするために特別なメソッドを提供します。このメソッドはidentifier()と呼ばれ識別子フィールド名をキーとして値を連想プロパティの値として返します。
<code type="php">
$user['name'] = 'Jack Daniels';

$user->save();

$user->identifier(); // array('id' => 1)
</code>

共通の事例は与えられたレコードに割り当てる必要のある値の配列を持つことです。これらの値を個別に設定することは扱いにくいと感じるかもしれませんが心配する必要はありません。{{Doctrine_Record}}は与えられた配列をプロパティの値にマージする方法を提供します。

The merge()メソッドは与えら他レコードのプロパティをイテレートして与えられた配列の値を連想プロパティに割り当てします。

<code type="php">
$values = array('name' => 'someone',
                'age'  => 11,
                'unknownproperty' => '...');

// ここではunknownpropertyは
// その名前を持つカラムを持たないUserクラスとして割り当てされないことに注意する
$user->merge($values);

print $user->name; // someone
print $user->age; // 11

print $user->unknownproperty; // 例外をスローする
</code> 


+++ 存在するレコードを取得する

Doctrineはレコードの取得のために多くの方法を提供します。存在するレコードを取得するためにもっとも速い方法は{{Doctrine_Table}}によって提供されるファインダーメソッドです。もっと複雑なクエリを使う必要がある場合DQLのAPIをご覧下さい。

<code type="php">
$table = $conn->getTable("User");

// 主キーを見つける

$user = $table->find(2);
if($user !== false)
    print $user->name;

// すべてのユーザーを取得する
foreach($table->findAll() as $user) {
    print $user->name;
}

// dqlで見つける
foreach($table->findByDql("name LIKE '%John%'") as $user) {
    print $user->created;
}

// DQLでオブジェクトを見つける

$users = $conn->query("FROM User u WHERE u.name LIKE '%John%'");
</code>




+++ レコードを更新する

オブジェクトの更新はとても簡単で、{{Doctrine_Record::save()}}メソッドを呼び出すだけです。他の方法はすべてのオブジェクトを保存する{{Doctrine_Connection::flush()}}を呼び出すことです。flushingは単にsaveメソッドを呼び出すよりも遙かに重いオペレーションであることに注意すべきです。

<code type="php">
$table = $conn->getTable('User');

$user = $table->find(2);

if($user !== false) {
    $user->name = 'Jack Daniels';
    
    $user->save();
}
</code>

時に直接更新したいことがあります。直接の更新においてオブジェクトはデータベースからロードされず、むしろデータベースの状態は直接更新されます。次の例においてすべてのユーザーを更新するためにDQLのPDATE命令文を使います。


<code type="php">
// すべてのユーザー名を小文字にします
Doctrine_Query::create()->update('User u')
                        ->set('u.name', 'LOWER(u.name)')
                        ->execute();
</code>

+++ レコードをリフレッシュする

データベースからデータを持つレコードをリフレッシュしたい場合、{{Doctrine_Record::refresh()}}を使います。

<code type="php">
$user = $conn->getTable('User')->find(2);
$user->name = 'New name';
// oups, 名前を更新したい
$user->refresh();
</code>

++++ リレーションシップをリフレッシュする

{{Doctrine_Record::refresh()}}メソッドはレコードのリレーションシップもリフレッシュしますがクエリ上でそれらを指定する必要があります。

<code type="php">
$user = Doctrine_Query::create()
    ->from('User u')
    ->leftJoin('u.Groups')
    ->where('id = ?')
    ->fetchOne(array(1));

$group = Doctrine_Query::create()
    ->from('Group g')
    ->leftJoin('g.Users')
    ->where('id = ?')
    ->fetchOne(array(1));

$userGroup = new UserGroup();
$userGroup->user_id = $user->id;
$userGroup->group_id = $group->id;
$userGroup->save();

// ユーザー上の新しいグループを取得する
$user->refresh(true);
// グループ上の新しいユーザーを取得する
$group->refresh(true);
</code>

+++ レコードを削除する

Doctrineでレコードを削除することは{{Doctrine_Record::delete()}}、{{Doctrine_Collection::delete()}}と{{Doctrine_Connection::delete()}}メソッドで取り扱われます。

<code type="php">
$table = $conn->getTable("User");

$user = $table->find(2);

// ユーザーとすべての関連した複合オブジェクトを削除する
if($user !== false)
    $user->delete();


$users = $table->findAll();


// すべてのユーザーと関連した複合オブジェクトを削除する
$users->delete();
</code>

+++ 式の値を使う

カラムの値をSQLの表現で使う必要がある状況を考えます。これはポータブルなDQL表現をネイティブなSQL表現に変換することで達成できます。

timepoint(datetime)とname(string)というカラムを持つeventと言う名前のクラスを考えます。現在のtimepointを持つレコードを保存することは以下のように達成されます:
<code type="php">
$event = new Event();
$event->name = 'Rock festival';
$event->timepoint = new Doctrine_Expression('NOW()');

$event->save();
</code>

最後の行はSQLを実行します(SQLiteにて):
<code>
INSERT INTO event (name, timepoint) VALUES (?, 'NOW()')
</code>

+++ レコードの状態を取得する

{{Every Doctrine_Record}}は状態を持ちます。最初にレコードはtransient(一時的)もしくはpersistent(持続的)になることができます。データベースから取得されたすべてのレコードはpersistentですべての新しく作成されたレコードはtransientです。If a {{Doctrine_Record}}がデータベースから取得されるがロードされたぴｒっぱてぃが主キーである場合、このレコードはproxy(プロクシ)という状態を持ちます。

すべてのtransientでpersistentな{{Doctrine_Record}}はcleanもしくはdirtyです。プロパティがまったく変更されていないときはDoctrine_Record はcleanでプロパティが少なくとも変更されている場合、Doctrine_Record はdirtyであると言います。

レコードにはlockedと呼ばれる状態もあります。無限再帰を避けるためにごくまれな循環参照の事例においてDoctrineはレコードが現在操作オペレーションであることを示すためにこの状態を内部で使用します。

<code type="php">
$state = $record->state();

switch($state):
    case Doctrine_Record::STATE_PROXY:
        // レコードはproxyの状態 
        // persistentであるがデータベースから
        // すべてのプロパティがロードされていないことを意味する
    break;
    case Doctrine_Record::STATE_TCLEAN:
        // レコードがtransientなcleanである
        // transientでプロパティが
        // まったく変更されていないことを意味する
    break;
    case Doctrine_Record::STATE_TDIRTY:
        // レコードがtransientでdirtyである
        // transientでプロパティのいくつかが変更されている
        // ことを意味する
    break;
    case Doctrine_Record::STATE_DIRTY:
        // レコードがdirtyである
        // persistentで
        // プロパティのいくつかが変更されている
    break;
    case Doctrine_Record::STATE_CLEAN:
        // recordがcleanである
        // persistentでプロパティが変更されていない
        // ことを意味する
    break;
    case Doctrine_Record::STATE_LOCKED:
        // レコードがlockedされている
    break;
endswitch;
</code>


+++ オブジェクトコピーを取得する

オブジェクトのコピーをしたい場合を考えます(すべてのプロパティを持つ新しいオブジェクトはコピーされます)。Doctrineはこのためにシンプルな方法を提供します: {{Doctrine_Record::copy()}}です。

<code type="php">
$copy = $user->copy();
</code>

copy()でレコードをコピーすることで古いレコードの値を持った新しいレコード(状態はTDIRTY)が返され、そのレコードのリレーションがコピーされることに注意して下さい。リレーションもコピーしたくない場合、copy(false)を使用する必要があります。

<code type="php">
// リレーション無しのユーザーのコピーを取得する
$copy = $user->copy(false);
</code>

+++ 空白のレコードを保存する

デフォルトでsave()メソッドが修正されていないレコードに呼び出されているときDoctrineはsave()メソッドを実行しません。レコードが修正されていない場合でもレコードを強制insertしたい状況があります。これはレコードの状態をDoctrine_Record::STATE_TDIRTYに割り当てることで達成できます。

<code type="php">
$user = new User();
$user->state('TDIRTY');
$user->save();

$user->id; // 1
</code>

+++ カスタムの値をマッピングする

カスタムの値をレコードに割り当てたい場合を考えます。例えばデータが外部のソースに依存していて持続的ではなく実行時のみにこれらの値を利用可能にしたい場合があります。これは次のように達成されます:

<code type="php">
$user->mapValue('isRegistered', true);

$user->isRegistered; // true
</code>


+++ シリアライズする

レコードオブジェクトをシリアライズしたい場合(おそらくキャッシュのため)を考えます。レコードはシリアライズできますが、覚えておいて下さい: Doctrineはこれを行う前に、すべてのリレーションをクリーンにします。オブジェクトをシリアライズする前にオブジェクトをデータベースに存続させることを覚えていて下さい。

<code type="php">
$string = serialize($user);

$user = unserialize($string);
</code>


+++ 存在を確認する

とてもありふれた状況としてデータベースに与えられたレコードが存在するか知る必要がある場合を考えます。与えられたレコードがデータベースの列と同等であるか確認するためにexists()メソッドを使うことができます。

<code type="php">
$record = new User();

$record->exists(); // false

$record->name = 'someone';
$record->save();

$record->exists(); // true
</code>

+++ カラムに対するファンクションコールバック

{{Doctrine_Record}}はカラムの値に対してコールバックコールを追加する方法を提供します。例えばあるカラムをtrimしたい場合、次のように入力します:

<code type="php">
$record->call('trim', 'column1');
</code>

++ コレクション

{{Doctrine_Collection}}はレコードのコレクションです({{Doctrine_Record}}を参照)。レコードに関して{{Doctrine_Collection::delete()}}と{{Doctrine_Collection::save()}}を使用してコレクションはそれぞれ削除され保存されます。

DQLのAPI({{Doctrine_Query}}を参照)もしくはrawSqlのAPI({{Doctrine_RawSql}}を参照)のどちらかでデータベースからデータを取得するとき、メソッドはデフォルトで{{Doctrine_Collection}}のインスタンスを返します。

次の例は新しいコレクションを初期化する方法を示しています:

<code type="php">
$conn = Doctrine_Manager::getInstance()
        ->openConnection(new PDO("dsn", "username", "pw"));

// 新しいコレクションを初期化する
$users = new Doctrine_Collection($conn->getTable('User'));

// 代替方法(おそらくより簡単)
$users = new Doctrine_Collection('User');

// データを追加する
$users[0]->name = 'Arnold';

$users[1]->name = 'Somebody';

// 最後に保存する！
$users->save();
</code>


+++ 要素にアクセスする

{{set()}}メソッドと{{get()}}メソッドもしくは{{ArrayAccess}}インターフェイスで{{Doctrine_Collection}}の要素にアクセスできます。

<code type="php">
$table = $conn->getTable("User");

$users = $table->findAll();

// ArrayAccessインターフェイスで要素にアクセスする

$users[0]->name = "Jack Daniels";

$users[1]->name = "John Locke";

// get()で要素にアクセスする

print $users->get(1)->name;
</code>


+++ 新しい要素を追加する

コレクションの単独要素にアクセスしてそれらの要素(レコード)が存在しないときDoctrineは自動的にそれらを追加します。

次の例においてデータベースからすべてのユーザー(5つ存在する)を取得しユーザーの組をコレクションに追加します。

PHPの配列に関してインデックスは0から始まります。

<code type="php">
$users = $table->findAll();

print count($users); // 5

$users[5]->name = "new user 1";
$users[6]->name = "new user 2";
</code>


+++ コレクションカウントを取得する

{{Doctrine_Collection}}のメソッドである{{count()}}はコレクションの現在の要素数を返します。

<code type="php">
$users = $table->findAll();

print $users->count();
</code>

{{Doctrine_Collection}}はCountableインターフェイスを実行するので以前の例に対して有効な代替方法はcount()関数に対してコレクションを引数として渡すことです。

<code>
print count($users); // Doctrine_CollectionはCountableインターフェイスを実装する
</code>


+++ コレクションを保存する

{{Doctrine_Record}}と同じようにコレクションは{{save()}}メソッドを呼び出すことで保存されます。save()が呼び出されたときDoctrineはすべてのレコードに対してsave()オペレーションを行いトランザクションにおける全体の処理をラップします。

<code type="php">
$users = $table->findAll();

$users[0]->name = 'Jack Daniels';

$users[1]->name = 'John Locke';

$users->save();
</code>


+++ コレクションを削除する

Doctrineのコレクションを削除する方法はDoctrine Recordsとまったく同じで{{delete()}}メソッドを呼び出すだけです。コレクションに関してDoctrineはsingle-shot-deleteを実行する方法を知っています。これはそれぞれのコレクションに対して一つのデータベースクエリのみを実行することを意味します。

例えばユーザーのコレクションを考えてみます。ユーザーのコレクションを削除するときDoctrineはこの全体のトランザクションに対して一つのクエリのみを実行します。クエリは次のようになります:

<code type="sql">
DELETE FROM user WHERE id IN (1,2,3, ... ,N)
</code>

+++ キーマッピング

コレクションの要素に対して通常のインデックス化作業を使いたくないことがあります。例えば、主キーをコレクションキーとしてマップすると便利なことがあります。次の例はどのように実現するのか示しています。

<code type="php">
// idカラムをマップする

$user = new User();

$user->setAttribute(Doctrine::ATTR_COLL_KEY, 'id');

// ユーザーコレクションはidカラムを
// 要素インデックスとして使用する

$users = $user->getTable()->findAll();

foreach($users as $id => $user) {
    print $id . $user->name;
}

// nameカラムをマップする

$user = new User();

$user->setAttribute(Doctrine::ATTR_COLL_KEY, 'name');

// ユーザーコレクションはnameカラムを
// 要素インデックスとして使用する

$users = $user->getTable()->findAll();

foreach($users as $name => $user) {
    print $name . $user->type;
}
</code>


+++ 関連レコードをロードする

Doctrineはすべてのレコード要素に対して関連したレコードのすべてを効率的に取得する方法を提供します。このことは例えばユーザーのコレクションがあるとき{{loadRelated()}}メソッドを呼び出すことですべてのユーザーに対する電話番号をロードできることを意味します。

しかしながら、大抵の場合明示的に関連した要素をロードする必要はありません。もしろすべきことはDQLのAPIとJOINを使用して一度にすべてをロードしてみることです。

次の例はユーザーと、ユーザーの電話番号、ユーザーが所属するグループを取得するために、3つのクエリーを使用しています。

<code type="php">
$users = $conn->query('FROM User');

// すべてのユーザーに対する電話番号をロードする

$users->loadRelated('Phonenumber');

foreach($users as $user) {
    print $user->Phonenumber[0]->phonenumber;
    // ここでは追加のDBクエリーは必要なし
}

// loadRelatedはリレーション、アソシエーションでさえも動作させる:

$users->loadRelated('Group');

foreach($users as $user) {
    print $user->Group[0]->name;
}
</code>

上記の例はDQLのAPIを使用することでより効率的な方法を示します。

<code type="php">
// ここですべてのものをロードする
$users = $conn->query('FROM User u LEFT JOIN u.Phonenumber p LEFT JOIN u.Group g');

foreach($users as $user) {
    // ここでは追加のDBクエリーは必要無し
    print $user->Phonenumber->phonenumber;

    print $user->Group->name;
}
</code>

++ 接続

Doctrine_Connectionはデータベース接続のためのラッパーです。次の内容を取り扱います: 

*  PDOから失われているデータベースの可搬性に関することを取り扱う(例えば{{LIMIT}} / {{OFFSET}}のエミュレーション)
*  {{Doctrine_Table}}オブジェクトの経過を追う
*  レコードの経過を追う
*  更新/追加/削除される必要のあるレコードの経過を追う
*  トランザクションとトランザクションネスティングを取り扱う
*  {{INSERT}} / {{UPDATE}} / {{DELETE}}オペレーションに関して、データベースの実際のクエリー発行を取り扱う
*  DQLのAPIを利用してデータベースにクエリーを行うことができる({{Doctrine_Query}}を参照)
*  オプションで{{Doctrine_Validator}}を利用してトランザクションを検証し 起こりうるエラーの全情報を提供する。


+++ 利用可能なドライバ

DoctrineはｓべてのPDOでサポートされているデータベースのためのドライバを持っています。サポートされているデータベースは次の通りです:

* FreeTDS / Microsoft SQL Server / Sybase
* Firebird/Interbase 6
* Informix
* Mysql
* Oracle
* Odbc
* PostgreSQL
* Sqlite


+++ テーブルオブジェクトを取得する

指定されたレコードからテーブルオブジェクトを取得するためにcall {{Doctrine_Record::getTable()}}もしくは{{Doctrine_Connection::getTable()}}を呼び出すだけです。

<code type="php">
$manager = Doctrine_Manager::getInstance();

// 新しい接続を開く

$conn = $manager->openConnection(new PDO('dsn','username','password'));

// テーブルオブジェクトを取得する

$table = $conn->getTable('User');
</code>


+++ 接続を有効にする

新しいレコード(データベースの列)を作ることはとても簡単です。それを行うもしくは新しいオペレータを単に使うために{{Doctrine_Connection::create()}}メソッドもしくは {{Doctrine_Table::create()}}メソッドのどちらかを利用できます

<code type="php">
$user = new User();
$user->name = 'Jack';

$group = $conn->create('Group');
$group->name = 'Drinking Club';

// すべての変更されたオブジェクトをデータベースに保存する

$conn->flush();
</code>


+++ データベースにクエリを行う

{{Doctrine_Connection::query()}}は効率的なオブジェクト取得のためのシンプルなメソッドです。このメソッドは一つのパラメータ(DQLのクエリ)とオプションとしてプリペアードステートメントのパラメータを取ります。

<code type="php">

// すべてのユーザーをselectする

$users = $conn->query('FROM User');

// Eメールがjackdaniels@drinkmore.info であるすべてのユーザーをselectする

$users = $conn->query("FROM User WHERE User.Email.address = 'jackdaniels@drinkmore.info'");

// プリペアードステートメントを使う

$users = $conn->query('FROM User WHERE User.name = ?', array('Jack'));
</code>



++ テーブル
{{Doctrine_Table}}は与えられたコンポーネント(レコード)によって指定されたスキーマ情報を保持します。例えばDoctrine_Recordクラスを拡張するUserクラスがある場合、それぞれのスキーマ定義コールは後の使用のために情報を保持するユニークなテーブルオブジェクトにデリゲートされます。

それぞれの{{Doctrine_Table}}は{{Doctrine_Connection}}によって登録されます 。このことは適切なコンポーネント名を持ったgetTable()メソッドを呼び出すことで接続からテーブルを取得できることを意味します。

例えば、Userクラスのためにテーブルオブジェクトを取得することを考えてみましょう。単にgetTable()メソッドに対して'User'を最初の引数として渡すことでこれを行うことができます。

<code>
// 現在の接続を取得する
$conn = Doctrine_Manager::connection();

$table = $conn->getTable('User');
</code>

+++ カラム情報を取得する

適切な{{Doctrine_Table}}メソッドを使用して、{{Doctrine_Record}}のカラム定義セットを取得できます。すべてのカラムのすべての情報が必要な場合、次のように簡単に使えます:

<code type="php">
// すべてのカラムのすべての情報を取得する
$columns = $table->getColumns();
</code>

ときにこれはやりすぎになることがあります。次の例はカラム名を配列として取得する方法を示します:

<code>
// カラム名を取得する
$names = $table->getColumnNames();
</code>

+++ リレーション情報を取得する


+++ ファインダーメソッド

{{Doctrine_Table}}は基本的なファインダメソッドを提供します。これらのファインダメソッドはとても速く一つのデータベーステーブルからデータを取得します。いくつかのコンポーネント(データベーステーブル)を使用するクエリーが必要な場合{{Doctrine_Connection::query()}}を使用して下さい。

<code type="php">
$table = $conn->getTable("User");

// 主キーでfindする

$user = $table->find(2);

if($user !== false)
    print $user->name;


// すべてのユーザーを取得する
foreach($table->findAll() as $user) {
    print $user->name;
}

// DQLでfindする
foreach($table->findByDql("name LIKE '%John%'") as $user) {
    print $user->created;
}
</code>


++++ カスタムのテーブルクラス

カスタムのテーブルクラスを追加するのはとても簡単です。唯一必要なことはクラスの名前を{{[componentName]Table}}と名付けて{{Doctrine_Table}}から継承させることです。

<code type="php">

// 有効なテーブルオブジェクト

class UserTable extends Doctrine_Table 
{
}

// [Doctrine_Table]を正しく拡張していない
class GroupTable { }
</code>


+++ カスタムのファインダー

カスタムのファインダメソッドをカスタムのテーブルオブジェクトに追加できます。これらのファインダメソッドは速い {{Doctrine_Table}}ファインダメソッドもしくはDQLのAPI({{Doctrine_Connection::query()}})を使用します。

<code type="php">
class UserTable extends Doctrine_Table {
    /**
     * 独自のファインダメソッドをここで追加できる
     */
    public function findByName($name) {
        return $this->getConnection()->query("FROM User WHERE name LIKE '%$name%'");
    }
}
class User extends Doctrine_Record { }

$conn = Doctrine_Manager::getInstance()
           ->openConnection(new PDO("dsn","username","password"));

// DoctrineはUserTableという名前のクラスが存在するか
// そしてそれがDoctrine_Tableを継承しているか確認をする

$table   = $conn->getTable("User");

print get_class($table); // UserTable

$users   = $table->findByName("Jack");

</code>

++ バリデータ
+++ 導入

Doctrineでのバリデーション(Validation・検証)はMBCアーキテクチャのモデル部分であなたのビジネスルールを強制する方法です。このバリデーションをデータが持続的に保存される前に正しく渡される必要のあるゲートウェイとして見なすことができます。これらのビジネスルールの定義はレコードレベル、つまり、アクティブなレコードモデル({{Doctrine_Record}}から由来するクラス)、で行われます。この種のバリデーションを使うためにあなたが最初にする必要のあることはそれをグローバルに有効にすることです。これは{{Doctrine_Manege}}を通して行われます(下記のコードを参照)。

一旦バリデーションを有用にすると、たくさんのバリデーションが自動的に利用できます:

* **データ型のバリデーション**: カラムに割り当てられたすべての値は正しい型であるか確認されます。このことはレコードのカラムを'integer'型として指定した場合、Doctrineはこのカラムに割り当てられたどどの値もこの型に当てはまることを検証します。PHPは型の緩い言語なのでこの種のバリデーションはできる限りスマートにしようとします。例えばは2は"7"と同様に両方ともバリッドな整数型であるの対して"3f"はそうではありません。型バリデーションはすべてのカラム上で行われます(すべてのカラム定義が一つの型を必要とするからです)。
* **長さのバリデーション**: 名前が示すように、カラムに割り当てられたすべての値は値が最大値を超えないことを確認するために検証されます。

<code type="php">
// バリデーションを有効にする
Doctrine_Manager::getInstance()->setAttribute(Doctrine::ATTR_VALIDATE, Doctrine::VALIDATE_ALL);
</code>

ビット単位のオペレーションで次の定数を結びつけることができます: VALIDATE_ALL, VALIDATE_TYPES, VALIDATE_LENGTHS, 
VALIDATE_CONSTRAINTS, VALIDATE_NONE. 例えば、長さのバリデーション以外のすべてのバリデーションを有効にするために次のように設定します:
<code>
VALIDATE_ALL & ~VALIDATE_LENGTHS
</code>

+++ さらなるバリデーション

型と長さのバリデーションは手軽ですが大抵の場合それらだけでは十分ではありません。そのためDoctrineはより詳細なデータをバリデートするために使用できるメカニズムを提供します。

バリデータはさらなるバリデーションを指定するための簡単な方法です。DoctrineはEメール、国、IP、範囲と正規表現バリデータなどよく必要になる、多くのあらかじめ定義されたバリデータを持ちます。このページの一番下に利用可能なバリデータの全リストが見つかります。{{hasColumn()}}メソッドの4番目の引数を通してバリデータをカラムに適用することを指定できます。それでも重ｂんではなくあらかじめ定義されたバリデータとして利用できない特化したバリデーションが必要な場合3つの選択肢があります:

* 独自のバリデータを書く。
* 新しいバリデータを書くようにDoctrineの開発者に提案する。
* バリデーションフックを使う。

バリデーションが一般的で潜在的に多くの状況に適用できるなら最初の2つのオプションが望ましいです。その場合新しいバリデータを実装することはよいアイディアです。しかしバリデーションは特別な場合Doctrineによって提供されたフックを使うことがベターです:

* {{validate()}} (レコードがバリデートされるたびに実行される)
* {{validateOnInsert()}} (新しいレコードがバリデートされるたびに実行される)
* {{validateOnUpdate()}} (新しくないレコードがバリデートされるたびに実行される)

アクティブレコードで特別なバリデーションが必要な場合アクティブレコードクラスでこれらのメソッドの一つを簡単にオーバーライドできます({{Doctrine_Record}}の子孫)。これらのメソッドの範囲内でフィールドをバリデートするためにPHPのすべてのパワーを使うことができます。フィールドがバリデーションを渡さないときエラーをレコードエラースタックに追加できます。次のコードスニペットはカスタムバリデーションと一緒にバリデータを定義する方法を示しています:

<code type="php">
class User extends Doctrine_Record 
{
    public function setUp() 
    {
        $this->hasOne('Email', array('local' => 'email_id'));
    }
    public function setTableDefinition() 
    {
        // 特別なバリデータは使用されず
        //型と長さのみがバリデートされる
        $this->hasColumn('name', 'string', 15);
        $this->hasColumn('email_id', 'integer');
        $this->hasColumn('created', 'integer', 11);
    }
    // 独自のバリデーション
    protected function validate() 
    {
        if ($this->name == 'God') {
            // 冒涜です！ おやめ下さい ;-)
            // 構文: add(<fieldName>, <error code/identifier>)
            $this->getErrorStack()->add('name', 'forbiddenName');
        }
    }
}
class Email extends Doctrine_Record {
    public function setTableDefinition() {
        // バリデータの'email'と'unique'が使用される
        $this->hasColumn("address","string",150, array("email", "unique"));
    }
}  
</code>


+++ 有効もしくは無効

現在あなたのモデルでビジネスルールを指定する方法を理解しているので、アプリケーションの残りでこれらのルールを取り扱う方法を見てみましょう。

++++ 暗黙のバリデーション

レコードが持続的データストアに保存されようとしているときはいつでも (すなわち{{$record->save()}}を呼び出すことを通して) バリデーションの全手続きが実行されます。この処理の間にエラーが発生する場合{{Doctrine_Validator_Exception}}タイプの例外がスローされます。 {{Doctine_Validator_Exception::getInvalidRecords()}}のインスタンスメソッドを使って例外をキャッチしてこのエラーを分析できます。このメソッドはバリデーションに渡されなかったレコードへの参照を持つ通常の配列を返します。それぞれのレコードのエラースタックを分析することでそれぞれのレコードのエラーをさらに調べることができます。レコードのエラースタックは{{Doctrine_Record::getErrorStack()}}インスタンスメソッドで取得できます。 それぞれのエラースタックは{{Doctrine_Validator_ErrorStack}}クラスのインスタンスです。エラースタックはエラーを検査するインターフェイスを使用するための簡単な方法を提供します。

++++ 明示的なバリデーション

いつでもどのレコードに対しても明示的にバリデーションを起動できます。この目的のためにDoctrine_Recordは{Doctrine_Record::isValid()}}インスタンスメソッドを提供します。このメソッドはバリデーションの結果を示すbooleanの値を返します。メソッドがfalseを返す場合、例外がスローされてないことを除けば上記と同じ方法でエラースタックを検査できるので{{Doctrine_Record::getErrorStack()}}を通してバリデーションを渡さなかったレコードのエラースタックを入手します。

次のコードスニペットは{{Doctrine_Validator_Exception}}を引き起こす明示的なバリデーションの例を示します。

<code type="php">
try {
    $user->name = "this is an example of too long name";
    $user->Email->address = "drink@@notvalid..";
    $user->save();
} catch(Doctrine_Validator_Exception $e) {
    // 注: $e->getInvalidRecords()も利用できる。ここで使用されている
    // 直接の方法は取り扱うレコードを知っているときはよりシンプルである
    $userErrors = $user->getErrorStack();
    $emailErrors = $user->Email->getErrorStack();
    
    /* ユーザーのエラーを検査する */
    foreach($userErrors as $fieldName => $errorCodes) {
        switch ($fieldName) {
            case 'name':
                // $user->nameが無効である。必要ならエラーコードを検査する。
            break;
        }
    }
    
    /* Eメールのエラーを検査する */
    foreach($emailErrors as $fieldName => $errorCodes) {
        switch ($fieldName) {
            case 'address':
                // $user->Email->addressが無効である。必要ならエラーコードを検査する。
            break;
        }
    }
}
</code>



++ プロファイラ
+++ 導入
{{Doctrine_Connection_Profiler}}は{{Doctrine_Connection}}に対するイベントリスナーで、柔軟なクエリープロファイリングを提供します。SQLの文字列に加えてクエリープロファイルはクエリーを実行する経過時間を含みます。これによってクエリの検査は追加のデバッギング用のコードをモデルクラスに追加することなく実行できます。

{{Doctrine_Connection_Profiler}}は{{Doctrine_Connection}}に対するイベントリスナーとして有効になります。

<code type="php">
$conn = Doctrine_Manager::connection($dsn);

$profiler = new Doctrine_Connection_Profiler();

$conn->setListener($profiler);
</code>
+++ 基本的な使い方

おそらくいくつかのページは遅くロードされます。次のコードは接続から完全なプロファイラレポートをビルドする方法を示します:

<code type="php">
$time = 0;
foreach ($profiler as $event) {
    $time += $event->getElapsedSecs();
    echo $event->getName() . " " . sprintf("%f", $event->getElapsedSecs()) . "<br>\n";
    echo $event->getQuery() . "<br>\n";
    $params = $event->getParams();
    if( ! empty($params)) {
        var_dump($params);
    }
}
echo "Total time: " . $time  . "<br>\n";
</code>

+++ 高度な使い方


++ マネージャーをロッキングする
+++ 導入

[**注**: 'Transaction'という用語はデータベースのトランザクションではなくこの用語の一般的な意味を言及しています]

[**注**: このコンポーネントは**Alpha版**です]

ロッキングは同時並行性を制御するメカニズムです。2つのもっともよく知られるロッキングは楽観的(optimistic)と悲観的(pessimistic)ロッキングです。 以下の記事ではこれらの戦略のうち現時点でDoctrineによってサポートされているペシミスティックロッキングについての手短な説明です。

**楽観的ロッキング:**

オブジェクトの状態/バージョンはトランザクションが始まるときに記録されます。トランザクションが終了したとき記録されたあとに追加されたオブジェクトの記録された状態/バージョンは現在の状態/バージョンと比較されます。状態/バージョンが別のトランザクションによって修正されたオブジェクトと異なる場合は現在のトランザクションが失敗します。この方法は'(オプティミスティック)optimistic'と呼ばれます。なぜなら数人のユーザーが同時に同じオブジェクトに参加することが見込みないことを前提としているからです。 

**悲観的ロッキング:**

トランザクションに加入する必要のあるオブジェクトはユーザーがトランザクションを始めた瞬間にロックされます。他のユーザーはロックがアクティブである間にこれらのオブジェクト上で実行するトランザクションを始めることはできません。これによってトランザクションを始める一人のユーザーの作業が終わるまで他のユーザーが同じオブジェクトを修正できないことが保証されます。

Doctrineの悲観的オフラインロッキングの能力はいくつかのHTTPリクエストとリスポンスサイクルかつ/もしくは完了させるのに多くの時間がかかるアクションとプロシージャ間に同時並行性を制御するために使うことができます。


+++ 例

次のコードスニペットはDoctrineの悲観的オフラインロッキング能力の使用を実際に示しています。

ロックがリクエストされたページ上です...

<code type="php">

// ロッキングマネージャーのインスタンスを取得する
$lockingMngr = new Doctrine_Locking_Manager_Pessimistic();

try
{
    // 我々のロックを得ることを試す前に
    // タイムアウトした古いロックが開放されることを保証する
    // 300秒 = 5分のタイムアウト
    $lockingMngr->releaseAgedLocks(300);

    // レコード上でロックの取得を試みる
    $gotLock = $lockingMngr->getLock(
     // ロックするレコード。これはどのDoctrine_Recordにもなり得る
                        $myRecordToLock,
    // ロックの取得を試みるユーザーのユニークな識別子
                       'Bart Simpson'
               );

    if($gotLock)
    {
        echo "Got lock!";
        // ... 処理される
    }
    else
    {
        echo "Sorry, someone else is currently working on this record";
    }
}
catch(Doctrine_Locking_Exception $dle)
{
    echo $dle->getMessage();
    // エラーを取り扱う
}

</code>

トランザクションが終了するページ上にて...

<code type="php">
// ロッキングマネージャーを取得する
$lockingMngr = new Doctrine_Locking_Manager_Pessimistic();

try
{
    if($lockingMngr->releaseLock($myRecordToUnlock, 'Bart Simpson'))
    {
        echo "Lock released";
    }
    else
    {
        echo "Record was not locked. No locks released.";
    }
}
catch(Doctrine_Locking_Exception $dle)
{
    echo $dle->getMessage();
    // エラーを取り扱う
}
</code>


+++ 計画

* 特定のRecord型のロックを開放する能力(すなわち'User'オブジェクト上ですべてのロックを開放します)。

+++ 技術的な詳細

悲観的オフラインロッキングマネージャーはデータベースでロックを貯蔵します(それゆえ'offline'です)。マネージャーのインスタンスを初期化しようとしてATTR_CREATE_TABLESがTRUEに設定されているときに要求されるロッキングテーブルは自動的に作成されます。この振る舞いはインストール作業の目的のために集中型で一貫したテーブル作成手続きを提供するために将来変更される可能性があります。


+++ メンテナー

Roman Borschel - romanb at #doctrine (freenode)

質問、アイディアなどが存在する場合ご遠慮なく連絡して下さい。


++ ビュー
+++ 導入

データベースビューは複雑なクエリーのパフォーマンスを多いに向上させます。それらをキャッシュされたクエリーとして見なすことができます。{{Doctrine_View}}はデータベースビューとDQLクエリー間の統合を提供します。


+++ ビューを管理する

<code type="php">
$conn = Doctrine_Manager::getInstance()
        ->openConnection(new PDO("dsn","username","password"));

$query = new Doctrine_Query($conn);
$query->from('User.Phonenumber')->limit(20);

$view  = new Doctrine_View($query, 'MyView');

// データベースビューを作成する
$view->create();

// データベースからビューをドロップする
$view->drop();
</code>


+++ ビューを使う

<code type="php">
$conn = Doctrine_Manager::getInstance()
        ->openConnection(new PDO("dsn","username","password"));

$query = new Doctrine_Query($conn);
$query->from('User.Phonenumber')->limit(20);

// クエリーを適切なビューにフックする
$view  = new Doctrine_View($query, 'MyView');

// ビューからデータを取得する
$coll  = $view->execute();
</code>
