The PHP Doctrine ORM offers a fully featured database migration utility that makes it easy to upgrade your databases for both schema and 
data changes without having to manually write or keep up with SQL statements.

Database migrations essentially allow you to have multiple versions of your schema. A single Doctrine migration class represents one
version of the schema. Each migration class must have an up() and a down() method defined and the down() must negate everything done in 
the up() method. Below I will show you an example of how to use Doctrine to control your database.

<code>
This tutorial is written for symfony 1.1 but the same functionality exists for the 1.0 version of sfDoctrinePlugin but in the 1.0 
style task system.
</code>

++ Setting up your database

First thing we need to do is define your database and create it. Edit config/databases.yml and setup your mysql database. Copy and 
paste the yaml below in to the file.

<code type="yaml">
all:
  doctrine:
    class:    sfDoctrineDatabase
    param:
      dsn:    mysql://root:@localhost/symfony11Doctrine
</code>

++ Define your schema

In this example we are going to use a traditional Blog model. Open config/doctrine/schema.yml and copy and paste the yaml contents from 
below in to the file.

<code type="yaml">
---
BlogPost:
  actAs:
    Sluggable:
      fields: [title]
  columns:
    title: string(255)
    body: clob
    author: string(255)
  relations:
    Tags:
      class: Tag
      refClass: BlogPostTag
      foreignAlias: BlogPosts

BlogPostTag:
  columns:
    blog_post_id:
      type: integer
      primary: true
    tag_id:
      type: integer
      primary: true

Tag:
  columns:
    name: string(255)
</code>

Place the below data fixtures in to data/fixtures/data.yml

<code type="yaml">
---
BlogPost:
  BlogPost_1:
    slug: symfony-doctrine
    author: Jonathan H. Wage
    title: symfony + Doctrine
    body: symfony and Doctrine are great!
    Tags: [symfony, doctrine, php]

Tag:
  symfony:
    name: symfony
  doctrine:
    name: doctrine
  php:
    name: php
</code>

++ Build Database

Now with one simple command Doctrine is able to create the database, the tables and load the data fixtures for you. Doctrine works 
with any [PDO](http://www.php.net/pdo) driver and is able to drop and create databases for any of them.

<code>
$ ./symfony doctrine-build-all-reload frontend
>> doctrine  Are you sure you wish to drop your databases? (y/n)
y
>> doctrine  Successfully dropped database f...1.1Doctrine/config/doctrine.db"
>> doctrine  Successfully created database f...1.1Doctrine/config/doctrine.db"
>> doctrine  Generated models successfully
>> doctrine  Created tables successfully
>> doctrine  Data was successfully loaded
</code>

Now your database, models and tables are created for you so easily. Lets run a simple DQL query to see the current data that is in the 
database so we can compare it to the data after the migration has been performed.

<code>
$ ./symfony doctrine-dql frontend "FROM BlogPost p, p.Tags t"
>> doctrine  executing: "FROM BlogPost p, p.Tags t" ()
>> doctrine  - 
>> doctrine    id: 1
>> doctrine    title: symfony + Doctrine
>> doctrine    body: symfony and Doctrine are great!
>> doctrine    author: Jonathan H. Wage
>> doctrine    slug: symfony-doctrine
>> doctrine    Tags: 
>> doctrine      - 
>> doctrine        id: 1
>> doctrine        name: symfony
>> doctrine      - 
>> doctrine        id: 2
>> doctrine        name: doctrine
>> doctrine      - 
>> doctrine        id: 3
>> doctrine        name: php
</code>

++ Setup Migration

Now what if a few months later you want to change the schema to split out the BlogPost.author column to an Author model that is related 
to BlogPost.author_id. First lets add the new model to your config/doctrine/schema.yml. Replace your schema yaml with the schema 
information from below.

<code type="yaml">
---
BlogPost:
  actAs:
    Sluggable:
      fields: [title]
  columns:
    title: string(255)
    body: clob
    author: string(255)
    author_id: integer
  relations:
    Author:
      foreignAlias: BlogPosts
    Tags:
      class: Tag
      refClass: BlogPostTag
      foreignAlias: BlogPosts

BlogPostTag:
  columns:
    blog_post_id:
      type: integer
      primary: true
    tag_id:
      type: integer
      primary: true

Tag:
  columns:
    name: string(255)

Author:
  columns:
    name: string(255)
</code>

Rebuild your models now with the following command.

<code>
$ ./symfony doctrine-build-model
>> doctrine  Generated models successfully
</code>

As you see we have added a new Author model, and changed the author column to author_id and integer for a foreign key to the Author
model. Now lets write a new migration class to upgrade the existing database without losing any data. Run the following commands 
to create skeleton migration classes in lib/migration/doctrine. You will see a file generated named 001_add_author.class.php and
002_migrate_author.class.php. Inside them are blank up() and down() method for you to code your migrations for the schema changes above.

<code>
$ ./symfony doctrine:generate-migration frontend AddAuthor
>> doctrine  Generated migration class: AddA...Doctrine/lib/migration/doctrine
$ ./symfony doctrine:generate-migration frontend MigrateAuthor
>> doctrine  Generated migration class: Migr...Doctrine/lib/migration/doctrine
</code>

Now we have 2 blank migration skeletons to write our migration code in. Below I have provided the code to migrate the author column
to an Author model and automatically relate blog posts to the newly created author id.

<code type="php">
// 001_add_author.class.php
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class AddAuthor extends Doctrine_Migration
{
	public function up()
	{
	  // Create new author table
	  $columns = array('id'   => array('type'          => 'integer',
	                                   'length'        => 4,
	                                   'autoincrement' => true),
	                   'name' => array('type'          => 'string',
	                                   'length'        => 255));

    $this->createTable('author', $columns, array('primary' => array('id')));

    // Add author_id to the blog_post table
    $this->addColumn('blog_post', 'author_id', 'integer', array('length' => 4));
	}

	public function down()
	{
	  // Remove author table
    $this->dropTable('author');

    // Remove author_id column from blog_post table
    $this->removeColumn('blog_post', 'author_id');
	}
}

// 002_migrate_author.class.php
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class MigrateAuthor extends Doctrine_Migration
{
  public function preUp()
  {
    $q = Doctrine_Query::create()
          ->select('p.id, p.author')
          ->from('BlogPost p');

    $blogPosts = $q->execute();
    foreach ($blogPosts as $blogPost)
    {
      $author = Doctrine::getTable('Author')->findOneByName($blogPost->author);
      if ( ! ($author instanceof Author && $author->exists()))
      {
        $author = new Author();
        $author->name = $blogPost->author;
        $author->save();
      }
      $blogPost->author_id = $author->id;
      $blogPost->save();
    }
  }

	public function up()
	{
    $this->removeColumn('blog_post', 'author');
	}

	public function down()
	{
	  $this->addColumn('blog_post', 'author', 'string', array('length' => 255));
	}
}
</code>
Now run the following command and Doctrine will automatically perform the migration process and update the database.

++ Run Migration

<code>
$ ./symfony doctrine-migrate frontend
>> doctrine  migrated successfully to version #2
</code>

Now the database is updated with the new schema information and data migrated. Give it a check and you will see that we have a new 
author table, the blog_post.author column is gone and we have a new blog_post.author_id column that is set to the appropriate author 
id value.

The #2 migration removed the author column from the blog_post table, but we left it in the model definition so that while it still 
existed, before the #2 migration began we copied the contents of the author column to the author table and related the blog_post to
the author id. You can now remove the author: string(255) column definition from the config/doctrine/schema.yml and rebuild the models.
Here is the new BlogPost model definition.

<code>
---
BlogPost:
  actAs:
    Sluggable:
      fields: [title]
  columns:
    title: string(255)
    body: clob
    author_id: integer
  relations:
    Author:
      foreignAlias: BlogPosts
    Tags:
      class: Tag
      refClass: BlogPostTag
      foreignAlias: BlogPosts
</code>

Re-build the models now since we removed the author column from the model definition and the table in the database.

<code>
$ ./symfony doctrine-build-model
>> doctrine  Generated models successfully
</code>

Now lets run a DQL query from the command line to see the final product.

<code>
$ ./symfony doctrine:dql frontend "FROM BlogPost p, p.Tags, p.Author a"
>> doctrine  executing: "FROM BlogPost p, p.Tags, p.Author a" ()
>> doctrine  - 
>> doctrine    id: 1
>> doctrine    title: symfony + Doctrine
>> doctrine    body: symfony and Doctrine are great!
>> doctrine    author_id: 1
>> doctrine    slug: symfony-doctrine
>> doctrine    Tags: 
>> doctrine      - 
>> doctrine        id: 1
>> doctrine        name: symfony
>> doctrine      - 
>> doctrine        id: 2
>> doctrine        name: doctrine
>> doctrine      - 
>> doctrine        id: 3
>> doctrine        name: php
>> doctrine    Author: 
>> doctrine      id: 1
>> doctrine      name: Jonathan H. Wage
</code>

If you compare the data returned here, to the data that was returned in the beginning of this tutorial you will see that the author 
column was removed and migrated to an Author model.